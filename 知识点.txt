25 ***

    var a = new Array( 3 );
    var b = [ undefined, undefined, undefined ];
    var c = [];

```
    a.join( "-" ); // "--"
    b.join( "-" ); // "--"

    a.map(function(v,i){ return i; }); // [ undefined x 3 ]
    b.map(function(v,i){ return i; }); // [ 0, 1, 2 ]
```

24 ***

`数组`构造函数只带一个`数字`参数时，该参数会被当作数组的预设大小（length），而非数组中的一个元素。

这实在不是一个明智的做法，容易让人忽视和犯错。

更要命的是，`数组`并没有预设大小这个概念。这样创建出来的只是一个空数组（empty array），只不过其`length`属性被设置成了指定的值。

23 ***

通常我们不需要直接使用封装。最好是让JS引擎自己决定什么时候使用封装。换句话说就是应该优先考虑使用`"abc"`和`42`这样的基本类型值，而非`new String("abc")`和`new Number(42)`。

```
    var a = new Boolean( false );
    
    if (!a) {
        console.log( "Oops" ); // never returns
    }
```

这里的问题是，我们为`false`值创建了一个封装对象，但对象是真值（即“truthy”，总是返回`true`，见`第四章`），所以使用封装对象和使用`false`值的结果大相径庭。

如果你想要得到封装对象内的基本类型值，可以使用`valueOf()`函数

22 ****

封装对象扮演的角色十分重要。因为基本类型值没有属性和方法，我们需要通过封装对象来访问`.length`和`.toString()`，此时JS会自动为基本类型值*包装*（box或者wrap）一个封装对象：

```
    var a = "abc";
    
    a.length; // 3
    a.toUpperCase(); // "ABC"
```

21 ***

```
    Object.prototype.toString.call( [1,2,3] );
    // "[object Array]"

    Object.prototype.toString.call( /regex-literal/i );
    // "[object RegExp]"
```

20 ****

反之，如果要象引用那样，将标量基本值传递到函数内并进行更改，就需要将该值封装到一个复合值（`对象`，`数组`，或其他）中，通过引用拷贝的方式传递。

```
    function foo(wrapper) {
        wrapper.a = 42;
    }

    var obj = { 
        a: 2
    };

    foo( obj );

    obj.a; // 42
```

19 ****

从ES6开始有一个新的工具方法`Object.is(..)`来判断两个值是否严格相等，它可以处理上述所有的特殊情况：

```
    var a = 2 / "foo";
    var b = -3 * 0;

    Object.is( a, NaN );    // true
    Object.is( b, -0 );     // true

    Object.is( b, 0 );      // false
```

在能够安全使用`==`和`===`的情况下（见`第四章`），可以尽量不用`Object.is(..)`，因为前两者效率更高，也更符合习惯，更为通用。`Object.is(..)`主要是针对那些特殊情况。

18 **

负零转换为字符串结果是“`0`”

-0 == 0; 

-0 === 0; 

17 ***

因为从数学运算和JavaScript语言的角度来说，`Infinity / Infinity`是一个未经定义的运算操作。JS中它的运算结果是`NaN`。

那么有穷数正数除以`Infinity`呢？很简单，结果是`0`。有穷负数除以`Infinity`呢？我们后面介绍。

16 ***

```
    var a = 2 / "foo";      // NaN

    typeof a === "number";  // true
```

`NaN != NaN`为`true`

`NaN`有意无意地反映了很多JS程序面临的一个现实问题。它使得我们尽量使用`Number.isNaN(..)`这样的可靠的测试方法，无论是系统内置还是polyfill都是如此。

如果你用到了`isNaN(..)`，很不幸你的代码会有bug。

15 **

在`非严格`和`严格`模式下，你可以声明一个名为`undefined`的局部变量。再次强调我们不建议这样做。

```
   function foo() {
        "use strict";
        var undefined = 2;
        console.log( undefined ); // 2
    }

    foo();
```

14 ***

    if (!Number.EPSILON) {
        ...
    }

    or

    typeof Number.EPSILON == "undefined"

13 ***

```
    0.1 + 0.2 === 0.3; // false
```

12 ***

这些方法不仅适用于`数字`变量，也适用于`数字`常量。不过在使用`.`操作符时需要特别注意，因为它是一个合法的数字字符，它会被尽可能优先识别为`数字`常量的一部分，然后才是对象属性访问操作符。

```
    // invalid syntax:
    42.toFixed( 3 );    // SyntaxError

    // these are all valid:
    (42).toFixed( 3 );  // "42.000"
    0.42.toFixed( 3 );  // "0.420"
    42..toFixed( 3 );   // "42.000"
```

11 ***

此外，很多`数组`函数在处理`字符串`时非常有用，`字符串`中没有这些函数，但我们可以“借用”`数组`的这些非变更方法（nonmutation）来处理`字符串`：

```
    a.join;         // undefined
    a.map;          // undefined

    var c = Array.prototype.join.call( a, "-" );
    var d = Array.prototype.map.call( a, function(v){
        return v.toUpperCase() + ".";
    } ).join( "" );
    
    c;              // "f-o-o"
    d;              // "F.O.O."
```

我们再来看看另外一个例子：`字符串`反转（经常在JavaScript面试中遇到的问题！）。`数组`有一个可变更成员函数`reverse()`，而`字符串`没有：

```
    a.reverse;      // undefined

    b.reverse();    // ["!","o","O","f"]
    b;              // ["f","O","o","!"]
```

遗憾的是，此类“借用”对于`数组`的可变更成员函数不适用，因为`字符串`是不可变的，其内容无法更改：

```
    Array.prototype.reverse.call( a );
    // 返回值仍然是"foo"的一个字符串封装对象（见第三章）:(
```

一个变通（破解）的办法是将`字符串`转换为`数组`，执行需要的操作，然后再转换回`字符串`：

```
    var c = a
        // split `a` into an array of characters
        .split( "" )
        // reverse the array of characters
        .reverse()
        // join the array of characters back to a string
        .join( "" );
    
    c; // "oof"
```

10 **

`字符串`不可变的意思是`字符串`的成员函数都不会改动`字符串`的原始值，而是创建并返回一个新的`字符串`。而`数组`的成员函数都是在其原始值上进行操作。

9 ****

然而有一个容易出错的地方需要我们注意，如果作为键值的`字符串`可以被强制类型转换为10进制`数字`，则系统则视其为`数字`索引而非`字符串`键值！

```
    var a = [ ];
    a["13"] = 42;
    a.length; // 14
```

8 **

`数组`使用数字索引，因为其也是`对象`，因此可以包含字符串键值和属性（并不计算在数组长度`length`内）：

7

```
    // 这样做会产生错误
    if (DEBUG) {
        console.log( "Debugging is starting" );
    }
    // 这样做则是安全的，不会产生错误
    if (typeof DEBUG !== "undefined") {
        console.log( "Debugging is starting" );
    }

```

6

```
    var a;

    typeof a; // "undefined"

    typeof b; // "undefined"
```

5

在JavaScript中变量是没有类型的，只有值才有。变量随时可以持有任意类型的值。

```
    var a = 42;
    typeof a; // "number"

    a = true;
    typeof a; // "boolean"
```

4

那么数组的情况又如何呢？JavaScript本身支持数组，那它是不是也是一个特殊类型？

```
    typeof [1,2,3] === "object"; // true
```

非也，数组也是`object`类型。确切地说是`object`的一个子类型（见`第三章`），其中一个特征是数组中的元素按照数字顺序进行索引（而非普通对象那样是字符串键值），并且`length`属性会根据元素数量自动更新。

3

那么`typeof`的第七个返回值字符串值是什么呢？

```
    typeof function a(){ /* .. */ } === "function"; // true
```

上面`typeof`的返回值容易让我们得出这样一个结论，就是`函数`（function）也是JavaScript的一个内置类型。然而如果你查阅规范就会知道，它实际上是`object`的一个“子类型”（subtype）。具体来说，函数被称为“可调用对象”（callable object），即该对象内部有一个｀\[\[Call\]\]｀属性使得它能够被执行。

2

typeof null === "object"; // true

你需要使用复合条件来检测`null`值的类型，：

```
    var a = null;

    (!a && typeof a === "object"); // true
```

1

JavaScript有七种内置类型：

- null
- undefined
- boolean
- number
- string
- object
- symbol（ES6中新加入）