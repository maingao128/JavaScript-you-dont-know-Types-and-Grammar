37 ***

下面这些值我们称为假值（“falsy” values）：

- `undefined`
- `null`
- `false`
- `+0`，`-0`和`NaN`
- `""`

它们在`boolean`强制类型转换中为`false`。

按理说该列表以外的值应该会被转换为`true`，我们称为真值（“truthy” values）。但JS规范对此并没有明确定义，只给出了一些例子，比如明确规定所有对象都是真值，通常我们可以认为*所有不在假值列表中的值都是真值*。

36 ****

我们常误以为数值`1`和`0`分别等同于`true`和`false`。在有些语言中可能如此，而在JS中`boolean`和`number`是不同的。虽然我们可以将`1`强制类型转换为`true`（反之亦然），将`0`强制类型转换为`false`（反之亦然）。但它们本质上是不同的。

35 ***

####ToNumber

在某些情况下非`数字`值需要被当作`数字`来使用，比如数学运算，ES5规范中第9.3节定义了抽象操作`ToNumber`。

例如，`true`转换为`1`，`false`转换为`0`。`undefined`转换为`NaN`，而`null`则为`0`。

34 ***

我们可以向`JSON.stringify(..)`传递第二个参数，即可选参数（optional argument）*replacer*。它可以是`数组`或者`函数`，通过某种过滤机制来指定哪些属性应该被处理和排除，然后对结果进行序列化，以此来实现对象递归序列化的定制，类似`toJSON()`。

33 ****

JSON字符串化对于包含`toJSON()`方法的对象有一点特别，这时`toJSON()`方法会首先被调用，然后用它的返回值来做序列化。

如果我们要对含有非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要为该对象定义`toJSON()`方法，使之返回一个安全的JSON值。

我们通常会误以为`toJSON()`方法必须返回一个经过JSON字符串化的值。这并不准确，除非我们确实需要字符串化`字符串`（通常不会！）.`toJSON()`应该返回一个适当的值（可以是任何类型），然后再由`JSON.stringify(..)`来对其进行字符串化。

32 ****

ES5规范第9节中定义了一些“抽象操作”（“仅内部使用的操作”的规范用语）及其转换规则。我们这里着重介绍`ToString`，`ToNumber`，和`ToBoolean`，附带讲一讲`ToPrimitive`。

重要的话说两遍，`toString()`可以被显式调用，在非字符串值需要转换为字符串的时候也会被自动调用。

31 ****

将值从一种类型转换为另一种类型通常称为“类型转换”（type casting），这是指显式的情况，在隐式的情况下我们称为“强制类型转换”（coercion，具体怎么转换由值的使用规则来决定）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">JavaScript中强制类型转换总是返回标量基本类型值（见<b>第二章</b>），如：<b>字符串</b>，<b>数字</b>，和<b>布尔值</b>。强制类型转换不会返回<b>对象</b>和<b>函数</b>。在<b>第三章</b>中我们介绍过“封装”，即为标量基本类型值封装一个对应类型的对象，但这并非严格意义上的强制类型转换。</td>
    </tr>
</table>

也可以这样来区分它们：“类型转换”发生在静态类型语言的编译阶段，而“强制类型转换”是发生在动态语言的运行时。

然而在JavaScript中大部份人都将它们统称为*强制类型转换*，我个人倾向于使用“隐式类型转换”和“显式类型转换”。

30 ***

###Prototypes作为默认值

`Function.prototype`是一个空函数，`RegExp.prototype`是一个“空”正则表达式（例如：没有任何匹配），而`Array.prototype`是一个空数组，对于那些还没有被赋值的变量来说它们是不错的缺省值。

例如：

```
    function isThisCool(vals,fn,rx) {
        vals = vals || Array.prototype;
        fn = fn || Function.prototype;
        rx = rx || RegExp.prototype;
        return rx.test(
            vals.map( fn ).join( "" )
        ); 
    }

    isThisCool();       // true
    
    isThisCool(
        ["a","b","c"],
        function(v){ return v.toUpperCase(); },
        /D/
    );                  // false
```

29 ***

任何字符串值都可以通过prototype delegation（参考本系列的*《this & Object Prototypes》*）来访问这些方法：

```
    var a = " abc ";
    
    a.indexOf( "c" ); // 3
    a.toUpperCase();  // " ABC "
    a.trim();         // "abc"
```

28 ***

我们必须遵循一个基本原则：任何情况下都不要创建和使用空单元数组。

27 ****

http://www.w3schools.com/js/js_function_invocation.asp

Invoking a Function with a Function Method
In JavaScript, functions are objects. JavaScript functions have properties and methods.

call() and apply() are predefined JavaScript function methods. Both methods can be used to invoke a function, and both methods must have the owner object as first parameter.

Example
function myFunction(a, b) {
    return a * b;
}
myObject = myFunction.call(myObject, 10, 2);     // Will return 20

Example
function myFunction(a, b) {
    return a * b;
}
myArray = [10, 2];
myObject = myFunction.apply(myObject, myArray);  // Will also return 20

26 ***

http://www.w3schools.com/js/js_function_invocation.asp

The Global Object
When a function is called without an owner object, the value of this becomes the global object.

In a web browser the global object is the browser window.

This example returns the window object as the value of this:

Example
function myFunction() {
    return this;
}
myFunction();                // Will return the window object

25 ***

    var a = new Array( 3 );
    var b = [ undefined, undefined, undefined ];
    var c = [];

```
    a.join( "-" ); // "--"
    b.join( "-" ); // "--"

    a.map(function(v,i){ return i; }); // [ undefined x 3 ]
    b.map(function(v,i){ return i; }); // [ 0, 1, 2 ]
```

24 ***

`数组`构造函数只带一个`数字`参数时，该参数会被当作数组的预设大小（length），而非数组中的一个元素。

这实在不是一个明智的做法，容易让人忽视和犯错。

更要命的是，`数组`并没有预设大小这个概念。这样创建出来的只是一个空数组（empty array），只不过其`length`属性被设置成了指定的值。

23 ***

通常我们不需要直接使用封装。最好是让JS引擎自己决定什么时候使用封装。换句话说就是应该优先考虑使用`"abc"`和`42`这样的基本类型值，而非`new String("abc")`和`new Number(42)`。

```
    var a = new Boolean( false );
    
    if (!a) {
        console.log( "Oops" ); // never returns
    }
```

这里的问题是，我们为`false`值创建了一个封装对象，但对象是真值（即“truthy”，总是返回`true`，见`第四章`），所以使用封装对象和使用`false`值的结果大相径庭。

如果你想要得到封装对象内的基本类型值，可以使用`valueOf()`函数

22 ****

封装对象扮演的角色十分重要。因为基本类型值没有属性和方法，我们需要通过封装对象来访问`.length`和`.toString()`，此时JS会自动为基本类型值*包装*（box或者wrap）一个封装对象：

```
    var a = "abc";
    
    a.length; // 3
    a.toUpperCase(); // "ABC"
```

21 ***

```
    Object.prototype.toString.call( [1,2,3] );
    // "[object Array]"

    Object.prototype.toString.call( /regex-literal/i );
    // "[object RegExp]"
```

20 ****

反之，如果要象引用那样，将标量基本值传递到函数内并进行更改，就需要将该值封装到一个复合值（`对象`，`数组`，或其他）中，通过引用拷贝的方式传递。

```
    function foo(wrapper) {
        wrapper.a = 42;
    }

    var obj = { 
        a: 2
    };

    foo( obj );

    obj.a; // 42
```

19 ****

从ES6开始有一个新的工具方法`Object.is(..)`来判断两个值是否严格相等，它可以处理上述所有的特殊情况：

```
    var a = 2 / "foo";
    var b = -3 * 0;

    Object.is( a, NaN );    // true
    Object.is( b, -0 );     // true

    Object.is( b, 0 );      // false
```

在能够安全使用`==`和`===`的情况下（见`第四章`），可以尽量不用`Object.is(..)`，因为前两者效率更高，也更符合习惯，更为通用。`Object.is(..)`主要是针对那些特殊情况。

18 **

负零转换为字符串结果是“`0`”

-0 == 0; 

-0 === 0; 

17 ***

因为从数学运算和JavaScript语言的角度来说，`Infinity / Infinity`是一个未经定义的运算操作。JS中它的运算结果是`NaN`。

那么有穷数正数除以`Infinity`呢？很简单，结果是`0`。有穷负数除以`Infinity`呢？我们后面介绍。

16 ***

```
    var a = 2 / "foo";      // NaN

    typeof a === "number";  // true
```

`NaN != NaN`为`true`

`NaN`有意无意地反映了很多JS程序面临的一个现实问题。它使得我们尽量使用`Number.isNaN(..)`这样的可靠的测试方法，无论是系统内置还是polyfill都是如此。

如果你用到了`isNaN(..)`，很不幸你的代码会有bug。

15 **

在`非严格`和`严格`模式下，你可以声明一个名为`undefined`的局部变量。再次强调我们不建议这样做。

```
   function foo() {
        "use strict";
        var undefined = 2;
        console.log( undefined ); // 2
    }

    foo();
```

14 ***

    if (!Number.EPSILON) {
        ...
    }

    or

    typeof Number.EPSILON == "undefined"

13 ***

```
    0.1 + 0.2 === 0.3; // false
```

12 ***

这些方法不仅适用于`数字`变量，也适用于`数字`常量。不过在使用`.`操作符时需要特别注意，因为它是一个合法的数字字符，它会被尽可能优先识别为`数字`常量的一部分，然后才是对象属性访问操作符。

```
    // invalid syntax:
    42.toFixed( 3 );    // SyntaxError

    // these are all valid:
    (42).toFixed( 3 );  // "42.000"
    0.42.toFixed( 3 );  // "0.420"
    42..toFixed( 3 );   // "42.000"
```

11 ***

此外，很多`数组`函数在处理`字符串`时非常有用，`字符串`中没有这些函数，但我们可以“借用”`数组`的这些非变更方法（nonmutation）来处理`字符串`：

```
    a.join;         // undefined
    a.map;          // undefined

    var c = Array.prototype.join.call( a, "-" );
    var d = Array.prototype.map.call( a, function(v){
        return v.toUpperCase() + ".";
    } ).join( "" );
    
    c;              // "f-o-o"
    d;              // "F.O.O."
```

我们再来看看另外一个例子：`字符串`反转（经常在JavaScript面试中遇到的问题！）。`数组`有一个可变更成员函数`reverse()`，而`字符串`没有：

```
    a.reverse;      // undefined

    b.reverse();    // ["!","o","O","f"]
    b;              // ["f","O","o","!"]
```

遗憾的是，此类“借用”对于`数组`的可变更成员函数不适用，因为`字符串`是不可变的，其内容无法更改：

```
    Array.prototype.reverse.call( a );
    // 返回值仍然是"foo"的一个字符串封装对象（见第三章）:(
```

一个变通（破解）的办法是将`字符串`转换为`数组`，执行需要的操作，然后再转换回`字符串`：

```
    var c = a
        // split `a` into an array of characters
        .split( "" )
        // reverse the array of characters
        .reverse()
        // join the array of characters back to a string
        .join( "" );
    
    c; // "oof"
```

10 **

`字符串`不可变的意思是`字符串`的成员函数都不会改动`字符串`的原始值，而是创建并返回一个新的`字符串`。而`数组`的成员函数都是在其原始值上进行操作。

9 ****

然而有一个容易出错的地方需要我们注意，如果作为键值的`字符串`可以被强制类型转换为10进制`数字`，则系统则视其为`数字`索引而非`字符串`键值！

```
    var a = [ ];
    a["13"] = 42;
    a.length; // 14
```

8 **

`数组`使用数字索引，因为其也是`对象`，因此可以包含字符串键值和属性（并不计算在数组长度`length`内）：

7

```
    // 这样做会产生错误
    if (DEBUG) {
        console.log( "Debugging is starting" );
    }
    // 这样做则是安全的，不会产生错误
    if (typeof DEBUG !== "undefined") {
        console.log( "Debugging is starting" );
    }

```

6

```
    var a;

    typeof a; // "undefined"

    typeof b; // "undefined"
```

5

在JavaScript中变量是没有类型的，只有值才有。变量随时可以持有任意类型的值。

```
    var a = 42;
    typeof a; // "number"

    a = true;
    typeof a; // "boolean"
```

4

那么数组的情况又如何呢？JavaScript本身支持数组，那它是不是也是一个特殊类型？

```
    typeof [1,2,3] === "object"; // true
```

非也，数组也是`object`类型。确切地说是`object`的一个子类型（见`第三章`），其中一个特征是数组中的元素按照数字顺序进行索引（而非普通对象那样是字符串键值），并且`length`属性会根据元素数量自动更新。

3

那么`typeof`的第七个返回值字符串值是什么呢？

```
    typeof function a(){ /* .. */ } === "function"; // true
```

上面`typeof`的返回值容易让我们得出这样一个结论，就是`函数`（function）也是JavaScript的一个内置类型。然而如果你查阅规范就会知道，它实际上是`object`的一个“子类型”（subtype）。具体来说，函数被称为“可调用对象”（callable object），即该对象内部有一个｀\[\[Call\]\]｀属性使得它能够被执行。

2

typeof null === "object"; // true

你需要使用复合条件来检测`null`值的类型，：

```
    var a = null;

    (!a && typeof a === "object"); // true
```

1

JavaScript有七种内置类型：

- null
- undefined
- boolean
- number
- string
- object
- symbol（ES6中新加入）