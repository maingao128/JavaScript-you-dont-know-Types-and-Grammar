79. *****

`try`中如果包含`return`语句会出现什么情况呢？很显然`return`会产生一个返回值，那么调用该函数并获得这个返回值的代码是在`finally`之前执行还是之后呢？

```
    function foo() {
            try {
                return 42;
            } 
            finally {
                console.log( "Hello" );
            }

            console.log( "never runs" );
    }

    console.log( foo() );
    // Hello
    // 42
```
......

`try`中的`throw`也是如此：

```
    function foo() {
        try {
            throw 42; 
        }
        finally {
            console.log( "Hello" );
        }

      console.log( "never runs" );
    }

    console.log( foo() );
    // Hello
    // Uncaught Exception: 42
```

如果`finally`中抛出异常（无论是人为还是无意），函数就会在此处终结。如果`try`中已经有`return`设置了一个返回值，则该值会被丢弃：

```
    function foo() {
        try {
            return 42;
        } 
        finally {
            throw "Oops!";
        }

        console.log( "never runs" );
    }
    
    console.log( foo() );
    // Uncaught Exception: Oops!
```

`continue`和`break`也是如此：

......

`finally`中的`return`会覆盖`try`和`catch`中的`return`的返回值：

78. ****

组合

```
    var a = true, b = false, c = true, d = true, e = false;

    a ? b : (c ? d : e); // false, 执行 `a` 和 `b`
    (a ? b : c) ? d : e; // false, 执行 `a`, `b` 和 `e`
```

77. ****

关联（associativity）针对的是多个相同优先级的运算符。

- 执行顺序
- 关联
- 绑定
- 组合

76. *****

遗憾的是JS规范对运算符优先级并没有一个集中的介绍。我们需要从语法规则中间逐一了解。所以我们在这里列出一些常见和有用的优先级规则。完整列表请参见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN</a>上的“优先级列表”。

75. ****

在使用`,`来连接一系列语句的时候，请务必记住它的优先级最低，其他操作数的优先级都比它高。

74 ****

```
    function foo() {
        a = a + 1;
    }
    
    var a = 1;
    foo();      // 结果值: `undefined`, 副作用: `a`的值被改变
```

73 ****

很多人不知道语句都有一个结果值（statement completion value，`undefined`也是一个结果值）。

获得结果值最直接的方法是在浏览器开发控制台中输入语句，默认情况下控制台会显示执行的最后一条语句的结果值。

72 ****

首先`a`和`each`是通过`===`（见`第四章`）来进行相等比较。多数情况下`switch`中的`case`都是使用值，所以这样并没有问题。

然而我们有时可能需要通过强制类型转换来进行相等比较（即`==`，见`第四章`），这时就要在`switch`中做一些特殊处理：

```
    var a = "42";

    switch (true) {
        case a == 10:
            console.log( "10 or '10'" );
            break;
        case a == 42;
            console.log( "42 or '42`" );
            break;
        default:
            // never gets here
    }
    // 42 or '42'
```

除了简单值，`case`中还可以出现各种表达式，它会将表达式的结果值和`true`进行比较。因为`a == 42`的结果为`true`，所以条件成立。

尽管可以使用`==`，但`switch`中`true`和`true`之间仍然是严格相等比较。如果`case`表达式的结果为真值，但不是严格意义上的`true`（见`第四章`），则条件不成立。所以如果在这里使用`||`和`&&`“逻辑运算符”就很容易掉坑里：

```
    var a = "hello world";
    var b = 10;

    switch (true) {
        case (a || b == 10):
            // never gets here
            break;
        default:
            console.log( "Oops" );
    }
    // Oops
```

......

```
    var a = 10;

    switch (a) {
            case 1:
            case 2:
                    // never gets here
            default:
                    console.log( "default" );
            case 3:
                    console.log( "3" );
                    break;
            case 4:
                    console.log( "4" );
    }
    // default
    // 3
```

上例中的代码是这样执行的，首先遍历并找到所有匹配的`case`，如果没有匹配则执行`default`中的代码。因为其中没有`break`，所以继续执行已经遍历过的`case 3`代码块，直到`break`为止。

71 *****

```
    function foo() {
            try {
                return 42;
            } 
            finally {
                console.log( "Hello" );
            }

            console.log( "never runs" );
    }

    console.log( foo() );
    // Hello
    // 42
```

......

```
    function foo() {
        try {
            throw 42; 
        }
        finally {
            console.log( "Hello" );
        }

      console.log( "never runs" );
    }

    console.log( foo() );
    // Hello
    // Uncaught Exception: 42
```

......

```
    function foo() {
        try {
            return 42;
        } 
        finally {
            throw "Oops!";
        }

        console.log( "never runs" );
    }
    
    console.log( foo() );
    // Uncaught Exception: Oops!
```

......

`continue`和`break`也是如此：

```
    for (var i=0; i<10; i++) {
        try {
            continue; 
        }
        finally {
            console.log( i );
        }
    }
    // 0 1 2 3 4 5 6 7 8 9
```

......

`finally`中的`return`将会覆盖`try`和`catch`中的`return`的返回值：

```
    function foo() {
        try {
            return 42;
        } 
        finally {
            // no `return ..` here, so no override
        } 
    }
    
    function bar() {
        try {
            return 42;
        }
        finally {
            // override previous `return 42`
            return; 
        }
    }

    function baz() {
        try {
            return 42;
        } 
        finally {
            // override previous `return 42`
            return "Hello";
        }
    }

    foo();  // 42
    bar();  // undefined
    baz();  // Hello
```

......

通常来说，在函数中省略`return`与`return;`和`return undefined;`结果是一样的，但是在`finally`中省略`return`则会返回前面的`return`值。

70 ***

如果向函数传递参数，`arguments`数组中的对应单元会和命名参数建立关联（linkage）以获得相同的值。如果不传递参数就不会建立关联。

但是在`严格`模式中并没有建立关联这一说：

```
    function foo(a) {
        "use strict";
        a = 42;
        console.log( arguments[0] );
    }

    foo( 2 );   // 2 (not linked)
    foo();      // undefined (not linked)
```

所以依赖这种关联并不好，实际上它来自于JavaScript语言引擎的底层实现，语言本身并没有这个特性。

虽然并非一无是处，但`arguments`数组已经被废止（特别是ES6引入剩余参数`...`（rest parameters）之后，参见本系列的*《ES6 & Beyond》*）。

在ES6之前，获得传递给函数的所有参数的唯一途径就是`arguments`数组，它非常有用。我们还可以将命名参数和`arguments`数组混用，只要遵守一个原则就不会有问题，即*永远不要同时访问命名参数和其对应的`arguments`数组单元*。这样就能确保不会出现关联泄露（leaky linkage）：

```
   function foo(a) {
        console.log( a + arguments[1] ); // safe!
    }

    foo( 10, 32 );  // 42
```

69 ****

在ES6中，如果参数被省略或者值为`undefined`，则使用该参数的缺省值：
```
    function foo( a = 42, b = a + 1 ) {
        console.log( a, b );
    }

    foo();              // 42 43
    foo( undefined );   // 42 43
    foo( 5 );           // 5 6
    foo( void 0, 7 );   // 42 7
    foo( null );        // null 1
```
......

这里省略掉参数和传递`undefined`值的效果是一样的。然而它们之间的区别还是可以通过某些形式体现出来：

```
    function foo( a = 42, b = a + 1 ) {
        console.log(
            arguments.length, a, b,
            arguments[0], arguments[1]
        );
    ￼}

    foo();                  // 0 42 43 undefined undefined
    foo( 10 );              // 1 10 11 10 undefined
    foo( 10, undefined );   // 2 10 11 10 undefined
    foo( 10, null );        // 2 10 null 10 null
```

68 ****

有意思的是对未声明（undeclared）变量使用`typeof`不会产生错误（参见`第一章`），但在TDZ中却会报错：

```
{
    typeof a;   // undefined
    typeof b;   // ReferenceError! (TDZ)
    let b;
}
```

......

```
    var b = 3;

    function foo( a = 42, b = a + b + 5 ) {
        // ..
    }
```

`b = a + b + 5`试图在参数`b`的TDZ中访问`b`（并非函数外的那个`b`），因此会出错。然而访问`a`却没有问题，因为其刚好越过了参数`a`的TDZ。

67 ***

ES5规范的`严格（strict）`模式定义了更多的前期错误。比如在`严格`模式中，函数的参数不能重名：

```
    function foo(a,b,a) { }                 // just fine
    function bar(a,b,a) { "use strict"; }   // Error!
```

66 ****

请注意ASI只在换行符（即line break）处起作用，不会在代码行的中间插入分号。

......

语法规定`do..while`后必须带`;`，`while`和`for`则不需要。大部分人不记得这一点，此时ASI就会自动加上分号。

65 **

我个人的观点是，依赖运算符优先级／关联性规则和使用`( )`自行控制运算符的结合这两者都应该兼顾，对于`第四章`中的*隐式*强制类型转换我也持同样的观点，我们应该安全合理地运用它们，而非无节制地滥用。

64 ***

```
    true ? false : true ? true : true;      // false

    true ? false : (true ? true : true);    // false
    (true ? false : true) ? true : true;    // true
```

63.2 *****

有人可能会问，如果返回的不是`true`和`false`，为什么`a && (b || c)`这样的表达式在`if`和`for`中没有出现问题。

这些代码（或许）真的没有问题。问题在于他们不知道那些条件判断表达式最后还会执行`boolean`*隐式*强制类型转换。

例如：

```
    var a = 42;
    var b = null;
    var c = "foo";
    
    if (a && (b || c)) {
        console.log( "yep" );
    }
```

63 *****

有一种方法对于开发人员不太常见，但JS代码压缩工具经常使用。即如果第一个操作数为真值，则`&&`运算符“选择”第二个操作数作为返回值，这也叫做“守护运算符（guard operator）”（见`第五章``第140页的“短路（Short Circuited）”`）－－前面的表达式为后面的表达式“把关”：

```
    function foo() {
        console.log( a );
    }
    
    var a = 42;
    
    a && foo(); // 42
```

`foo()`只有在条件判断`a`通过时才会被调用。如果条件判断未通过，`a && foo()`就会悄然终止（也叫做“短路，short circuiting”），`foo()`不会被调用。

这样的用法对于开发人员不太常见，通常是用`if (a) { foo(); }`。但是JS代码压缩工具用的是`a && foo()`，因为更简洁。以后看到这样的代码我们就能知其所以然了。

......

短路很好用，也很常用，如：

```
    function doSomething(opts) {
        if (opts && opts.cool) {
            // .. 
        }
    }
```

`opts && opts.cool`中的`opts`条件判断如同一层安全保护措施，因为如果`opts`未赋值（或者不是一个`object`），表达式`opts.cool`会出错。此时利用`短路`特性，`opts`条件判断未通过，所以`opts.cool`不会执行，也就不会产生错误！

`||`同样如此：

```
    function doSomething(opts) {
        if (opts.cache || primeCache()) {
            // .. 
        }
    }
```

这里我们先判断`opts.cache`，如果它存在则无需调用`primeCache()`，这样可以避免执行不必要的代码。

62 *****

```
    false && true || true;      // true
    (false && true) || true;    // true
```

......

```
    true || false && false;     // true

    (true || false) && false;   // false--晕
    true || (false && false);   // true--欧耶!
```

......

`&&`先于`||`执行

......

因为`&&`的优先级高于`||`，`||`的优先级又高于`? :`。

61 ****

```
    var a = 42, b;
    b = ( a++, a );
    
    a;  // 43
    b;  // 43
```

如果去掉`( )`会出现什么情况呢？

```
    var a = 42, b;
    b = a++, a;

    a;  // 43
    b;  // 42
```

60 *****

人们常误以为JavaScript中有`else if`，因为可以这样写代码：

```
    if (a) { 
        // ..
    }
    else if (b) {
        // .. 
    }
    else { 
        // ..
    }
```

...

我们经常用到的`else if`实际上是这样的：
```
    if (a) { 
        // ..
    } 
    else {
        if (b) { 
            // ..
        } 
        else {
            // .. 
        }
    }
```

59 ****

ES6中的解构赋值

......

```
    function foo({ a, b, c }) {
        // no need for:
        // var a = obj.a, b = obj.b, c = obj.c
        console.log( a, b, c );
    }

    foo( {
        c: [1,2,3],
        a: 42,
        b: "foo"
    } );    // 42 "foo" [1, 2, 3]
```

58 ****

下面是另一个常见的坑（涉及强制类型转换，见`第四章`）：

```
    [] + {}; // "[object Object]"
    {} + []; // 0
```

看似`+`运算符根据第一个操作数（`[]`或`{}`）的不同产生不同的结果。实际上不是！

第一行中的`{}`被当作一个值（空`object`）来处理。在`第四章`我们讲过，`[]`会被强制类型转换为`""`，`{}`会被强制类型转换为`"[object Object]"`。

但在第二行中，`{}`被当作一个独立的空代码块（不做任何事情）。代码块结尾不需要分号，所以这里语法没有问题。最后`+ []`将`[]`*显式强制类型转换*为`number`值`0`。

57 ***

`{"a":42}`作为JSON值没有任何问题，但是在作为代码执行时会产生JS错误，因为它被当作一个带有非法标签的语句块来执行。`foo({"a":42})`就没有问题，因为`{"a":42}`在这里是一个传递给`foo(..)`的`object`常量。因此，确切地说，*JSON-P能将JSON转换为合法的JS语法*。

56 *****

#####标签

如果将上例中的`var a =`去掉会发生什么情况呢？

```
    // assume there's a `bar()` function defined
    {
        foo: bar()
    }
```

......

然而JS支持某种有限度的特别的`goto`：标签跳转（labeled jumps）。`continue`和`break`语句都可以带一个标签，这样程序执行流程就可以象`goto`那样进行跳转了。

......

<b>contine foo</b>并不是指“跳转到标签<i>foo</i>所在的位置继续执行”，而是“执行标签为<i>foo</i>循环的下一轮循环”。所以这里的<b>foo</b>并非<b>goto</b>。

......

<b>break foo</b>的意思不是“跳转到标签<i>foo</i>所在位置继续执行”，而是“跳出标签<i>foo</i>所在的循环／代码块，继续执行其后的代码”。所以它并非传统意义上的<b>goto</b>。

......

标签也能用于非循环代码块，但只有`break`可以这样。我们可以对带标签的代码块使用`break ___`，但是不能对带标签的非循环代码块使用`continue ___`，也不能对不带标签的代码块使用`break`：

55 ****

赋值表达式（或者语句）的结果值在串联多个赋值语句（链式赋值，chained assignments）的时候很有用，比如：

```
    var a, b, c;

    a = b = c = 42;
```

这里`c = 42`的结果值为`42`（产生的边缘效应是`42`被赋值给`c`），然后`b = 42`的结果值为`42`（产生的边缘效应是`42`被赋值给`b`），最后是`a = 42`（产生的边缘效应是`42`被赋值给`a`）。

54 ***

```
    var a;
    
    a = 42;     // 42
    a;          // 42
```

`a = 42`中的`=`看似没有边缘效应。但是如果我们检查一下语句`a = 42`的结果值就会发现，它返回的是`42`，所以`=`的边缘效应就是给`a`赋值。


53 ****

```
    var a = 42, b;
    b = ( a++, a );
    
    a;  // 43
    b;  // 43
```

52 ***

考考你，<b>++a++</b>这样的语法是否合法？你试一试就知道，它会产生<b>ReferenceError</b>错误。因为运算符需要将它产生的边缘效应赋值给一个变量。以<b>++a++</b>为例，首先执行<b>a++</b>（根据运算符优先级，见下），返回a递增之前的值<b>42</b>。然后执行<b>++42</b>，这时会产生<b>ReferenceError</b>错误，因为<b>++</b>无法直接在<b>42</b>这样的值上产生边缘效应。

51 ****

```
    var a = 42;
    var b = a++;

    a;  // 43
    b;  // 42
```

......

当`++`出现在操作数前面时，如：`++a`，它的边缘效应（递增`a`）发生在表达式返回结果值之前，而`a++`的边缘效应发生在之后。

50.1 ****

其中第一段（11.9.3.1）中规定如果两个值类型相同，就只比较它们的值是否相等。例如，`42`等于`42`，`"abc"`等于`"abc"`。

有几个非常规的情况需要注意：

- `NaN`不等于`NaN`（见`第二章`）。
- `+0`等于`-0`（见`第二章`）。 

11.9.3.1最后一段中定义了`object`（包括`function`和`array`）的宽松相等`==`。两个对象指向*同一个值*时视为相等。这里不涉及强制类型转换。

50 ****

相等比较中有严格相等，而关系比较中没有“严格关系比较（strict relational comparison）”。也就是说如果要避免关系比较中的*隐式*强制类型转换，比如`a < b`，我们只能确保`a`和`b`的类型一致，除此之外别无他法。

和`==`及`===`的完整性检查同样的道理。我们应该在必要和安全的情况下使用强制类型转换，如：`42 < "43"`。另一方面，如果要确保关系比较的安全，就应该在比较之前使用*显式强制类型转换*：

```
    var a = [ 42 ];
    var b = "043";

    a < b;                      // false -- string comparison!
    Number( a ) < Number( b );  // true -- number comparison!
```

49.2 *****

因为根据规范`a <= b`被处理为`b < a`，然后将结果反转。因为`b < a`的结果是`false`，所以`a <= b`的结果是`true`。

这可能与我们设想的大相径庭，即`<=`应该是“小于或者等于”。实际上JS中`<=`是指“不大于”（即`!(a > b)`，处理为`!(b < a)`）。同理`a >= b`处理为`b <= a`。

相等比较有严格相等，而关系比较没有“严格关系比较（strict relational comparison）”。也就是说如果要避免`a < b`中发生*隐式*强制类型转换，我们只能确保`a`和`b`有相同的类型，除此之外别无他法。

49.1 *****

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">该算法仅针对<b>a &lt; b</b>，<b>a > b</b>会被处理为<b>b &lt; a</b>。</td>
    </tr>
</table>

比较双方首先调用`ToPrimitive`，如果结果出现非`string`则根据`ToNumber`规则将双方强制类型转换为`number`来进行比较。

49 ****

```
    var a = { b: 42 };
    var b = { b: 43 };

    a < b;  // false
    a == b; // false
    a > b;  // false
    
    a <= b; // true
    a >= b; // true
```

......

但如果`a < b`和`a == b`的结果都是`false`，为什么`a <= b`和`a >= b`的结果是`true`呢？

因为根据规范，`a <= b`实际上是先执行`b < a`，然后将结果反转。因为`b < a`的结果是`false`，所以`a <= b`的结果为`true`。

48 *****

关键是我们要对`==`两边的值认真推敲。以下两条原则可以有效地避免错误：

- 如果两边的值中有`true`或者`false`，不要使用`==`。
- 如果两边的值中有`[]`，`""`或者`0`时，尽量不要使用`==`。

这时候最好用`===`，这样可以避免意料之外的强制类型转换。这两条原则可以让我们避开几乎所有强制类型转换的坑。

47 ****

这还不算完，还有更极端的例子：

```
    [] == ![]   // true
```

事情变得越来越疯狂了。这看起来象是真值和假值之间的相等比较，结果不应该是`true`，因为一个值不可能同时既是真值也是假值！

事实并非如此。让我们来看看`!`运算符都做了些什么？根据`ToBoolean`规则，它会进行`boolean`显式强制类型转换（同时反转奇偶校验位）。所以`[] == ![]`先变成了：`[] == false`。从前面的例子中我们知道`false == []`，所以最后的结果一点也不出人意外。

那么其他情况呢？

```
    2 == [2];       // true
    "" == [null];   // true
```

我们在介绍`ToNumber`时说过，右边的值`[2]`和`[null]`会执行`ToPrimitive`强制类型转换，以便能够和左边的基本类型值进行比较（`2`和`""`）。因为`数组`的`valueOf()`返回`数组`本身，所以强制类型转换将对`数组`进行字符串化。

第一行的`[2]`会被转换为`"2"`，然后通过`ToNumber`转换为`2`。第二行的`[null]`会被直接转换为`""`。

因此`2 == 2`和`"" == ""`的结果就完全可以理解了。

......

还有经常被提及的坑是：

```
    0 == "\n";  // true
```

46 ****

`==`中的*隐式*强制类型转换最为人诟病的地方是假值的相等比较。

......

```
    "0" == null;        // false
    "0" == undefined;   // false
    "0" == false;       // true -- 晕！
    "0" == NaN;         // false
    "0" == 0;           // true
    "0" == "";          // false

    false == null;      // false
    false == undefined; // false
    false == NaN;       // false
    false == 0;         // true -- 晕！
    false == "";        // true -- 晕！
    false == [];        // true -- 晕！
    false == {};        // false

    "" == null;         // false
    "" == undefined;    // false
    "" == NaN;          // false
    "" == 0;            // true -- 晕！
    "" == [];           // true -- 晕！
    "" == {};           // false

    0 == null;          // false
    0 == undefined;     // false
    0 == NaN;           // false
    0 == [];            // true -- 晕！
    0 == {};            // false
```

45 ****

```
    Number.prototype.valueOf = function() {
        return 3;
    };

    new Number( 2 ) == 3;   // true
```

44 ******

我个人建议无论什么情况，永远不要使用`== true`和`== false`。

但是请注意，这里讨论的只是`==`，`=== true`和`=== false`不允许强制类型转换，所以并不涉及`ToNumber`转换。

......

== 和 ===

```
1. 如果Type(x)是数字，Type(y)是字符串，则返回x == ToNumber(y)的结果。
2. 如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x) == y的结果。
```

```
1. 如果Type(x)是`boolean`值，则返回ToNumber(x) == y的结果。
2. 如果Type(y)是`boolean`值，则返回x == ToNumber(y)的结果。
```

"42" == true // false
"42" == false // false

我们需要理解`==`算法如何是怎样处理不同的类型组合的。它首先会将`==`两边的`boolean`值强制类型转换为`number`。

永远不要使用`== true`和`== false`。

在`==`中`null`和`undefined`相等（同时它们也和自身相等），除它们之外其他值都不存在这种情况。

null == false // false
+null == false // true

Number(null) // 0
Number(false) // +0

```
    var a = "abc";
    var b = Object( a );    // same as `new String( a )`

    a === b;                // false
    a == b;                 // true
```

43 *****

“在相等比较中，`==`允许强制类型转换，而`===`不允许”。

42 ****

```
    var a = 42;
    var b = null;
    var c = "foo";
    
    if (a && (b || c)) {
        console.log( "yep" );
    }
```

以上代码的执行结果和我们预期的一样，除了一处细节，`a && (b || c)`表达式的返回值实际上是`"foo"`，而非`true`。随后由`if`表达式将`foo`强制类型转换为`boolean`，最后结果为`true`。

41 ***

```
    function foo() {
        console.log( a );
    }
    
    var a = 42;
    
    a && foo(); // 42
```

只有在`a`条件测试通过的时候`foo()`才会被调用。如果条件测试不通过，`a && foo()`语句就会默默地终止（也称为“短路，short circuiting”），`foo()`不会被调用。

对于程序员来说这样的用法不太常见，通常我们会使用`if (a) { foo(); }`。但是JS代码压缩工具会使用`a && foo()`，因为它更精简。以后我们如果再看到这样的代码就能知其所以然了。

40.1 ****

涉及`boolean`*隐式*强制类型转换的情况有：

1. `if (..)`语句中的条件判断表达式
2. `for ( .. ; .. ; .. )`语句中的条件判断表达式（第二个）
3. `while (..)`和`do..while(..)`循环中的条件判断表达式
4. `? :`中的条件判断表达式
5. 逻辑运算符`||`（逻辑或）和`&&`（逻辑与）左边的操作数（作为条件判断表达式）。

40 ****

但是还要注意一点！

```
    foo( "That's it!", "" ); // "That's it! world" <-- Oops!
```

你能看到问题所在吗？第二个参数""是一个假值（见`第67页“ToBoolean”`），因此`b = b || "world"`条件判断结果为假，返回缺省值`"world"`，虽然你可能本意是想传递空字符串`""`给`b`。

`||`这样的用法非常常见，也很有用，但是你需要确保在使用中避免传递`假值`。否则你就需要在条件判断中更加清晰地说明条件，也可以换而实用`? :`三元表达式。

39.5 *****

下面是`||`一个十分常见的用法，也许你已经用过但并未完全理解：

```
    function foo(a,b) {
        a = a || "hello";
        b = b || "world";
     
        console.log( a + " " + b );
    }

    foo();                  // "hello world"
    foo( "yeah", "yeah!" ); // "yeah yeah!"
```

`a = a || "hello"`（又叫做C#“空合并运算符，null coallescing operator”的JavaScript版本）检查变量`a`，如果它未赋值（或者为假值），就赋予它一个缺省值（`"hello"`）。

但这里需要注意！

```
    foo( "That's it!", "" ); // "That's it! world" <-- Oops!
```

第二个参数`""`是一个`假值`（`falsy value`，见`第67页的“ToBoolean”`），因此`b = b || "world"`条件不成立，返回缺省值`"world"`。

这种用法极为常见，但不可以使用`假值`，否则就需要在条件判断中写清楚，或者转而使用`? :`三元表达式。

39.4 ****

比较`a + ""`（隐式）和之前介绍过的`String(a)`（显式），两者之间有一个细微的差别需要注意。根据`ToPrimitive`抽象操作的工作原理，`a + ""`会对`a`调用`valueOf()`方法，然后返回值通过`ToString`抽象操作转换为`string`。而`String(a)`则是直接调用`ToString()`。

它们最终返回的都是`string`，但是如果`a`不是`number`基本类型而是`object`，就有可能得到其它结果！

例如：

```
    var a = {
        valueOf: function() { return 42; },
        toString: function() { return 4; }
    };
    
    a + ""; // "42"
    
    String( a );    // "4"
```

如果代码中不存在匪夷所思的数据结构和操作，一般是不太可能碰到这个问题的，但是如果我们要为某些对象自定义`valueOf()`和`toString()`方法，就需要特别小心，因为这会影响到强制类型转换的结果。
*****

39.3 ****

```
    var a = "42";
    var b = "0";

    var c = 42;
    var d = 0;
    
    a + b; // "420"
    c + d; // 42
```

为什么会得到`"420"`和`42`两个不同的结果？常见的误解是，因为某个或者两个操作数都是`string`，所以`+`进行的是`string`拼接。这样理解只对了一半，实际情况要复杂得多。

......

简单说就是如果`+`的其中一个操作数是`string`（或者通过以上步骤可以产生`string`值），则执行`string`拼接。否则执行`number`加法。

39.2 ***

对`~~`我们要特别小心。首先它仅适用于32位数字，更重要的是它对负数的处理与`Math.floor(..)`不同。

39.1 ****

JavaScript中`string`的`indexOf(..)`方法也遵循此惯例，其在字符串中搜索指定的子字符串，如果找到则返回子字符串的位置（从0开始），否则返回`-1`。

`indexOf(..)`不仅用于获取子字符串的位置，还被用来检查字符串中是否包含指定的子字符串，相当于一个`boolean`判断。例如：

```
    var a = "Hello World";
    
    if (a.indexOf( "lo" ) >= 0) {   // true
        // found it!
    }
    if (a.indexOf( "lo" ) != -1) {  // true
        // found it }
    if (a.indexOf( "ol" ) < 0) {    // true
        // not found!
    }
    if (a.indexOf( "ol" ) == -1) {  // true
        // not found!
    }
```

`>= 0`和`== -1`这样的写法不是很好，属于“抽象渗漏（leaky abstraction）”，意思是在代码中暴露了底层的实现细节，这里是指用`-1`作为失败返回值，这些细节应该被隐藏。

现在我们终于明白`~`的用处了！`~`和`indexOf()`一起可以将结果“强制类型转换”（实际上只是转换）为真／假值：

```
    var a = "Hello World";
    
    ~a.indexOf( "lo" );         // -4 <-- truthy!
    
    if (~a.indexOf( "lo" )) {   // true
        // found it!
    }
    
    ~a.indexOf( "ol" );         // 0  <-- falsy!
    !~a.indexOf( "ol" );        // true
    
    if (!~a.indexOf( "ol" )) {  // true
        // not found!
    }
```

如果`indexOf(..)`返回值为`-1`，`~`将其转换为`假值0`，其他情况则转换为`真值`。

39 ****

`||`和`&&`操作符首先会对*第一个操作数*（`a`和`c`）进行`boolean`条件判断。如果它不是`boolean`值（如上例）则执行`ToBoolean`强制类型转换，以便执行条件判断。

对于`||`操作符来说，如果条件判断结果为`true`，`||`表达式返回第一个操作数（`a`和`c`）的值。如果条件判断结果为`false`则返回第二个操作数（`b`）的值。

相反，对于`&&`操作数，如果条件判断结果为`true`，`&&`表达式返回第二个操作数（`b`）的值。如果条件判断结果为`false`则返回第一个操作数（`a`和`c`）的值。

从另一个角度来理解：

```
    a || b;
    // roughly equivalent to:
    a ? a : b;

    a && b;
    // roughly equivalent to:
    a ? b : a;
```

之所以说大致相当（roughly equivalent），是因为返回结果相同，但是它们之间存在一个细微的差别。在<b>a ? a : b</b>中，如果<b>a</b>是更为复杂一些的表达式（比如：一个有副作用的函数调用），则<b>a</b>表达式有可能被执行两次（如果第一次结果为真）。相反，对于<b>a || b</b>，表达式只会执行一次，其结果值会被用于条件判断以及返回值（如果适用的话）。<b>a &amp;&amp; b</b>和<b>a ? b : a</b>也一样。

......

```
    var a = 42;
    var b = "abc";
    var c = null;

    a || b;     // 42 
    a && b;     // "abc"
    
    c || b;     // "abc" 
    c && b;     // null
```

38 *****

*&&和||操作符的返回值并不一定是`boolean`类型。它们的返回值是两个操作数其中的一个的值。*

37.3 ****

对`string`中的`number`进行解析时*允许*`string`中含有非数字字符，按从左到右的顺序，如果遇到非数字字符则解析停止。然而强制类型转换*不允许*非数字字符，否则会失败并返回`NaN`。

37.2 ****

将`Date`对象转换为时间戳并非只有强制类型转换这一种方法，其它更显式的方法或许还更好一些：

```
    var timestamp = new Date().getTime();
    // var timestamp = (new Date()).getTime();
    // var timestamp = (new Date).getTime();
```

从ES5开始*最好*使用静态方法`Date.now()`：

```
    var timestamp = Date.now();
```

为老版本浏览器polyfill `Date.now()`功能也很简单：

```
    if (!Date.now) {
        Date.now = function() {
            return +new Date();
        };
    }
```

建议不要对`日期`类型使用强制类型转换，而是使用`Date.now()`来获得当前时间戳，使用`new Date(..).getTime()`来获得指定时间的时间戳。

37.1 ***

除了`String(..)`和`Number(..)`外，还有其他方法可以实现`string`和`number`之间的“显式”类型转换：

```
    var a = 42;
    var b = a.toString();
    
    var c = "3.14";
    var d = +c;

    b; // "42"
    d; // 3.14
```

调用`a.toString()`的意图非常明显（“toString”意指“to a string”），不过这里涉及一些隐蔽的隐式转换。因为`toString()`对`42`这样的基本类型值不适用，所以JS引擎会自动为`42`创建一个封装对象（见`第三章`），然后在该对象上调用`toString()`。这里的显式转换中含有隐式转换。

上例中`+c`是`+`运算符的*一元（unary）*形式（即只有一个操作数）。`+`运算符显式地将`c`转换为`number`，而不是数学加法运算（也不是字符串拼接操作－－见下）。

37 ***

下面这些值我们称为假值（“falsy” values）：

- `undefined`
- `null`
- `false`
- `+0`，`-0`和`NaN`
- `""`

它们在`boolean`强制类型转换中为`false`。

按理说该列表以外的值应该会被转换为`true`，我们称为真值（“truthy” values）。但JS规范对此并没有明确定义，只给出了一些例子，比如明确规定所有对象都是真值，通常我们可以认为*所有不在假值列表中的值都是真值*。

36 ****

首先也是最重要的一点，是JS有两个关键词`true`和`false`，分别代表`boolean`类型中的真和假。我们常常误以为数值`1`和`0`分别等同于`true`和`false`。在有些语言中可能确实如此，但在JS中`boolean`和`number`不同。虽然我们可以将`1`强制类型转换为`true`（反之亦然），将`0`强制类型转换为`false`（反之亦然），但它们不是一回事。

35.1 ****

对象（和数组）首先被转换为相应的基本类型值，如果返回的是非`number`的基本类型值，就再遵循上述规则将其强制转换为`number`。

为了将值转换为相应的基本类型值，抽象操作`ToPrimitive`（见ES5规范第9.1节）会首先（通过内部操作`DefaultValue`，见ES5规范第8.12.8节）检查该值是否有`valueOf()`方法。如果有且返回的是基本类型值，就使用该返回值进行强制类型转换。如果没有就使用`toString()`的返回值（如果有的话）来进行强制类型转换。

如果两者都不返回基本类型值则会产生`TypeError`错误。

从ES5开始，使用`Object.create(null)`创建的对象`[[Prototype]]`属性为`null`，并且没有`valueOf()`和`toString()`方法，因此无法进行强制类型转换。详情请参考本系列的*《this & Object Prototypes》*一书中`[[Prototype]]`相关部分。

35 ***

####ToNumber

在某些情况下非`数字`值需要被当作`数字`来使用，比如数学运算，ES5规范中第9.3节定义了抽象操作`ToNumber`。

例如，`true`转换为`1`，`false`转换为`0`。`undefined`转换为`NaN`，而`null`则为`0`。

34.1 ****

'use strict';

class Cat {
    constructor() {
        this.name = "cat's name";
        this.gendre = "male";
        this['etc'] = 'etc';
    }

};

var cat2 = {
    name: "cat 2's name",
    gendre: "female",
    "etc": 'etc'
}

console.log(JSON.stringify(new Cat()));
console.log(JSON.stringify(cat2));

output:

{"name":"cat's name","gendre":"male","etc":"etc"}
{"name":"cat 2's name","gendre":"female","etc":"etc"}

34 ***

我们可以向`JSON.stringify(..)`传递第二个参数，即可选参数（optional argument）*replacer*。它可以是`数组`或者`函数`，通过某种过滤机制来指定哪些属性应该被处理和排除，然后对结果进行序列化，以此来实现对象递归序列化的定制，类似`toJSON()`。

33.1 *****

`JSON.stringify(..)`遇到`undefined`，`function`，和`symbol`会自动忽略，如果在`array`中则返回`null`（从而保证单元位置索引不变），如果是对象属性则会被忽略。

33 ****

JSON字符串化对于包含`toJSON()`方法的对象有一点特别，这时`toJSON()`方法会首先被调用，然后用它的返回值来做序列化。

如果我们要对含有非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要为该对象定义`toJSON()`方法，使之返回一个安全的JSON值。

我们通常会误以为`toJSON()`方法必须返回一个经过JSON字符串化的值。这并不准确，除非我们确实需要字符串化`字符串`（通常不会！）.`toJSON()`应该返回一个适当的值（可以是任何类型），然后再由`JSON.stringify(..)`来对其进行字符串化。

32 ****

ES5规范第9节中定义了一些“抽象操作”（“仅内部使用的操作”的规范用语）及其转换规则。我们这里着重介绍`ToString`，`ToNumber`，和`ToBoolean`，附带讲一讲`ToPrimitive`。

重要的话说两遍，`toString()`可以被显式调用，在非字符串值需要转换为字符串的时候也会被自动调用。

31 *****

将值从一种类型转换为另一种类型通常称为“类型转换”（type casting），这是指显式的情况，在隐式的情况下我们称为“强制类型转换”（coercion，具体怎么转换由值的使用规则来决定）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">JavaScript中强制类型转换总是返回标量基本类型值（见<b>第二章</b>），如：<b>字符串</b>，<b>数字</b>，和<b>布尔值</b>。强制类型转换不会返回<b>对象</b>和<b>函数</b>。在<b>第三章</b>中我们介绍过“封装”，即为标量基本类型值封装一个对应类型的对象，但这并非严格意义上的强制类型转换。</td>
    </tr>
</table>

也可以这样来区分它们：“类型转换”发生在静态类型语言的编译阶段，而“强制类型转换”是发生在动态语言的运行时。

然而在JavaScript中大部份人都将它们统称为*强制类型转换*，我个人倾向于使用“隐式类型转换”和“显式类型转换”。

30 ***

###Prototypes作为默认值

`Function.prototype`是一个空函数，`RegExp.prototype`是一个“空”正则表达式（例如：没有任何匹配），而`Array.prototype`是一个空数组，对于那些还没有被赋值的变量来说它们是不错的缺省值。

例如：

```
    function isThisCool(vals,fn,rx) {
        vals = vals || Array.prototype;
        fn = fn || Function.prototype;
        rx = rx || RegExp.prototype;
        return rx.test(
            vals.map( fn ).join( "" )
        ); 
    }

    isThisCool();       // true
    
    isThisCool(
        ["a","b","c"],
        function(v){ return v.toUpperCase(); },
        /D/
    );                  // false
```

......

这样做有一点好处就是`.prototypes`已经创建好并且*只创建一次*。相比之下如果使用`[]`，`function(){}`，和`/(?:)/`作为缺省值，每次调用`isThisCool(..)`的时候这些缺省值都会被重新创建（具体取决于JS引擎，稍后可能被垃圾回收）。这样会造成内存和CPU资源的浪费。

还有一点需要注意，就是如果缺省值随后会被更改，就不要使用`Array.prototype`作为缺省值。上例中的`vals`是作为只读变量来使用，更改`vals`实际上是更改`Array.prototype`本身，这样会导致前面提到过的一系列问题！

29.1

创建日期对象必须使用`new Date()`。`Date(..)`构造函数可以带参数，用来指定日期和时间，不带参数的话则使用当前日期和时间。

......

If you call Date() without new, you’ll get back a string representation of the date/time at that moment. The exact form of this representation is not specified in the language spec, though browsers tend to agree on something close to "Fri Jul 18 2014 00:31:02 GMT-0500 (CDT)".

......

构造函数`Error(..)`（和前面的`Array()`类似）带不带`new`关键字都一样。

29 ***

任何字符串值都可以通过prototype delegation（参考本系列的*《this & Object Prototypes》*）来访问这些方法：

```
    var a = " abc ";
    
    a.indexOf( "c" ); // 3
    a.toUpperCase();  // " ABC "
    a.trim();         // "abc"
```

28 ***

我们必须遵循一个基本原则：任何情况下都不要创建和使用空单元数组。

27.1 *****

`apply(..)`是一个工具函数，适用于所有函数对象，它以一种特殊的方式来调用传递给它的函数。

第一个参数是`this`对象（在本系列的<i>《this & Object Prototypes》</i>一书中有介绍），这里我们不用管它，将它设为`null`。第二个参数必须是一个`array`（或者类似数组的值，也叫做“类数组对象，array-like object”）。该“数组”中的值作为被调用函数的参数。

27 ****

http://www.w3schools.com/js/js_function_invocation.asp

Invoking a Function with a Function Method
In JavaScript, functions are objects. JavaScript functions have properties and methods.

call() and apply() are predefined JavaScript function methods. Both methods can be used to invoke a function, and both methods must have the owner object as first parameter.

Example
function myFunction(a, b) {
    return a * b;
}
myObject = myFunction.call(myObject, 10, 2);     // Will return 20

Example
function myFunction(a, b) {
    return a * b;
}
myArray = [10, 2];
myObject = myFunction.apply(myObject, myArray);  // Will also return 20

26 ***

http://www.w3schools.com/js/js_function_invocation.asp

The Global Object
When a function is called without an owner object, the value of this becomes the global object.

In a web browser the global object is the browser window.

This example returns the window object as the value of this:

Example
function myFunction() {
    return this;
}
myFunction();                // Will return the window object

25 ***

    var a = new Array( 3 );
    var b = [ undefined, undefined, undefined ];
    var c = [];

```
    a.join( "-" ); // "--"
    b.join( "-" ); // "--"

    a.map(function(v,i){ return i; }); // [ undefined x 3 ]
    b.map(function(v,i){ return i; }); // [ 0, 1, 2 ]
```

24 ***

`数组`构造函数只带一个`数字`参数时，该参数会被当作数组的预设大小（length），而非数组中的一个元素。

这实在不是一个明智的做法，容易让人忽视和犯错。

更要命的是，`数组`并没有预设大小这个概念。这样创建出来的只是一个空数组（empty array），只不过其`length`属性被设置成了指定的值。

23 ***

通常我们不需要直接使用封装。最好是让JS引擎自己决定什么时候使用封装。换句话说就是应该优先考虑使用`"abc"`和`42`这样的基本类型值，而非`new String("abc")`和`new Number(42)`。

```
    var a = new Boolean( false );
    
    if (!a) {
        console.log( "Oops" ); // never returns
    }
```

这里的问题是，我们为`false`值创建了一个封装对象，但对象是真值（即“truthy”，总是返回`true`，见`第四章`），所以使用封装对象和使用`false`值的结果大相径庭。

如果你想要得到封装对象内的基本类型值，可以使用`valueOf()`函数

22 ****

封装对象扮演的角色十分重要。因为基本类型值没有属性和方法，我们需要通过封装对象来访问`.length`和`.toString()`，此时JS会自动为基本类型值*包装*（box或者wrap）一个封装对象：

```
    var a = "abc";
    
    a.length; // 3
    a.toUpperCase(); // "ABC"
```

21.1 ****

原生函数可以被当做构造函数来使用。但是它们创建出来的对象可能会和我们预想的有出入：

```
    var a = new String( "abc" );
    
    typeof a;                            // "object" ... not "String"
    
    a instanceof String;                 // true
    
    Object.prototype.toString.call( a ); // "[object String]"
```

通过构造函数（如`new String("abc")`）创建的对象是包含基本类型值（如`"abc"`）的封装对象。

21 ***

###内部属性[[Class]]

`typeof`返回值为`"object"`的对象（如`array`）包含一个内部属性`[[Class]]`（我们可以把它看作是一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般是通过`Object.prototype.toString(..)`来访问。例如：

```
    Object.prototype.toString.call( [1,2,3] );
    // "[object Array]"

    Object.prototype.toString.call( /regex-literal/i );
    // "[object RegExp]"
```

20.3 *****

虽然这里传递的是一个指向`Number`对象的引用拷贝，但和预想的不同，我们并不能通过它来更改其中的基本类型值：

```
    function foo(x) {
        x = x + 1;
        x; // 3 
    }
    
    var a = 2;
    var b = new Number( a ); // or equivalently `Object(a)`
    
    foo( b );
    console.log( b ); // 2, not 3
```

因为标量基本类型值是不可更改的（`字符串`和`布尔`也是如此）。如果一个`数字`对象的标量基本类型值是`2`，那么该值就不能被更改，除非创建一个包含新值的`数字`对象。

当执行`x = x + 1;`时，`x`中的标量基本类型值`2`被从`数字`对象中提取出来，`x`神不知鬼不觉地从引用变成了`数字`对象，它的值为`2 + 1`等于`3`。然而函数外部的`b`仍然指向原来那个值为`2`的`数字`对象。

20.2 ****

由于引用指向的是值本身而非变量，所以一个引用无法更改另一个引用的指向。

```
    var a = [1,2,3];
    var b = a;
    a; // [1,2,3]
    b; // [1,2,3]
    
    // later
    b = [4,5,6];
    a; // [1,2,3]
    b; // [4,5,6]
```

`b=[4,5,6]`给'b'赋新值时，并不影响`a`指向的值`[1,2,3]`。除非`b`不是指向`array`的引用，而是指向'a'的指针。但是这种情况在JS中不存在！

......

如果要将`a`指向的值更改为`[4,5,6,7]`，我们必须更改`x`指向的`数组`的内容，而不是为`x`赋值一个新的`数组`。

```
    function foo(x) {
        x.push( 4 );
        x; // [1,2,3,4]

        // later
        x.length = 0; // empty existing array in-place
        x.push( 4, 5, 6, 7 );
        x; // [4,5,6,7]
    }
    
    var a = [1,2,3];

    foo( a );
    
    a; // [4,5,6,7] not [1,2,3,4]
```

20.1 *****

JavaScript在语法上对值和引用的赋值／传递不做区分，*仅通过值的类型来判断*。

```
    var a = 2;
    var b = a; // `b` is always a copy of the value in `a`
    b++;
    a; // 2
    b; // 3

    var c = [1,2,3];
    var d = c; // `d` is a reference to the shared `[1,2,3]` value
    d.push( 4 );
    c; // [1,2,3,4]
    d; // [1,2,3,4]
```

20 ****

反之，如果要象引用那样，将标量基本值传递到函数内并进行更改，就需要将该值封装到一个复合值（`对象`，`数组`，或其他）中，通过引用拷贝的方式传递。

```
    function foo(wrapper) {
        wrapper.a = 42;
    }

    var obj = { 
        a: 2
    };

    foo( obj );

    obj.a; // 42
```

19 *****

ES6中新加入了一个工具方法`Object.is(..)`来判断两个值是否绝对相等，可以处理上述所有的特殊情况：

```
    var a = 2 / "foo";
    var b = -3 * 0;

    Object.is( a, NaN );    // true
    Object.is( b, -0 );     // true

    Object.is( b, 0 );      // false
```

对于ES6之前的版本，`Object.is(..)`有一个简单的polyfill：

......

能使用`==`和`===`（见`第四章`）时就尽量不要使用`Object.is(..)`，因为前者效率更高、更通用。`Object.is(..)`主要用来处理那些特殊的相等比较。

18 ***

负零转换为字符串结果是“`0`”

......

-0 == 0; // true

-0 === 0; // true

17 ***

```
    var a = 1 / 0;  // Infinity
    var b = -1 / 0; // -Infinity
```

......

因为从数学运算和JavaScript语言的角度来说，`Infinity / Infinity`是一个未经定义的运算操作。JS中它的运算结果是`NaN`。

那么有穷数正数除以`Infinity`呢？很简单，结果是`0`。有穷负数除以`Infinity`呢？我们后面介绍。

16 ***

```
    var a = 2 / "foo";      // NaN

    typeof a === "number";  // true
```

......

`NaN != NaN`为`true`

......

很明显"foo"*不是一个数字*，但是它也不是`NaN`。这个bug自JS问世以来就一直存在，至今超过19年了。

从ES6开始，有一个替代工具函数`Number.isNaN(..)`。它是一个简单的polyfill，你可以在ES6之前的浏览器中安全地测试`NaN`值。

......

`NaN`有意无意地反映了很多JS程序面临的一个现实问题。它使得我们尽量使用`Number.isNaN(..)`这样的可靠的测试方法，无论是系统内置还是polyfill都是如此。

如果你用到了`isNaN(..)`，很不幸你的代码会有bug。

15.1 ***

表达式`void ___`没有返回值，因此返回值是`undefined`。`void`并不改变表达式的结果，只是让表达式没有返回值：

```
    var a = 42;

    console.log( void a, a ); // undefined 42
```

15 **

在`非严格`和`严格`模式下，你可以声明一个名为`undefined`的局部变量。再次强调我们不建议这样做。

```
   function foo() {
        "use strict";
        var undefined = 2;
        console.log( undefined ); // 2
    }

    foo();
```

14.1 ***

要检测一个值是否是整数，可以使用ES6中的`Number.isInteger(..)`方法：

```
    Number.isInteger( 42 );     // true
    Number.isInteger( 42.000 ); // true
    Number.isInteger( 42.3 );   // false
```

14 *****

常见的方法是设置一个误差范围值，我们通常称为“机器精度（machine epsilon）”，对于JavaScript中的`数字`来说这个值通常是`2^-52 (2.220446049250313e-16)`。

从ES6开始，该误差范围值定义在`Number.EPSILON`中，我们可以直接拿来用，也可以为ES6之前的版本polyfill该值：

```
    if (!Number.EPSILON) {
        Number.EPSILON = Math.pow(2,-52);
    }
```

我们可以使用`Number.EPSILON`来比较两个`数字`是否（在指定的误差范围内）相等：

```
    function numbersCloseEnoughToEual(n1,n2) {
        return Math.abs( n1 - n2 ) < Number.EPSILON;
    }

    var a = 0.1 + 0.2;
    var b = 0.3;

    numbersCloseEnoughToEqual( a, b );                  // true
    numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );  // false
```

......

有时JS程序需要处理一些比较大的数字，如数据库中的64位ID等常见情况。由于JavaScript的`数字`类型无法精确呈现64位数值，所以必须将它们保存（转换）为`字符串`来处理。

13 *****

二进制浮点数最大的问题（不仅是JavaScript，所有遵循IEEE 754规范的语言都是如此），是会出现下面的情况：

```
    0.1 + 0.2 === 0.3; // false
```

12 ***

这些方法不仅适用于`数字`变量，也适用于`数字`常量。不过在使用`.`操作符时需要特别注意，因为它是一个合法的数字字符，它会被尽可能优先识别为`数字`常量的一部分，然后才是对象属性访问操作符。

```
    // invalid syntax:
    42.toFixed( 3 );    // SyntaxError

    // these are all valid:
    (42).toFixed( 3 );  // "42.000"
    0.42.toFixed( 3 );  // "0.420"
    42..toFixed( 3 );   // "42.000"
```

`42.toFixed(3)`是非法语法，因为`.`被视为常量`42.`的一部分（如前所述），因此没有`.`访问运算符来调用`toFixed`方法。

11.1 ****

```
    function foo() {
        var arr = Array.prototype.slice.call( arguments );
        arr.push( "bam" );
        console.log( arr );
    }

    foo( "bar", "baz" ); // ["bar","baz","bam"]
```

如上所示，`slice()`返回参数列表（在本例中是一个类`array`）的一个数组复本。

ES6中的内置工具函数`Array.from(..)`也实现同样的功能：

```
    ...
    var arr = Array.from( arguments );
    ...
```

11 ****

此外，很多`数组`函数在处理`字符串`时非常有用，`字符串`中没有这些函数，但我们可以“借用”`数组`的这些非变更方法（nonmutation）来处理`字符串`：

```
    a.join;         // undefined
    a.map;          // undefined

    var c = Array.prototype.join.call( a, "-" );
    var d = Array.prototype.map.call( a, function(v){
        return v.toUpperCase() + ".";
    } ).join( "" );
    
    c;              // "f-o-o"
    d;              // "F.O.O."
```

我们再来看看另外一个例子：`字符串`反转（经常在JavaScript面试中遇到的问题！）。`数组`有一个可变更成员函数`reverse()`，而`字符串`没有：

```
    a.reverse;      // undefined

    b.reverse();    // ["!","o","O","f"]
    b;              // ["f","O","o","!"]
```

遗憾的是，此类“借用”对于`数组`的可变更成员函数不适用，因为`字符串`是不可变的，其内容无法更改：

```
    Array.prototype.reverse.call( a );
    // 返回值仍然是"foo"的一个字符串封装对象（见第三章）:(
```

一个变通（破解）的办法是将`字符串`转换为`数组`，执行需要的操作，然后再转换回`字符串`：

```
    var c = a
        // split `a` into an array of characters
        .split( "" )
        // reverse the array of characters
        .reverse()
        // join the array of characters back to a string
        .join( "" );
    
    c; // "oof"
```

10 ****

`字符串`不可变是指`字符串`的成员函数不会改变`字符串`的原始值，而是创建并返回一个新的`字符串`。而`数组`的成员函数都是在其原始值上进行操作。

9 ****

然而有一个容易出错的地方需要我们注意，如果作为键值的`字符串`可以被强制类型转换为10进制`数字`，则系统则视其为`数字`索引而非`字符串`键值！

```
    var a = [ ];
    a["13"] = 42;
    a.length; // 14
```

8.2 *****

`数组`通过数字进行索引，有趣的是因为`数组`的类型是`对象`，所以也可以包含`字符串`键值和属性（这些并不计算在数组长度`length`内）：

```
    var a = [ ];

    a[0] = 1;
    a["foobar"] = 2;
    
    a.length;       // 1
    a["foobar"];    // 2
    a.foobar;       // 2
```

这里我们需要特别注意一个坑（gotcha），即如果`字符串`键值能够被强制类型转换为十进制`数字`的话，就会被当做`数字`索引来处理！

```
    var a = [ ];

    a["13"] = 42;
    
    a.length; // 14
```

8.1 *****

和强类型语言不同，在JavaScript中，`array`可以容纳任何类型的值，可以是`string`，`number`，`object`，甚至是其他`array`（多维数组就是通过这种方式来实现的）：

```
    var a = [ 1, "2", [3] ];

    a.length;       // 3
    a[0] === 1;     // true
    a[2][0] === 3;  // true
```

...

<b>delete</b>操作可将值从<b>数组</b>中移除，但需要注意的是，值被移除后数组的<b>length</b>属性并不会相应发生变化。我们会在<b>第五章</b>详细介绍<b>delete</b>操作。

8 **

`数组`使用数字索引，因为其也是`对象`，因此可以包含字符串键值和属性（并不计算在数组长度`length`内）：

......

`数组`通过数字进行索引，有趣的是因为`数组`的类型是`object`，所以也可以包含`字符串`键值和属性（这些并不计算在数组长度`length`内）：

```
    var a = [ ];

    a[0] = 1;
    a["foobar"] = 2;
    
    a.length;       // 1
    a["foobar"];    // 2
    a.foobar;       // 2
```

7 *****

问题是在程序中怎样来检查全局变量`DEBUG`才不会出现`ReferenceError`错误。这时`typeof`的安全防范机制就成了我们的好帮手：

```
    // 这样做会产生错误
    if (DEBUG) {
        console.log( "Debugging is starting" );
    }
    // 这样做则是安全的，不会产生错误
    if (typeof DEBUG !== "undefined") {
        console.log( "Debugging is starting" );
    }

```

这不仅对用户定义的变量有用，对内建的API也很有用：

```
    if (typeof atob === "undefined") {
        atob = function() { /*..*/ };
    }

6.2 *****

还有一些人喜欢使用“依赖注入”（dependency injection）设计模式，就是将依赖通过参数显式地传递到函数中，如：

    function doSomethingCool(FeatureXYZ) {
        var helper = FeatureXYZ ||
            function() { /*.. default feature ..*/ };
        var val = helper();
        // ..
    }

6.1 *****

另外有一种方法不用通过`typeof`的安全防范机制，就是检查全局变量是否是全局对象的属性，在浏览器中全局对象是`window`。所以前面的例子也可以这样来实现：

```
    if (window.DEBUG) {
        // ..
    }
    
    if (!window.atob) {
        // ..
    }
```

与未声明变量不同，访问不存在的对象属性不会产生`ReferenceError`错误。

6 *****


```
    var a;

    a; // undefined
    b; // ReferenceError: b is not defined
```

......

```
    var a;

    typeof a; // "undefined"

    typeof b; // "undefined"
```

5 ****

JavaScript中变量是没有类型的，只有值才有。变量随时可以持有任意类型的值。

从另一个角度来理解就是JavaScript不“强制指定类型”，也就是说语言引擎不要求变量总是持有与其初始值相同类型的值。一个变量可以当前被赋予字符串类型的值，随后又被赋予数字类型的值。

......

```
    var a = 42;
    typeof a; // "number"

    a = true;
    typeof a; // "boolean"
```

4 ***

那么数组的情况又如何呢？JavaScript本身支持数组，那它是不是也是一个特殊类型？

```
    typeof [1,2,3] === "object"; // true
```

非也，数组也是`object`类型。确切地说是`object`的一个子类型（见`第三章`），其中一个特征是数组中的元素按照数字顺序进行索引（而非普通对象那样是字符串键值），并且`length`属性会根据元素数量自动更新。

3 ***

那么`typeof`的第七个返回值字符串值是什么呢？

```
    typeof function a(){ /* .. */ } === "function"; // true
```

上面`typeof`的返回值容易让我们得出这样一个结论，就是`函数`（function）也是JavaScript的一个内置类型。然而如果你查阅规范就会知道，它实际上是`object`的一个“子类型”（subtype）。具体来说，函数被称为“可调用对象”（callable object），即该对象内部有一个｀\[\[Call\]\]｀属性使得它能够被执行。

2 *****

typeof null === "object"; // true

你需要使用复合条件来检测`null`值的类型，：

```
    var a = null;

    (!a && typeof a === "object"); // true
```

`null`是基本类型中唯一的一个“假值”（falsy或者false-like，见`第四章`）类型，`typeof`对其仍旧返回`"object"`。

1 ***

JavaScript有七种内置类型：

- null
- undefined
- boolean
- number
- string
- object
- symbol（ES6中新加入）