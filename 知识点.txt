14 ***

    if (!Number.EPSILON) {
        ...
    }

    or

    typeof Number.EPSILON == "undefined"

13 ***

```
    0.1 + 0.2 === 0.3; // false
```

12 ***

这些方法不仅适用于`数字`变量，也适用于`数字`常量。不过在使用`.`操作符时需要特别注意，因为它是一个合法的数字字符，它会被尽可能优先识别为`数字`常量的一部分，然后才是对象属性访问操作符。

```
    // invalid syntax:
    42.toFixed( 3 );    // SyntaxError

    // these are all valid:
    (42).toFixed( 3 );  // "42.000"
    0.42.toFixed( 3 );  // "0.420"
    42..toFixed( 3 );   // "42.000"
```

11 ***

此外，很多`数组`函数在处理`字符串`时非常有用，`字符串`中没有这些函数，但我们可以“借用”`数组`的这些非变更方法（nonmutation）来处理`字符串`：

```
    a.join;         // undefined
    a.map;          // undefined

    var c = Array.prototype.join.call( a, "-" );
    var d = Array.prototype.map.call( a, function(v){
        return v.toUpperCase() + ".";
    } ).join( "" );
    
    c;              // "f-o-o"
    d;              // "F.O.O."
```

我们再来看看另外一个例子：`字符串`反转（经常在JavaScript面试中遇到的问题！）。`数组`有一个可变更成员函数`reverse()`，而`字符串`没有：

```
    a.reverse;      // undefined

    b.reverse();    // ["!","o","O","f"]
    b;              // ["f","O","o","!"]
```

遗憾的是，此类“借用”对于`数组`的可变更成员函数不适用，因为`字符串`是不可变的，其内容无法更改：

```
    Array.prototype.reverse.call( a );
    // 返回值仍然是"foo"的一个字符串封装对象（见第三章）:(
```

一个变通（破解）的办法是将`字符串`转换为`数组`，执行需要的操作，然后再转换回`字符串`：

```
    var c = a
        // split `a` into an array of characters
        .split( "" )
        // reverse the array of characters
        .reverse()
        // join the array of characters back to a string
        .join( "" );
    
    c; // "oof"
```

10 **

`字符串`不可变的意思是`字符串`的成员函数都不会改动`字符串`的原始值，而是创建并返回一个新的`字符串`。而`数组`的成员函数都是在其原始值上进行操作。

9 ****

然而有一个容易出错的地方需要我们注意，如果作为键值的`字符串`可以被强制类型转换为10进制`数字`，则系统则视其为`数字`索引而非`字符串`键值！

```
    var a = [ ];
    a["13"] = 42;
    a.length; // 14
```

8 **

`数组`使用数字索引，因为其也是`对象`，因此可以包含字符串键值和属性（并不计算在数组长度`length`内）：

7

```
    // 这样做会产生错误
    if (DEBUG) {
        console.log( "Debugging is starting" );
    }
    // 这样做则是安全的，不会产生错误
    if (typeof DEBUG !== "undefined") {
        console.log( "Debugging is starting" );
    }

```

6

```
    var a;

    typeof a; // "undefined"

    typeof b; // "undefined"
```

5

在JavaScript中变量是没有类型的，只有值才有。变量随时可以持有任意类型的值。

```
    var a = 42;
    typeof a; // "number"

    a = true;
    typeof a; // "boolean"
```

4

那么数组的情况又如何呢？JavaScript本身支持数组，那它是不是也是一个特殊类型？

```
    typeof [1,2,3] === "object"; // true
```

非也，数组也是`object`类型。确切地说是`object`的一个子类型（见`第三章`），其中一个特征是数组中的元素按照数字顺序进行索引（而非普通对象那样是字符串键值），并且`length`属性会根据元素数量自动更新。

3

那么`typeof`的第七个返回值字符串值是什么呢？

```
    typeof function a(){ /* .. */ } === "function"; // true
```

上面`typeof`的返回值容易让我们得出这样一个结论，就是`函数`（function）也是JavaScript的一个内置类型。然而如果你查阅规范就会知道，它实际上是`object`的一个“子类型”（subtype）。具体来说，函数被称为“可调用对象”（callable object），即该对象内部有一个｀\[\[Call\]\]｀属性使得它能够被执行。

2

typeof null === "object"; // true

你需要使用复合条件来检测`null`值的类型，：

```
    var a = null;

    (!a && typeof a === "object"); // true
```

1

JavaScript有七种内置类型：

- null
- undefined
- boolean
- number
- string
- object
- symbol（ES6中新加入）