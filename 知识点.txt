72 ****

首先`a`和`each`是通过`===`（见`第四章`）来进行相等比较。多数情况下`switch`中的`case`都是使用值，所以这样并没有问题。

然而我们有时可能需要通过强制类型转换来进行相等比较（即`==`，见`第四章`），这时就要在`switch`中做一些特殊处理：

```
    var a = "42";

    switch (true) {
        case a == 10:
            console.log( "10 or '10'" );
            break;
        case a == 42;
            console.log( "42 or '42`" );
            break;
        default:
            // never gets here
    }
    // 42 or '42'
```

除了简单值，`case`中还可以出现各种表达式，它会将表达式的结果值和`true`进行比较。因为`a == 42`的结果为`true`，所以条件成立。

尽管可以使用`==`，但`switch`中`true`和`true`之间仍然是严格相等比较。如果`case`表达式的结果为真值，但不是严格意义上的`true`（见`第四章`），则条件不成立。所以如果在这里使用`||`和`&&`“逻辑运算符”就很容易掉坑里：

```
    var a = "hello world";
    var b = 10;

    switch (true) {
        case (a || b == 10):
            // never gets here
            break;
        default:
            console.log( "Oops" );
    }
    // Oops
```

......

```
    var a = 10;

    switch (a) {
            case 1:
            case 2:
                    // never gets here
            default:
                    console.log( "default" );
            case 3:
                    console.log( "3" );
                    break;
            case 4:
                    console.log( "4" );
    }
    // default
    // 3
```

上例中的代码是这样执行的，首先遍历并找到所有匹配的`case`，如果没有匹配则执行`default`中的代码。因为其中没有`break`，所以继续执行已经遍历过的`case 3`代码块，直到`break`为止。

71 *****

```
    function foo() {
            try {
                return 42;
            } 
            finally {
                console.log( "Hello" );
            }

            console.log( "never runs" );
    }

    console.log( foo() );
    // Hello
    // 42
```

......

```
    function foo() {
        try {
            throw 42; 
        }
        finally {
            console.log( "Hello" );
        }

      console.log( "never runs" );
    }

    console.log( foo() );
    // Hello
    // Uncaught Exception: 42
```

......

```
    function foo() {
        try {
            return 42;
        } 
        finally {
            throw "Oops!";
        }

        console.log( "never runs" );
    }
    
    console.log( foo() );
    // Uncaught Exception: Oops!
```

......

`continue`和`break`也是如此：

```
    for (var i=0; i<10; i++) {
        try {
            continue; 
        }
        finally {
            console.log( i );
        }
    }
    // 0 1 2 3 4 5 6 7 8 9
```

......

`finally`中的`return`将会覆盖`try`和`catch`中的`return`的返回值：

```
    function foo() {
        try {
            return 42;
        } 
        finally {
            // no `return ..` here, so no override
        } 
    }
    
    function bar() {
        try {
            return 42;
        }
        finally {
            // override previous `return 42`
            return; 
        }
    }

    function baz() {
        try {
            return 42;
        } 
        finally {
            // override previous `return 42`
            return "Hello";
        }
    }

    foo();  // 42
    bar();  // undefined
    baz();  // Hello
```

......

通常来说，在函数中省略`return`与`return;`和`return undefined;`结果是一样的，但是在`finally`中省略`return`则会返回前面的`return`值。

70 ***

如果向函数传递参数，`arguments`数组中的对应单元会和命名参数建立关联（linkage）以获得相同的值。如果不传递参数就不会建立关联。

但是在`严格`模式中并没有建立关联这一说：

```
    function foo(a) {
        "use strict";
        a = 42;
        console.log( arguments[0] );
    }

    foo( 2 );   // 2 (not linked)
    foo();      // undefined (not linked)
```

所以依赖这种关联并不好，实际上它来自于JavaScript语言引擎的底层实现，语言本身并没有这个特性。

虽然并非一无是处，但`arguments`数组已经被废止（特别是ES6引入剩余参数`...`（rest parameters）之后，参见本系列的*《ES6 & Beyond》*）。

在ES6之前，获得传递给函数的所有参数的唯一途径就是`arguments`数组，它非常有用。我们还可以将命名参数和`arguments`数组混用，只要遵守一个原则就不会有问题，即*永远不要同时访问命名参数和其对应的`arguments`数组单元*。这样就能确保不会出现关联泄露（leaky linkage）：

```
   function foo(a) {
        console.log( a + arguments[1] ); // safe!
    }

    foo( 10, 32 );  // 42
```

69 ****

在ES6中，如果某个参数被省略或者值为`undefined`，则使用它的缺省值：

```
    function foo( a = 42, b = a + 1 ) {
        console.log( a, b );
    }

    foo();              // 42 43
    foo( undefined );   // 42 43
    foo( 5 );           // 5 6
    foo( void 0, 7 );   // 42 7
    foo( null );        // null 1
```
......

这里省略掉参数和传递`undefined`值的效果是一样的。然而它们之间的区别还是可以通过某些形式体现出来：

```
    function foo( a = 42, b = a + 1 ) {
        console.log(
            arguments.length, a, b,
            arguments[0], arguments[1]
        );
    ￼}

    foo();                  // 0 42 43 undefined undefined
    foo( 10 );              // 1 10 11 10 undefined
    foo( 10, undefined );   // 2 10 11 10 undefined
    foo( 10, null );        // 2 10 null 10 null
```

68 ***

```
{
    typeof a;   // undefined
    typeof b;   // ReferenceError! (TDZ)
    let b;
}
```

......

```
    var b = 3;

    function foo( a = 42, b = a + b + 5 ) {
        // ..
    }
```

`b = a + b + 5`试图在参数`b`的TDZ中访问`b`（并非函数外的那个`b`），因此会出错。然而访问`a`却没有问题，因为其刚好越过了参数`a`的TDZ。

67 ***

ES5规范的`严格（strict）`模式定义了更多的前期错误。比如在`严格`模式中，函数的参数不能重名：

```
    function foo(a,b,a) { }                 // just fine
    function bar(a,b,a) { "use strict"; }   // Error!
```

66 ***

ASI只在换行符（即line break）处起作用，不会在代码行的中间插入分号。

......

语法规定`do..while`后必须带`;`，`while`和`for`则不需要。大部分人不记得这一点，此时ASI就会自动加上分号。

65 **

我个人的观点是，依赖运算符优先级／关联性规则和使用`( )`自行控制运算符的结合这两者都应该兼顾，对于`第四章`中的*隐式*强制类型转换我也持同样的观点，我们应该安全合理地运用它们，而非无节制地滥用。

64 ***

```
    true ? false : true ? true : true;      // false

    true ? false : (true ? true : true);    // false
    (true ? false : true) ? true : true;    // true
```

63 *****

对于运算符`&&`和`||`来说，如果能够从左边的操作数得出结果，右边的操作数即可被略过。我们称之为“短路（short circuited）”（即执行最短路径）。

......

if (opts && opts.cool)

......

if (opts.cache || primeCache())

62 *****

```
    false && true || true;      // true
    (false && true) || true;    // true
```

......

```
    true || false && false;     // true

    (true || false) && false;   // false--晕
    true || (false && false);   // true--欧耶!
```

......

`&&`先于`||`执行

......

因为`&&`的优先级高于`||`，`||`的优先级又高于`? :`。

61 ****

```
    var a = 42, b;
    b = ( a++, a );
    
    a;  // 43
    b;  // 43
```

如果去掉`( )`会出现什么情况呢？

```
    var a = 42, b;
    b = a++, a;

    a;  // 43
    b;  // 42
```

60 *****

人们常误以为JavaScript中有`else if`，因为可以这样写代码：

```
    if (a) { 
        // ..
    }
    else if (b) {
        // .. 
    }
    else { 
        // ..
    }
```

...

我们经常用到的`else if`实际上是这样的：
```
    if (a) { 
        // ..
    } 
    else {
        if (b) { 
            // ..
        } 
        else {
            // .. 
        }
    }
```

59 ****

ES6中的解构赋值

......

```
    function foo({ a, b, c }) {
        // no need for:
        // var a = obj.a, b = obj.b, c = obj.c
        console.log( a, b, c );
    }

    foo( {
        c: [1,2,3],
        a: 42,
        b: "foo"
    } );    // 42 "foo" [1, 2, 3]
```

58 ***

下面是另一个常见的坑（涉及强制类型转换，见`第四章`）：

```
    [] + {}; // "[object Object]"
    {} + []; // 0
```

57 ***

`{"a":42}`作为JSON值没有任何问题，但是在作为代码执行时会产生JS错误，因为它被当作一个带有非法标签的语句块来执行。`foo({"a":42})`就没有问题，因为`{"a":42}`在这里是一个传递给`foo(..)`的`object`常量。因此，确切地说，*JSON-P能将JSON转换为合法的JS语法*。

56 *****

```
    // assume there's a `bar()` function defined
    {
        foo: bar()
    }
```

......

然而JS支持某种有限度的特别的`goto`：标签跳转（labeled jumps）。`continue`和`break`语句都可以带一个标签，这样程序执行流程就可以象`goto`那样进行跳转了。

......

<b>contine foo</b>的意思不是“跳转到标签<i>foo</i>所在位置继续执行”，而是“继续执行标签为<i>foo</i>的循环代码的下一个循环”。所以这里的<b>foo</b>并非<b>goto</b>。

......

<b>break foo</b>的意思不是“跳转到标签<i>foo</i>所在位置继续执行”，而是“跳出标签<i>foo</i>所在的循环／代码块，继续执行其后的代码”。所以它并非传统意义上的<b>goto</b>。

......

标签也能用于非循环代码块，但只有`break`可以这样。我们可以对带标签的代码块使用`break ___`，但是不能对带标签的非循环代码块使用`continue ___`，也不能对不带标签的代码块使用`break`：

55 ****

赋值表达式（或者语句）的结果值在串联多个赋值语句（链式赋值，chained assignments）的时候很有用，比如：

```
    var a, b, c;

    a = b = c = 42;
```

这里`c = 42`的结果值为`42`（产生的边缘效应是`42`被赋值给`c`），然后`b = 42`的结果值为`42`（产生的边缘效应是`42`被赋值给`b`），最后是`a = 42`（产生的边缘效应是`42`被赋值给`a`）。

54 ***

```
    var a;
    
    a = 42;     // 42
    a;          // 42
```

`a = 42`中的`=`看似没有边缘效应。但是如果我们检查一下语句`a = 42`的结果值就会发现，它返回的是`42`，所以`=`的边缘效应就是给`a`赋值。


53 ****

```
    var a = 42, b;
    b = ( a++, a );
    
    a;  // 43
    b;  // 43
```

52 ***

考考你，<b>++a++</b>这样的语法是否合法？你试一试就知道，它会产生<b>ReferenceError</b>错误。因为运算符需要将它产生的边缘效应赋值给一个变量。以<b>++a++</b>为例，首先执行<b>a++</b>（根据运算符优先级，见下），返回a递增之前的值<b>42</b>。然后执行<b>++42</b>，这时会产生<b>ReferenceError</b>错误，因为<b>++</b>无法直接在<b>42</b>这样的值上产生边缘效应。

51 ****

```
    var a = 42;
    var b = a++;

    a;  // 43
    b;  // 42
```

......

当`++`出现在操作数前面时，如：`++a`，它的边缘效应（递增`a`）发生在表达式返回结果值之前，而`a++`的边缘效应发生在之后。

50 ****

相等比较中有严格相等，而关系比较中没有“严格关系比较（strict relational comparison）”。也就是说如果要避免关系比较中的*隐式*强制类型转换，比如`a < b`，我们只能确保`a`和`b`的类型一致，除此之外别无他法。

和`==`及`===`的完整性检查同样的道理。我们应该在必要和安全的情况下使用强制类型转换，如：`42 < "43"`。另一方面，如果要确保关系比较的安全，就应该在比较之前使用*显式强制类型转换*：

```
    var a = [ 42 ];
    var b = "043";

    a < b;                      // false -- string comparison!
    Number( a ) < Number( b );  // true -- number comparison!
```

49 ****

```
    var a = { b: 42 };
    var b = { b: 43 };

    a < b;  // false
    a == b; // false
    a > b;  // false
    
    a <= b; // true
    a >= b; // true
```

......

但如果`a < b`和`a == b`的结果都是`false`，为什么`a <= b`和`a >= b`的结果是`true`呢？

因为根据规范，`a <= b`实际上是先执行`b < a`，然后将结果反转。因为`b < a`的结果是`false`，所以`a <= b`的结果为`true`。

48 *****

关键是要对`==`两边的值仔细斟酌。以下两条规则可以让我们有效地避免出错：

- 如果两边的值有可能转换为`true`或者`false`时，不要使用`==`。
- 如果两边的值有可能转换为`[]`，`""`或者`0`时，请考虑尽量不要使用`==`。

47 ****

这还不算完，还有更极端的例子：

```
    [] == ![]   // true
```

这看起来更疯狂了。我们会以为是这是真值和假值之间相等比较，因此不应该得到`true`的结果，因为一个值不可能同时既是真值也是假值！

但是事实并非如此。让我们细细探来，看看`!`运算符都做了些什么？它根据`ToBoolean`规则将值显式强制类型转换为`boolean`值（同时反转奇偶校验位）。所以在`[] == ![]`执行之前已经成为这样了：`[] == false`。从前面的例子中我们知道`false == []`，所以最后的结果一点也不出人意外。

那么其他情况呢？

```
    2 == [2];       // true
    "" == [null];   // true
```

我们在介绍`ToNumber`时说过，右边的值`[2]`和`[null]`会执行`ToPrimitive`强制类型转换，以便能够和左边的基本类型值进行比较（`2`和`""`）。因为`数组`的`valueOf()`返回`数组`本身，所以强制类型转换将对`数组`进行字符串化。

第一行的`[2]`会被转换为`"2"`，然后通过`ToNumber`转换为`2`。第二行的`[null]`会被直接转换为`""`。

因此`2 == 2`和`"" == ""`的结果就完全可以理解了。

......

还有经常被提及的坑是：

```
    0 == "\n";  // true
```

46 ****

```
    "0" == null;        // false
    "0" == undefined;   // false
    "0" == false;       // true -- 晕！
    "0" == NaN;         // false
    "0" == 0;           // true
    "0" == "";          // false

    false == null;      // false
    false == undefined; // false
    false == NaN;       // false
    false == 0;         // true -- 晕！
    false == "";        // true -- 晕！
    false == [];        // true -- 晕！
    false == {};        // false

    "" == null;         // false
    "" == undefined;    // false
    "" == NaN;          // false
    "" == 0;            // true -- 晕！
    "" == [];           // true -- 晕！
    "" == {};           // false

    0 == null;          // false
    0 == undefined;     // false
    0 == NaN;           // false
    0 == [];            // true -- 晕！
    0 == {};            // false
```

45 ****

```
    Number.prototype.valueOf = function() {
        return 3;
    };

    new Number( 2 ) == 3;   // true
```

44 *****

== 和 ===

```
1. 如果Type(x)是数字，Type(y)是字符串，则返回x == ToNumber(y)的结果。
2. 如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x) == y的结果。
```

```
1. 如果Type(x)是`boolean`值，则返回ToNumber(x) == y的结果。
2. 如果Type(y)是`boolean`值，则返回x == ToNumber(y)的结果。
```

"42" == true // false
"42" == false // false

我们需要理解`==`算法如何是怎样处理不同的类型组合的。它首先会将`==`两边的`boolean`值强制类型转换为`number`。

永远不要使用`== true`和`== false`。

在`==`中`null`和`undefined`相等（同时它们也和自身相等），除它们之外其他值都不存在这种情况。

null == false // false
+null == false // true

Number(null) // 0
Number(false) // +0

```
    var a = "abc";
    var b = Object( a );    // same as `new String( a )`

    a === b;                // false
    a == b;                 // true
```

43 *****

“在相等比较中，`==`允许强制类型转换，而`===`不允许”。

42 ****

```
    var a = 42;
    var b = null;
    var c = "foo";
    
    if (a && (b || c)) {
        console.log( "yep" );
    }
```

以上代码的执行结果和我们预期的一样，除了一处细节，`a && (b || c)`表达式的返回值实际上是`"foo"`，而非`true`。随后由`if`表达式将`foo`强制类型转换为`boolean`，最后结果为`true`。

41 ***

```
    function foo() {
        console.log( a );
    }
    
    var a = 42;
    
    a && foo(); // 42
```

只有在`a`条件测试通过的时候`foo()`才会被调用。如果条件测试不通过，`a && foo()`语句就会默默地终止（也称为“短路，short circuiting”），`foo()`不会被调用。

对于程序员来说这样的用法不太常见，通常我们会使用`if (a) { foo(); }`。但是JS代码压缩工具会使用`a && foo()`，因为它更精简。以后我们如果再看到这样的代码就能知其所以然了。

40 ****

但是还要注意一点！

```
    foo( "That's it!", "" ); // "That's it! world" <-- Oops!
```

你能看到问题所在吗？第二个参数""是一个假值（见`第67页“ToBoolean”`），因此`b = b || "world"`条件判断结果为假，返回缺省值`"world"`，虽然你可能本意是想传递空字符串`""`给`b`。

`||`这样的用法非常常见，也很有用，但是你需要确保在使用中避免传递`假值`。否则你就需要在条件判断中更加清晰地说明条件，也可以换而实用`? :`三元表达式。

39 ****

`||`和`&&`操作符首先会对*第一个操作数*（`a`和`c`）进行`boolean`条件判断。如果它不是`boolean`值（如上例）则执行`ToBoolean`强制类型转换，以便执行条件判断。

对于`||`操作符来说，如果条件判断结果为`true`，`||`表达式返回第一个操作数（`a`和`c`）的值。如果条件判断结果为`false`则返回第二个操作数（`b`）的值。

相反，对于`&&`操作数，如果条件判断结果为`true`，`&&`表达式返回第二个操作数（`b`）的值。如果条件判断结果为`false`则返回第一个操作数（`a`和`c`）的值。

从另一个角度来理解：

```
    a || b;
    // roughly equivalent to:
    a ? a : b;

    a && b;
    // roughly equivalent to:
    a ? b : a;
```

38 ****

*&&和||操作符的返回值并不一定是`boolean`类型。它们的返回值是两个操作数其中的一个的值。*

37 ***

下面这些值我们称为假值（“falsy” values）：

- `undefined`
- `null`
- `false`
- `+0`，`-0`和`NaN`
- `""`

它们在`boolean`强制类型转换中为`false`。

按理说该列表以外的值应该会被转换为`true`，我们称为真值（“truthy” values）。但JS规范对此并没有明确定义，只给出了一些例子，比如明确规定所有对象都是真值，通常我们可以认为*所有不在假值列表中的值都是真值*。

36 ****

我们常误以为数值`1`和`0`分别等同于`true`和`false`。在有些语言中可能如此，而在JS中`boolean`和`number`是不同的。虽然我们可以将`1`强制类型转换为`true`（反之亦然），将`0`强制类型转换为`false`（反之亦然）。但它们本质上是不同的。

35 ***

####ToNumber

在某些情况下非`数字`值需要被当作`数字`来使用，比如数学运算，ES5规范中第9.3节定义了抽象操作`ToNumber`。

例如，`true`转换为`1`，`false`转换为`0`。`undefined`转换为`NaN`，而`null`则为`0`。

34 ***

我们可以向`JSON.stringify(..)`传递第二个参数，即可选参数（optional argument）*replacer*。它可以是`数组`或者`函数`，通过某种过滤机制来指定哪些属性应该被处理和排除，然后对结果进行序列化，以此来实现对象递归序列化的定制，类似`toJSON()`。

33 ****

JSON字符串化对于包含`toJSON()`方法的对象有一点特别，这时`toJSON()`方法会首先被调用，然后用它的返回值来做序列化。

如果我们要对含有非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要为该对象定义`toJSON()`方法，使之返回一个安全的JSON值。

我们通常会误以为`toJSON()`方法必须返回一个经过JSON字符串化的值。这并不准确，除非我们确实需要字符串化`字符串`（通常不会！）.`toJSON()`应该返回一个适当的值（可以是任何类型），然后再由`JSON.stringify(..)`来对其进行字符串化。

32 ****

ES5规范第9节中定义了一些“抽象操作”（“仅内部使用的操作”的规范用语）及其转换规则。我们这里着重介绍`ToString`，`ToNumber`，和`ToBoolean`，附带讲一讲`ToPrimitive`。

重要的话说两遍，`toString()`可以被显式调用，在非字符串值需要转换为字符串的时候也会被自动调用。

31 ****

将值从一种类型转换为另一种类型通常称为“类型转换”（type casting），这是指显式的情况，在隐式的情况下我们称为“强制类型转换”（coercion，具体怎么转换由值的使用规则来决定）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">JavaScript中强制类型转换总是返回标量基本类型值（见<b>第二章</b>），如：<b>字符串</b>，<b>数字</b>，和<b>布尔值</b>。强制类型转换不会返回<b>对象</b>和<b>函数</b>。在<b>第三章</b>中我们介绍过“封装”，即为标量基本类型值封装一个对应类型的对象，但这并非严格意义上的强制类型转换。</td>
    </tr>
</table>

也可以这样来区分它们：“类型转换”发生在静态类型语言的编译阶段，而“强制类型转换”是发生在动态语言的运行时。

然而在JavaScript中大部份人都将它们统称为*强制类型转换*，我个人倾向于使用“隐式类型转换”和“显式类型转换”。

30 ***

###Prototypes作为默认值

`Function.prototype`是一个空函数，`RegExp.prototype`是一个“空”正则表达式（例如：没有任何匹配），而`Array.prototype`是一个空数组，对于那些还没有被赋值的变量来说它们是不错的缺省值。

例如：

```
    function isThisCool(vals,fn,rx) {
        vals = vals || Array.prototype;
        fn = fn || Function.prototype;
        rx = rx || RegExp.prototype;
        return rx.test(
            vals.map( fn ).join( "" )
        ); 
    }

    isThisCool();       // true
    
    isThisCool(
        ["a","b","c"],
        function(v){ return v.toUpperCase(); },
        /D/
    );                  // false
```

29 ***

任何字符串值都可以通过prototype delegation（参考本系列的*《this & Object Prototypes》*）来访问这些方法：

```
    var a = " abc ";
    
    a.indexOf( "c" ); // 3
    a.toUpperCase();  // " ABC "
    a.trim();         // "abc"
```

28 ***

我们必须遵循一个基本原则：任何情况下都不要创建和使用空单元数组。

27 ****

http://www.w3schools.com/js/js_function_invocation.asp

Invoking a Function with a Function Method
In JavaScript, functions are objects. JavaScript functions have properties and methods.

call() and apply() are predefined JavaScript function methods. Both methods can be used to invoke a function, and both methods must have the owner object as first parameter.

Example
function myFunction(a, b) {
    return a * b;
}
myObject = myFunction.call(myObject, 10, 2);     // Will return 20

Example
function myFunction(a, b) {
    return a * b;
}
myArray = [10, 2];
myObject = myFunction.apply(myObject, myArray);  // Will also return 20

26 ***

http://www.w3schools.com/js/js_function_invocation.asp

The Global Object
When a function is called without an owner object, the value of this becomes the global object.

In a web browser the global object is the browser window.

This example returns the window object as the value of this:

Example
function myFunction() {
    return this;
}
myFunction();                // Will return the window object

25 ***

    var a = new Array( 3 );
    var b = [ undefined, undefined, undefined ];
    var c = [];

```
    a.join( "-" ); // "--"
    b.join( "-" ); // "--"

    a.map(function(v,i){ return i; }); // [ undefined x 3 ]
    b.map(function(v,i){ return i; }); // [ 0, 1, 2 ]
```

24 ***

`数组`构造函数只带一个`数字`参数时，该参数会被当作数组的预设大小（length），而非数组中的一个元素。

这实在不是一个明智的做法，容易让人忽视和犯错。

更要命的是，`数组`并没有预设大小这个概念。这样创建出来的只是一个空数组（empty array），只不过其`length`属性被设置成了指定的值。

23 ***

通常我们不需要直接使用封装。最好是让JS引擎自己决定什么时候使用封装。换句话说就是应该优先考虑使用`"abc"`和`42`这样的基本类型值，而非`new String("abc")`和`new Number(42)`。

```
    var a = new Boolean( false );
    
    if (!a) {
        console.log( "Oops" ); // never returns
    }
```

这里的问题是，我们为`false`值创建了一个封装对象，但对象是真值（即“truthy”，总是返回`true`，见`第四章`），所以使用封装对象和使用`false`值的结果大相径庭。

如果你想要得到封装对象内的基本类型值，可以使用`valueOf()`函数

22 ****

封装对象扮演的角色十分重要。因为基本类型值没有属性和方法，我们需要通过封装对象来访问`.length`和`.toString()`，此时JS会自动为基本类型值*包装*（box或者wrap）一个封装对象：

```
    var a = "abc";
    
    a.length; // 3
    a.toUpperCase(); // "ABC"
```

21 ***

```
    Object.prototype.toString.call( [1,2,3] );
    // "[object Array]"

    Object.prototype.toString.call( /regex-literal/i );
    // "[object RegExp]"
```

20.3 *****

虽然这里传递的是一个指向`Number`对象的引用拷贝，但和预想的不同，我们并不能通过它来更改其中的基本类型值：

```
    function foo(x) {
        x = x + 1;
        x; // 3 
    }
    
    var a = 2;
    var b = new Number( a ); // or equivalently `Object(a)`
    
    foo( b );
    console.log( b ); // 2, not 3
```

因为标量基本类型值是不可更改的（`字符串`和`布尔`也是如此）。如果一个`数字`对象的标量基本类型值是`2`，那么该值就不能被更改，除非创建一个包含新值的`数字`对象。

当执行`x = x + 1;`时，`x`中的标量基本类型值`2`被从`数字`对象中提取出来，`x`神不知鬼不觉地从引用变成了`数字`对象，它的值为`2 + 1`等于`3`。然而函数外部的`b`仍然指向原来那个值为`2`的`数字`对象。

20.2 ****

由于引用指向的是值本身而非变量，所以一个引用无法更改另一个引用的指向。

```
    var a = [1,2,3];
    var b = a;
    a; // [1,2,3]
    b; // [1,2,3]
    
    // later
    b = [4,5,6];
    a; // [1,2,3]
    b; // [4,5,6]
```

`b=[4,5,6]`给'b'赋新值时，并不影响`a`指向的值`[1,2,3]`。除非`b`不是指向`array`的引用，而是指向'a'的指针。但是这种情况在JS中不存在！

......

如果要将`a`指向的值更改为`[4,5,6,7]`，我们必须更改`x`指向的`数组`的内容，而不是为`x`赋值一个新的`数组`。

```
    function foo(x) {
        x.push( 4 );
        x; // [1,2,3,4]

        // later
        x.length = 0; // empty existing array in-place
        x.push( 4, 5, 6, 7 );
        x; // [4,5,6,7]
    }
    
    var a = [1,2,3];

    foo( a );
    
    a; // [4,5,6,7] not [1,2,3,4]
```

20.1 *****

JavaScript在语法上对值和引用的赋值／传递不做区分，*仅通过值的类型来判断*。

```
    var a = 2;
    var b = a; // `b` is always a copy of the value in `a`
    b++;
    a; // 2
    b; // 3

    var c = [1,2,3];
    var d = c; // `d` is a reference to the shared `[1,2,3]` value
    d.push( 4 );
    c; // [1,2,3,4]
    d; // [1,2,3,4]
```

20 ****

反之，如果要象引用那样，将标量基本值传递到函数内并进行更改，就需要将该值封装到一个复合值（`对象`，`数组`，或其他）中，通过引用拷贝的方式传递。

```
    function foo(wrapper) {
        wrapper.a = 42;
    }

    var obj = { 
        a: 2
    };

    foo( obj );

    obj.a; // 42
```

19 *****

ES6中新加入了一个工具方法`Object.is(..)`来判断两个值是否绝对相等，可以处理上述所有的特殊情况：

```
    var a = 2 / "foo";
    var b = -3 * 0;

    Object.is( a, NaN );    // true
    Object.is( b, -0 );     // true

    Object.is( b, 0 );      // false
```

对于ES6之前的版本，`Object.is(..)`有一个简单的polyfill：

......

能使用`==`和`===`（见`第四章`）时就尽量不要使用`Object.is(..)`，因为前者效率更高、更通用。`Object.is(..)`主要用来处理那些特殊的相等比较。

18 ***

负零转换为字符串结果是“`0`”

......

-0 == 0; // true

-0 === 0; // true

17 ***

```
    var a = 1 / 0;  // Infinity
    var b = -1 / 0; // -Infinity
```

......

因为从数学运算和JavaScript语言的角度来说，`Infinity / Infinity`是一个未经定义的运算操作。JS中它的运算结果是`NaN`。

那么有穷数正数除以`Infinity`呢？很简单，结果是`0`。有穷负数除以`Infinity`呢？我们后面介绍。

16 ***

```
    var a = 2 / "foo";      // NaN

    typeof a === "number";  // true
```

......

`NaN != NaN`为`true`

......

很明显"foo"*不是一个数字*，但是它也不是`NaN`。这个bug自JS问世以来就一直存在，至今超过19年了。

从ES6开始，有一个替代工具函数`Number.isNaN(..)`。它是一个简单的polyfill，你可以在ES6之前的浏览器中安全地测试`NaN`值。

......

`NaN`有意无意地反映了很多JS程序面临的一个现实问题。它使得我们尽量使用`Number.isNaN(..)`这样的可靠的测试方法，无论是系统内置还是polyfill都是如此。

如果你用到了`isNaN(..)`，很不幸你的代码会有bug。

15.1 ***

表达式`void ___`没有返回值，因此返回值是`undefined`。`void`并不改变表达式的结果，只是让表达式没有返回值：

```
    var a = 42;

    console.log( void a, a ); // undefined 42
```

15 **

在`非严格`和`严格`模式下，你可以声明一个名为`undefined`的局部变量。再次强调我们不建议这样做。

```
   function foo() {
        "use strict";
        var undefined = 2;
        console.log( undefined ); // 2
    }

    foo();
```

14.1 ***

要检测一个值是否是整数，可以使用ES6中的`Number.isInteger(..)`方法：

```
    Number.isInteger( 42 );     // true
    Number.isInteger( 42.000 ); // true
    Number.isInteger( 42.3 );   // false
```

14 *****

常见的方法是设置一个误差范围值，我们通常称为“机器精度（machine epsilon）”，对于JavaScript中的`数字`来说这个值通常是`2^-52 (2.220446049250313e-16)`。

从ES6开始，该误差范围值定义在`Number.EPSILON`中，我们可以直接拿来用，也可以为ES6之前的版本polyfill该值：

```
    if (!Number.EPSILON) {
        Number.EPSILON = Math.pow(2,-52);
    }
```

我们可以使用`Number.EPSILON`来比较两个`数字`是否（在指定的误差范围内）相等：

```
    function numbersCloseEnoughToEual(n1,n2) {
        return Math.abs( n1 - n2 ) < Number.EPSILON;
    }

    var a = 0.1 + 0.2;
    var b = 0.3;

    numbersCloseEnoughToEqual( a, b );                  // true
    numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );  // false
```

......

有时JS程序需要处理一些比较大的数字，如数据库中的64位ID等常见情况。由于JavaScript的`数字`类型无法精确呈现64位数值，所以必须将它们保存（转换）为`字符串`来处理。

13 ***

二进制浮点数最大的问题（不仅是JavaScript，所有遵循IEEE 754规范的语言都是如此），是会出现下面的情况：

```
    0.1 + 0.2 === 0.3; // false
```

12 ***

这些方法不仅适用于`数字`变量，也适用于`数字`常量。不过在使用`.`操作符时需要特别注意，因为它是一个合法的数字字符，它会被尽可能优先识别为`数字`常量的一部分，然后才是对象属性访问操作符。

```
    // invalid syntax:
    42.toFixed( 3 );    // SyntaxError

    // these are all valid:
    (42).toFixed( 3 );  // "42.000"
    0.42.toFixed( 3 );  // "0.420"
    42..toFixed( 3 );   // "42.000"
```

`42.toFixed(3)`是非法语法，因为`.`被视为常量`42.`的一部分（如前所述），因此没有`.`访问运算符来调用`toFixed`方法。

11 ****

此外，很多`数组`函数在处理`字符串`时非常有用，`字符串`中没有这些函数，但我们可以“借用”`数组`的这些非变更方法（nonmutation）来处理`字符串`：

```
    a.join;         // undefined
    a.map;          // undefined

    var c = Array.prototype.join.call( a, "-" );
    var d = Array.prototype.map.call( a, function(v){
        return v.toUpperCase() + ".";
    } ).join( "" );
    
    c;              // "f-o-o"
    d;              // "F.O.O."
```

我们再来看看另外一个例子：`字符串`反转（经常在JavaScript面试中遇到的问题！）。`数组`有一个可变更成员函数`reverse()`，而`字符串`没有：

```
    a.reverse;      // undefined

    b.reverse();    // ["!","o","O","f"]
    b;              // ["f","O","o","!"]
```

遗憾的是，此类“借用”对于`数组`的可变更成员函数不适用，因为`字符串`是不可变的，其内容无法更改：

```
    Array.prototype.reverse.call( a );
    // 返回值仍然是"foo"的一个字符串封装对象（见第三章）:(
```

一个变通（破解）的办法是将`字符串`转换为`数组`，执行需要的操作，然后再转换回`字符串`：

```
    var c = a
        // split `a` into an array of characters
        .split( "" )
        // reverse the array of characters
        .reverse()
        // join the array of characters back to a string
        .join( "" );
    
    c; // "oof"
```

10 ****

`字符串`不可变是指`字符串`的成员函数不会改变`字符串`的原始值，而是创建并返回一个新的`字符串`。而`数组`的成员函数都是在其原始值上进行操作。

9 ****

然而有一个容易出错的地方需要我们注意，如果作为键值的`字符串`可以被强制类型转换为10进制`数字`，则系统则视其为`数字`索引而非`字符串`键值！

```
    var a = [ ];
    a["13"] = 42;
    a.length; // 14
```

8 **

`数组`使用数字索引，因为其也是`对象`，因此可以包含字符串键值和属性（并不计算在数组长度`length`内）：

......

<b>delete</b>操作可将值从<b>数组</b>中移除，但需要注意的是，值被移除后数组的<b>length</b>属性并不会相应发生变化。我们会在<b>第五章</b>详细介绍<b>delete</b>操作。

......

`数组`通过数字进行索引，有趣的是因为`数组`的类型是`object`，所以也可以包含`字符串`键值和属性（这些并不计算在数组长度`length`内）：

```
    var a = [ ];

    a[0] = 1;
    a["foobar"] = 2;
    
    a.length;       // 1
    a["foobar"];    // 2
    a.foobar;       // 2
```

7 ****

```
    // 这样做会产生错误
    if (DEBUG) {
        console.log( "Debugging is starting" );
    }
    // 这样做则是安全的，不会产生错误
    if (typeof DEBUG !== "undefined") {
        console.log( "Debugging is starting" );
    }

```

......

这类检查不仅对用户定义的变量有用，对检查内建的API功能也很有用：

```
    if (typeof atob === "undefined") {
        atob = function() { /*..*/ };
    }
```

6 ****


```
    var a;

    a; // undefined
    b; // ReferenceError: b is not defined
```

......

```
    var a;

    typeof a; // "undefined"

    typeof b; // "undefined"
```

5 ****

JavaScript中变量是没有类型的，只有值才有。变量随时可以持有任意类型的值。

从另一个角度来理解就是JavaScript不“强制指定类型”，也就是说语言引擎不要求变量总是持有与其初始值相同类型的值。一个变量可以当前被赋予字符串类型的值，随后又被赋予数字类型的值。

......

```
    var a = 42;
    typeof a; // "number"

    a = true;
    typeof a; // "boolean"
```

4 ***

那么数组的情况又如何呢？JavaScript本身支持数组，那它是不是也是一个特殊类型？

```
    typeof [1,2,3] === "object"; // true
```

非也，数组也是`object`类型。确切地说是`object`的一个子类型（见`第三章`），其中一个特征是数组中的元素按照数字顺序进行索引（而非普通对象那样是字符串键值），并且`length`属性会根据元素数量自动更新。

3 ***

那么`typeof`的第七个返回值字符串值是什么呢？

```
    typeof function a(){ /* .. */ } === "function"; // true
```

上面`typeof`的返回值容易让我们得出这样一个结论，就是`函数`（function）也是JavaScript的一个内置类型。然而如果你查阅规范就会知道，它实际上是`object`的一个“子类型”（subtype）。具体来说，函数被称为“可调用对象”（callable object），即该对象内部有一个｀\[\[Call\]\]｀属性使得它能够被执行。

2 ****

typeof null === "object"; // true

你需要使用复合条件来检测`null`值的类型，：

```
    var a = null;

    (!a && typeof a === "object"); // true
```

1 ***

JavaScript有七种内置类型：

- null
- undefined
- boolean
- number
- string
- object
- symbol（ES6中新加入）