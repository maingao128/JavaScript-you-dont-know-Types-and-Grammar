#你不知道的JavaScript － 类型和语法

##序

曾有人说：“JavaScript是唯一一门程序员先用后学的语言。”

每次听到这句话我都会付诸一笑，因为它对于我就是如此，不知道对其他程序员是否也一样。JavaScript，也许还有CSS和HTML，在互联网早期的大学计算机课程中并非主流的教学语言。新手程序员大多通过搜索和“查看源代码”的方式来自学这些Web的基础语言。

我仍然记得我高中时代的第一个网站项目。当时的任务是搭建一个网上商店，无论什么样的都行，因为我是詹姆斯∙邦德的粉丝，所以我决定搭建一个“黄金眼”商店。它包罗万象：背景音乐是“黄金眼”主题曲，有一个用JavaScript开发的瞄准器跟随鼠标移动，每次点击鼠标的时候会发出一声枪响。Q(JJ-??)实在应该为这个网站杰作感到骄傲。

我之所以讲到这个故事，是因为我当时使用的开发方式直到现在仍然有许多程序员在使用。我在项目中“拷贝－粘贴”了很多JavaScript代码，但根本没有理解它们是干什么的。现在流行的jQuery这样的JavaScript工具集，也在以它们各自的方式潜移默化地进一步鼓励了不深入学习JavaScript的方式。

我并不反对使用JavaScript工具集，事实上我还是MooTools JavaScript团队的成员之一。这些工具集功能如此强大的原因，恰恰是它们的开发者们从根本上了解它们，并且将其运用到了极致。了解这门语言的基本知识对我们来说仍然是非常重要的，这与掌握那些工具集一样会对我们非常有帮助。象Kyle Simpson的《你不知道的JS》系列这样的书，我们实在没有理由不学习。

《类型和语法》是该系列的第三本，它介绍了JavaScript核心基础知识，这些知识你永远不可能从“拷贝－粘贴”和JavaScript工具集中学到。前置（coercion）及其隐患、原生构造方法(JJ-??)、以及JavaScript的全部基础知识都在本书中做了详细的介绍，并配合以示例代码。同本系列的其他作品一样，Kyle的行文直中要点，没有多余的套话和修辞(JJ-??)，是我喜欢的技术书风格。

希望你们喜欢《类型和语法》这本书，并能够常读常新。

-David Walsh ([http://davidwalsh.name](http://davidwalsh.name)),
Senior Web Developer at Mozilla

------

##前言

我想你已经注意到了本书中的“JS”一词，但是它并非是用来咒骂JavaScript的简语，虽然咒骂一门语言是我们作为程序员的标志。

从互联网最早期开始，JavaScript就一直是实现内容交互体验的基本技术。虽然刚开始是用来实现鼠标移动轨迹闪烁效果，还有令人讨厌的弹出消息框。大约20年之后，JavaScript技术和功能得到了数量级的提高，没有人再怀疑它在互联网，这个世界上使用最广泛的软件系统，中的重要性和核心地位。

但是作为一门语言，它一直为人诟病，包括其历史沿革，更多是它的设计理念。它的命名，相对于其更成熟的哥哥Java，也被Brendan Eich称为“傻弟弟”。其实它的命名仅仅是政治和市场考量下的一个偶然。两个语言之间千差万别，“JavaScript”和“Java”之间如同“Carnival”（嘉年华）和“Car”之间一样毫无关联。

JavaScript在概念上和语法习惯上借鉴了许多语言，包括壮观的C风格的程序根，和相对隐晦的Scheme/Lisp风格的函数根，它能为更多的开发人员接受，包括没有编程经验的人。用JavaScript编写“Hello World”非常简单，让人很容易上手。

JavaScript或许是最容易上手和使用的语言之一，但是它的一些古怪的行为使得它不像其他语言那样容易完全掌握。使用C或者C++开发一个完整的程序需要对该语言有一个相当深入的了解。然而对于JavaScript来说，就算你使用它开发了一个完整的系统，也不见得对这门语言有什么深入理解。

这门语言中那些隐藏得很深的复杂概念，往往以一种看似简单的方式呈现，例如：将函数作为回调参数传递，使得JavaScript程序员乐于使用现成的语言机制，而不愿意去了解其中的原因。

JavaScript是一门简单易用的语言，应用广泛，同时又有着复杂和声名狼藉的语言机制，如果不用心掌握，即使经验丰富的JavaScript程序员也会对其出现理解上的偏差。

JavaScript的悖论就在于此，它的阿基里斯之踵正是我们要在本书解决的问题。因为你不需要理解就能够使用它，所以常常最终也不会去理解它。

###使命

在使用JavaScript时，每当遇到令人讶异或者抓狂的情况，你的反应如果是置之不理（这是人之常情），你很快会发现自己无法发挥这门语言的任何优势(JJ-??)。

这部分经常被称为“好的部分（The Good Parts）”，但我恳请读者朋友们不如把它视作“容易的部分”，“安全的部分”，甚至于“不完整的部分”。

《你不知道的JS》系列涉及的是另一个部分，即深入掌握JavaScript的所有知识，特别是那些重点难点。

我们让本书的内容对于JS程序员来说易于理解，而不强迫他们深入到原理。此外，在碰到疑难问题的时候我们不会避而不谈。

我不会满足于只是让代码运行而不明就里，，你也不应该仅仅满足于此。我会逐步用一些难点来挑战你，最终让你全面掌握JavaScript的威力。一旦掌握了这些知识，你将无法想象不需要技巧，框架，术语会是多么美妙的事情(JJ-??)。

本系列中的每本书全面深入地探讨了JavaScript中那些被误解，或者被低估的关键知识点。读完之后，从理论和实践上，对那些必须掌握的知识你都会有一个充分和自信的理解。

目前你对JavaScript的认识可能都来自于那些对JavaScript一知半解的人。JavaScript是一门语言，同时也是这门语言的一道影子。如果你还不真正了解它的话，读完本系列你会了解。让我们尽情地开始阅读吧。

###回顾

JavaScript是一门优秀的语言。它的各个部分学习起来都不难，但是要完全整体掌握则很难。当程序员遇到困惑时往往归咎于语言本身，而不是他们自身对语言的缺乏理解。本系列丛书旨在解决这个问题，让你能够发自内心地喜欢上这门语言。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">本书中的许多示例需要ES6这样的新一代的JavaScript引擎。一些代码可能无法在老的引擎（ES6之前）上运行。</td>
    </tr>
</table>


###书写约定

本书使用以下书写约定：

*斜体字*
表示新术语，URL，电子邮件，文件名，和文件扩展名。

等宽字
用于显示程序代码，和在段落中显示程序代码中的内容，如：变量名和函数名，数据库，数据类型，环境变量，声明语句，和关键词。

####粗体等宽字
需要用户输入的命令和其他文本。

*斜体等宽字*
需要用户提供替换值的文本，或者根据上下文计算的值。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">提示和建议</td>
    </tr>
</table>

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">注解</td>
    </tr>
</table>

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">警告和提醒</td>
    </tr>
</table>

###示例代码

本书的附带资料（如：示例代码，练习等）在[http://bit.ly/ydkjs-types-code](http://bit.ly/ydkjs-types-code)可以下载。

本书旨在帮助你解决实际问题。你可以在你的程序和文档中使用本书提供的示例代码。除非你使用了相当数量的示例代码，否则你不需要经过我们的许可。例如，你不必征得我们的同意既可在你的程序中使用几段本书的示例代码。如果你将O'Reilly出版的图书中的示例代码制作为光盘出售，则需要经过我们的许可。如果你在回答别人的问题时需要引用本书的内容和示例代码，你不需要征得我们许可。如果你的产品文档中引用了大量本书的示例代码，则需要征得我们许可。

如果你能够在使用到本书的地方注明出处，我们会非常感谢，不过这并不是强制的。注明出处通常包括书名，作者，出版方，和ISBN。例如：《你不知道的JS》，Kyle Simpson著，O'Reilly出版。Copyright 2015 Getify Solutions, Inc.,978-1-491-90419-0。

如果你觉得你的情况不属于上述两种情况，请通过[permissions@oreilly.com](permis‐ sions@oreilly.com)和我们联系。

###Safari Books Online

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/safari.png'></td>
        <td style="border: none;"><a href='http://safaribooksonline.com'>Safari Books Online</a>是及时点播式数字图书馆，为您提供来自世界顶尖科技和商业作者的专业书籍和视频<a href='https://www.safaribooksonline.com/explore'>内容</a>。</td>
    </tr>
</table>

科技工作者、软件开发人员、Web设计师和商业创新从业者都将Safari Books Online作为他们研究、攻关、学习和认证培训的一个主要资源。

Safari Books Onine为[企业](https://www.safaribooksonline.com/enterprise/)、[政府](https://www.safaribooksonline.com/government/)、[教育](https://www.safaribooksonline.com/academic-public-library/)和个人提供不同的[计划和收费](https://www.safaribooksonline.com/pricing/)。

Safari Books Online会员能够访问上千本图书，教学视频，和来自[上百家出版方](https://www.safaribooksonline.com/our-library)，如：O'Reilly Media，Prentice Hall Professional, Addison- Wesley Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders, McGraw-Hill, Jones & Bartlett, Course Tech‐ nology，并且可以在数据库中检索的正式出版前的稿件。有关Safari Books Online更多的信息请访问我们的网站。

------

###联系我们

关本书的想法和问题，您可以通过以下方式和我们联系：

O’Reilly Media, Inc.
1005 Gravenstein Highway North
Sebastopol, CA 95472
800-998-9938 (in the United States or Canada) 707-829-0515 (international or local) 707-829-0104 (fax)

我们为本书建设了一个网页，上面有勘误，示例，和其他信息。可以通过[http://bit.ly/ydkjs_types-and-grammar](http://bit.ly/ydkjs_types-and-grammar.)这个链接访问。

有关本书的评论和技术问题，可以发送邮件到[bookquestions@oreilly.com](bookquestions@oreilly.com)。

有关其他图书的信息，课程，论坛，和新闻，请访问我们的网站[http://www.oreilly.com](http://www.oreilly.com)。

我们的Facebook页面：[http://facebook.com/oreilly](http://facebook.com/oreilly)

关注我们的Twitter：[http://twitter.com/oreillymedia](http://twitter.com/oreillymedia)

我们的Youtube频道：[http://www.youtube.com/oreillymedia](http://www.youtube.com/oreillymedia)

------

##第一章 类型

很多开发人员认为动态语言（如：JavaScript）是没有类型的。让我们看看ES5.1规范（[http:// www.ecma-international.org/ecma-262/5.1/](http:// www.ecma-international.org/ecma-262/5.1/)）对此怎样解释：

```
本规范中的算法所操纵的值均有一个相对应的类型。本条款中定义了所有可能的值类型。类型是对ECMAScript语言类型和规范类型的进一步细分。
ECMAScript语言类型对应ECMAScript程序员使用该语言直接操纵的值。ECMAScript语言中的类型有：Undefined，Null，Boolean，String，Number，和Object。
```

如果你喜欢强类型（又称为静态类型）语言，你也许不同意使用“类型”一词。在强类型语言中，“类型”一词的含义比在JavaScript中广得多。

有人认为JavaScript中的“类型”应该叫“标签”或者“子类型”更合适。

我们在本书中对类型做如下粗略定义（和规范中一样）：*类型*是值的内部属性集合，它定义了该值的行为特征，使其能够区别于其他值。对于语言解析引擎和开发人员来说都是如此。

换句话说，如果语言解析引擎和开发人员对数字42和字符串"42"区别对待，则说明它们具有不同的类型，一个是数字，一个是字符串。我们通常会对数字42做数学运算。而对字符串"42"做一些其他操作，如将其显示到网页等等。所以它们的类型是不同的。

这样的定义并非十全十美，不过对于本书而言已经足够，而且它也与JavaScript语言对自身的描述一致。

###类型的另一面

抛开学术定义上的分歧不谈，JavaScript中有无类型为什么这么重要？

要合理准确地对值进行类型转换（见`第四章`），我们必须正确理解各个类型及其内部行为特征。几乎所有的JavaScript程序都涉及到各种形式的类型强制，因此你需要在处理这些情况时有充分的把握和信心。

如果你要将数字42当作字符串来处理，比如获得其第二个字符"2"，你就需要先将其从数字转换（强制）为字符串。

道理很明显。

但是强制类型转换的方式可以有很多种。有一些是显示的，比较容易，也比较可靠。但是如果你不小心，强制类型转换可能会产生意想不到的结果。

强制类型转换带来的困扰是JavaScript程序员最头疼的事情之一。它经常被诟病太危险，以至于被认为是语言设计上的缺陷，需要尽量回避。

在全面理解JavaScript中的类型的前提下，我们旨在阐述为什么强制类型转换的坏名声被过分夸大了，甚至一定程度上是错误的，这也许能够彻底转变你对它的看法，让你认识到它的强大和实用之处。不过首先我们需要对值和类型有一个更好的理解。

###内置类型

JavaScript中有7种内置类型：

- null
- undefined
- boolean
- number
- string
- object
- symbol（ES6中新增）

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">除object之外，其他统称为基本类型。</td>
    </tr>
</table>

typeof操作符检测值的类型，返回类型的字符串值。令人惊讶的是，以上7种类型和类型的字符串值并不一一对应：

```
    typeof undefined    === "undefined";    // true
    typeof true         === "boolean";      // true
    typeof 42           === "number";       // true
    typeof "42"         === "string";       // true
    typeof { life: 42 } === "object";       // true
    // added in ES6!
    typeof Symbol()     === "symbol";       // true
```

以上6个类型均有与其对应的字符串值，与类型名称相同。`Symbol`是ES6中新增的类型，我们将在`第三章`中介绍。

你可能注意到，null类型不在此列。它有些特殊，typeof运算符针对它的返回结果有bug：

```
    typeof null === "object"; // true
```

正确的返回结果应该是"null"，但是这是一个JavaScrtip固有的bug，已经存在近20年了，也可能永远不会被修复，因为太多的Web系统在“使用”这一bug，修复它将会产生更多的bug，导致大量的Web系统无法工作。

如果你想检测一个null值的类型，需要使用复合条件：

```
    var a = null;
    (!a && typeof a === "object"); // true
```

null是唯一一个“falsy”的基本类型（也称作false-like，见`第四章`），typeof对其仍然返回"object"。

那么typeof的第7个返回字符串值是什么呢？

```
    typeof function a(){ /* .. */ } === "function"; // true
```

上面的typeof的返回值容易让我们得出一个结论，就是`函数（function）`也是JavaScript的一个内置类型。然而如果你查阅规范就会知道，它实际上是`object`的一个子类型（subtype）。具体来说，函数被称为可调用对象（callable object），即该对象内部有一个\[\[Call\]\]属性，使其能够被执行。

函数是对象对我们很有用，更为重要的是，函数还可以拥有属性。例如：

```
    function a(b,c) {
        /* .. */
    }
```

函数对象的`length`属性设置为它的正式参数的数目：

```
    a.length; // 2
```

因为你为该函数定义了两个正式命名参数（b和c），所以函数的长度为2。

那么数组呢？JavaScript本身支持数组，那它是不是也是一个特殊类型？

```
    typeof [1,2,3] === "object"; // true
```

答案是no，数组也是object。确切地说，是object的一个子类型（见`第三章`），它另外一个特征是按照数字顺序进行索引（而非普通对象那样是字符串键值），并且它的`.length`属性会自动更新。

###值作为类型

JavaScript中变量没有类型，值才有。变量在任何时候都可以持有任何类型的值。

理解JavaScript类型的另一种方式是，JavaScript没有“强制类型检测”，就是语言解析引擎不要求一个变量总是持有与其初始值同样类型的值。变量可以一会持有字符串类型的值，一会持有数字类型的值，诸如此类。

值42的内部类型为number，它的类型无法更改。另一个值，如"42"，类型为字符串，能够通过强制类型转换的方式从数字42转换而来(coercion，见`第四章``)。

我们对变量使用typeof时，得到的并非是该变量的类型，因为JavaScript变量没有类型。我们得到的是变量持有的值的类型。

```
    var a = 42;
    typeof a; // "number"

    a = true;
    typeof a; // "boolean"
```

typeof操作符总是返回一个字符串：

```
    typeof typeof 42; // "string"
```

typeof 42首先返回"number"，然后typeof "number"返回"string"。

###undefined和undeclared

变量在没有持有任何值时其值为undefined。此时typeof返回"undefined"：

```
    var a;

    typeof a; // "undefined"

    var b = 42;
    var c;

    // later 
    b = c;

    typeof b; // "undefined"
    typeof c; // "undefined"
```

很多开发人员容易将“undefined”当作“undeclared”的同义词。然而在JavaScript中，它们之间有很大区别。

值为“undefined”的变量是那些已经在访问空间中声明过，但是当前并没有持有任何值的变量。相反，值为“undeclared”的变量是那些还没有在访问空间中声明过的变量。

例如：

```
    var a;

    a; // undefined
    b; // ReferenceError: b is not defined
```

浏览器在处理这类情况的时候显示的错误信息很容易误导人。如你所见，“b is not defined”这样的信息比较容易让人理解为“b is undefined”。再次说明，“undefined”和“is not defined”非常不同。如果浏览器显示诸如“b is not found”或者“b is not declared”这样的错误信息，就能避免不必要的误解。

typeof在处理undeclared变量时有一个特殊的行为更加深了我们的困惑。例如：

```
    var a;

    typeof a; // "undefined"

    typeof b; // "undefined"
```

typeof对于“undeclared”（或者“not defined”）的变量也返回"undefined"。请注意在执行typeof b时没有产生任何错误，即使b是一个undeclared变量。这是typeof中的一个特殊的安全防范。

同上所述，如果typeof对undeclared变量返回“undeclared”而非合用“undefined”，情况会好很多。

###typeof Undeclared

不管怎么说，这样的安全防范对于在浏览器中运行的JavaScript来说是很有帮助的，因为多个script文件可以将变量加载到共享的全局命名空间中。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px; "><img src='images/note.png'></td>
        <td style="border: none;">很多开发人员觉得全局命名空间中不应该有任何变量，所有的东西应该被封装到模块和私有命名空间中。理论上说这样不错，虽然在实际操作中基本不可能实现，但仍不失为一个值得努力的目标。幸运的是在ES6中加入了对模块的优先支持，最终将会让其更具可操作性。
        </td>
    </tr>
</table>

我们举个简单的例子，在你的程序中通过一个全局变量DEBUG来作为“调试模式”的开关。在执行诸如将信息写入控制台这样的调试任务前，你会检查DEBUG变量是否已经被声明过。这时最顶层的全局变量声明var DEBUG = true只包含在“debug.js”文件中，该文件只有在开发和测试时才在浏览器中加载，在生产环境中则不加载。

然而，你需要在程序的其他地方特别注意检查DEBUG变量的方式，以免出现ReferenceError错误。这时安全防范就很有用：

```
    // oops, this would throw an error!
    if (DEBUG) {
        console.log( "Debugging is starting" );
    }
    // this is a safe existence check
    if (typeof DEBUG !== "undefined") {
        console.log( "Debugging is starting" );
    }

```

即使对非用户定义的变量来说，这样的检查也是很有用的。如果你在为一个内置的API做特性检查，这也可以帮助你避免出现错误：

```
    if (typeof atob === "undefined") {
        atob = function() { /*..*/ };
    }
```


<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">如果你在为某个之前没有的特性定义一个“polyfill”，你可能会避免使用var来声明atob。如果你在if语句中使用var atob声明变量，该声明会被提升（参见本系列的Scope &amp; Closures一书）到范围中的最顶层，即使if条件未通过（因为atob全局变量已经存在）。在一些浏览器中和对于一些特殊的内置全局变量（通常被称为host objects），这样的重复声明会产生错误。而去掉var可以防止声明被提升。
        </td>
    </tr>
</table>

另一种对全局变量做检查但是不使用typeof安全防范的方法，是检查所有全局变量是否也是全局对象的属性，在浏览器中全局变量是window。所以上述检查可以写成这样：

```
    if (window.DEBUG) {
        // ..
    }
    
    if (!window.atob) {
        // ..
    }
```

和访问undeclared变量不同，当试图访问的对象属性不存在时，并不会产生ReferenceError错误。

另一方面，许多程序员避免通过window来访问全局变量，特别是当你的代码在多个JS环境下运行（不仅仅在浏览器，还在服务器端node.js，诸如此类），此时全局变量并不一定是window。

从技术角度而言，即便不是全局变量，使用typeof来做安全防范仍然是有用的，虽然这种情况不太常见，所以一些开发人员不太倾向使用这种方式。设想如果你想让别人拷贝粘贴一个工具函数到他们的程序中，你需要在函数中检查一些变量是否已经在它拷贝到的程序中被使用：

```
    function doSomethingCool() {
        var helper =
            (typeof FeatureXYZ !== "undefined") ?
            FeatureXYZ :
            function() { /*.. default feature ..*/ };
        var val = helper();
        // .. 
    }
```

doSomethingCool()检查变量FeatureXYZ，如果已存在就使用它，否则使用自己定义的版本。如果有人将这段代码引入到他们自己的模块和程序中，它会安全地检查FeatureXYZ是否已经被定义过：

```
    // an IIFE (see the "Immediately Invoked Function Expressions"
    // discussion in the Scope & Closures title in this series)
    (function(){
        function FeatureXYZ() { /*.. my XYZ feature ..*/ }

        // include `doSomethingCool(..)`
        function doSomethingCool() {
            var helper =
                (typeof FeatureXYZ !== "undefined") ?
                FeatureXYZ :
                function() { /*.. default feature ..*/ };
            var val = helper();
    // .. }
        doSomethingCool();
    })();
```

在这里FeatureXYZ不是一个全局变量，但是我们还是使用typeof安全防范。重要的是我们没有使用对象（如前面提到的windows.___）来做检查，因而typeof非常有用。

有些程序员可能倾向使用“依赖注入”（dependency injection）的方式，不是使用doSomethingCool()来检查FeatureXYZ是否已经在别处定义过，而是需要将依赖关系通过参数显示地传递进来，如：

```
    function doSomethingCool(FeatureXYZ) {
        var helper = FeatureXYZ ||
            function() { /*.. default feature ..*/ };
        var val = helper();
        // ..
    }
```

实现类似功能的方式有很多。它们之间没有“错”与“对”之分，每种方法都各有利弊。总而言之，使用typeof来检查undeclared变量为我们提供了更多的选择。

###回顾

JavaScript有7种内置类型：null，undefined，boolean，number，string，object，和symbol。可以使用typeof操作符来查看。

变量没有类型，但是它们持有的值有类型。类型定义了值的内在行为特征。

很多开发人员认为“undefined“和“undeclared”基本上是一样的，但是在JavaScript中，它们区别很大。`undefined`是变量可以持有的值的一种。“Undeclared”表示变量还没有被声明过。

不幸的是JavaScript将二者合并起来使用，不仅在相关的错误信息中如此（“ReferenceError:a is not defined”），typeof的返回值"undefined"也涵盖了这两种情况。

然而，使用typeof做安全防范对于检查undeclared的变量来说是非常有用的。

------

##第二章 值

数组，字符串，和数值是计算机程序最基本的组成部分，然而JavaScript中这些类型的一些独特的特性即能让人高兴，又能让人困惑。

###数组

相比其他的强制类型语言，JavaScript中的数组可以容纳任何类型的值，可以是字符串，数值，对象，甚至其他数组（多维数组就是以此方式来实现）：

```
    var a = [ 1, "2", [3] ];
    a.length;       // 3
    a[0] === 1;     // true
    a[2][0] === 3;  // true
```

你不需要预先设定数组的大小（参考`第44页的Array(...)`），你只需要对其进行声明，然后既可向其中加入值：

```
    var a = [ ];
    a.length;   // 0
    a[0] = 1;
    a[1] = "2";
    a[2] = [ 3 ];
    a.length;   // 3
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">对数组中的值执行delete操作能够将其从数组中移除，需要注意的是，即使值被移除后，数组的length属性并不会相应更改。我们将在第五章中详细介绍delete操作。
        </td>
    </tr>
</table>

创建“稀疏的”数组候需要特别注意（数组中有一些空白或者遗失的单元）：

```
    var a = [ ];
    a[0] = 1;
    // no `a[1]` slot set here
    a[2] = [ 3 ];
    a[1];       // undefined
    a.length;   // 3
```

虽然上面的代码没有问题，但是其中的“空白单元”会产生令人困惑的结果。即使单元[1]的值为`undefined`，但是它和我们明确设定该单元（a[1]=undefined）产生的结果还是有区别。详情参见`第44页的“Array(...)”`。

在你意料之中，数组使用数字索引，有趣的是数组也可以是字符串键值和属性组成的对象（它们并不计算在`length`内）：

```
    var a = [ ];
    a[0] = 1;
    a["foobar"] = 2;
    a.length;       // 1
    a["foobar"];    // 2
    a.foobar;       // 2
```

然而，我们需要注意的一个不容易察觉的地方是，如果你使用一个可以被强制转换为10进制数字的字符串作为键值，则默认为你是想使用其作为数字索引而非字符串键值！

```
    var a = [ ];
    a["13"] = 42;
    a.length; // 14
```

通常在数组中加入字符串键值/属性的方式并不是很好。推荐使用对象来存放键值/属性形式的值，使用数组来存放数字索引的值。

###类数组

有时候你需要将类似数组的值（一组使用数字索引的值）转换为真正的数组，通常你可以对其调用数组工具函数来实现（如：indexOf(..)，concat(..)，forEach(..)，等等）。

例如，一些DOM查询操作返回DOM元素列表，它们不是真正的数组，但是却很类似数组。另一个例子是一些函数使用自变量（类数组）对象将参数作为列表来访问（到ES6已经不支持了）。

使用slice(..)函数是实现此种转换的一个很普遍的方式：

```
    function foo() {
        var arr = Array.prototype.slice.call( arguments );
        arr.push( "bam" );
        console.log( arr );
    }

    foo( "bar", "baz" ); // ["bar","baz","bam"]
```

如上例所示，如果slice()不带其他参数，其参数的默认值为数组（本例中则是类数组）的值的复本(JJ-??)。

到ES6为止，其中有一个内置工具函数Array.from(..)也有相同的功能：

```
    ...
    var arr = Array.from( arguments );
    ...
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">Array.from(..)有几个强大的功能，我们将在本系列的《ES6及更多》一书中详细介绍。
</td>
    </tr>
</table>

###字符串

字符串通常被认为是由字符组成的数组。然而其内部实现也可能没有使用数组，重要的是认识到JavaScript中的字符串和字符数组不同。相同之处仅仅是皮毛而已。

例如下面两个值：

```
    var a = "foo";
    var b = ["f","o","o"];
```

如上所示，字符串确实和数组有相似之处，是类数组。比如，它们都有`length`属性，`indexOf(..)`方法（该方法对于数组只支持到ES5），和`concat(..)`方法：

```
    [source,js]

    a.length;                           // 3
    b.length;                           // 3

    a.indexOf( "o" );                   // 1
    b.indexOf( "o" );                   // 1

    var c = a.concat( "bar" );          // "foobar"
    var d = b.concat( ["b","a","r"] );  // ["f","o","o","b","a","r"]

    a === c;                            // false
    b === d;                            // false

    a;                                  // "foo" 
    b;                                  // ["f","o","o"]
```

那么是否可以说它们就是由字符组成的数组？答案是否定的：

```
    a[1] = "O";
    b[1] = "O";

    a; // "foo"
    b; // ["f","O","o"]
```

JavaScript中的`字符串`是不可变的，而`数组`是可变的。并且，a[1]这样的数据访问方式在JavaScript中并非总是合法的。旧版本的IE不允许这样做（现在允许了）。实际上*正确*的访问方式应该是`a.charAt(1)`。

`字符串`不可变意味着其中涉及到变更其内容的方法，都不会变更原始的内容，而是创建并返回一个新的`字符串`。相反，数组方法都是在其原始值上进行操作。

```
    c = a.toUpperCase();
    a === c;    // false
    a;          // "foo"
    c;          // "FOO"

    b.push( "!" );
    b;          // ["f","O","o","!"]
```

此外，很多`数组`中很有用的方法在`字符串`中并不支持，但是我们为`字符串`“借用”`数组`中那些非变更方法：

```
    a.join;         // undefined
    a.map;          // undefined

    var c = Array.prototype.join.call( a, "-" );
    var d = Array.prototype.map.call( a, function(v){
        return v.toUpperCase() + ".";
    } ).join( "" );
    
    c;              // "f-o-o"
    d;              // "F.O.O."
```

我们再来看看另外一个例子，反转`字符串`（一个经常在JavaScript面试中遇到的问题！）。`数组`中有一个叫做`reverse()`的变更方法，而`字符串`没有：

```
    a.reverse;      // undefined

    b.reverse();    // ["!","o","O","f"]
    b;              // ["f","O","o","!"]
```

遗憾的是，这种“借用”对于`数组`的变更方法而言无效，因为`字符串`是不可变的，其内容无法更改：

```
    Array.prototype.reverse.call( a );
    // still returns a String object wrapper (see Chapter 3)
    // for "foo" :(
```

一个变通（破解）的方法是将`字符串`转换为`数组`，执行需要的操作，然后在转换回`字符串`：

```
    var c = a
        // split `a` into an array of characters
        .split( "" )
        // reverse the array of characters
        .reverse()
        // join the array of characters back to a string
        .join( "" );
    
    c; // "oof"
```

该方法感觉太繁琐，实际也的确如此。至少它对于简单`字符串`还是可行的，往往这样简单粗暴的方法能够很快奏效。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">需要注意！上面的方法对于包含复杂字符（unicode）的字符串（星号，多子节字符等等）来说并不适用。对于这种情况你需要功能更加完备、能够处理unicode的工具库。可以参考Mathias Bynen开发的<a href='https://github.com/mathiasbynens/esrever'>Esrever</a>。</td>
    </tr>
</table>

另外一种思路是，如果你经常需要以`字符数组`的方式来处理字符串，那么不如直接用`数组`，而不是`字符串`。这样就不用花很多时间在`字符串`和`数组`之间进行转换了。你可以在需要时对`字符数组`执行`join("")`将其转换为`字符串`。

###数值

JavaScript只有一种数字类型，即：`数值`类型。它包括“整数”和带小数的十进制数。“整数“加引号的原因是，和其他语言不同，JavaScript中没有真正意义上的整数，这也是其一直被诟病的一个地方。这种情况在将来也许会有所改观，不过目前所有数字均为`数值`类型。

JavaScript中的整数只是没有小数的十进制数。所以42.0即等同于“整数”42。

和大多数现代编程语言一样，包括所有的脚本语言，JavaScript的`数值`类型的实现是基于“IEEE 754”标准，通常称为“浮点”。JavaScript具体使用的是“双精度”（又称“64位二进制”）标准。

网络上有很多优秀的文章详细介绍了二进制浮点数在内存中的存储方式，以及各种实现之间的不同。掌握JS中数值类型的正确使用方法，并不一定要求我们理解内存中的数位如何存储，所以本书不多做介绍，有兴趣的读者可以参考IEEE 754的细节。

###数值语法

JavaScript中的数值常量一般为十进制。例如：

```
    var a = 42;
    var b = 42.3;
```

数值前半部分为0的话可以省略：

```
    var a = 0.42;
    var b = .42;
```

同样地，数值后半部分（小数）为0的话也可以省略：

```
    var a = 42.0;
    var b = 42.;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">虽然42.这样的形式不太常见，但的确是允许的，考虑到代码可读性，通常不建议使用。</td>
    </tr>
</table>

缺省情况下，所有的`数值`都显示为十进制，小数部分最后面的0省略。如：

```
    var a = 42.300;
    var b = 42.0;

    a; // 42.3
    b; // 42
```

特别大和特别小的`数值`会默认用指数格式显示，效果和toExponential()函数一样，如：

```
    var a = 5E10;
    a;                  // 50000000000
    a.toExponential();  // "5e+10"

    var b = a * a;
    b;                  // 2.5e+21
    
    var c = 1 / a;
    c;                  // 2e-11
```

由于`数值`类型的值可以使用`Number`对象来封装（见`第三章`），因此`数值`类型的值可以使用`Number.prototype`中的方法（见`第三章`）。例如，`toFixed(..)`方法让你能够指定小数部分显示的位数：

```
    var a = 42.59;

    a.toFixed( 0 ); // "43"
    a.toFixed( 1 ); // "42.6"
    a.toFixed( 2 ); // "42.59"
    a.toFixed( 3 ); // "42.590"
    a.toFixed( 4 ); // "42.5900"
```

请注意输出结果实际上是该`数值`的`字符串`，如果小数部分显示位数多于实际值的位数，则使用0补齐。

类似地，`toPrecision(..)`方法指定`有效数字`显示的位数：

```
    var a = 42.59;

    a.toPrecision( 1 ); // "4e+1"
    a.toPrecision( 2 ); // "43"
    a.toPrecision( 3 ); // "42.6"
    a.toPrecision( 4 ); // "42.59"
    a.toPrecision( 5 ); // "42.590"
    a.toPrecision( 6 ); // "42.5900"
```

这些方法并不需要你使用变量来访问，`数值`常量也可以直接调用它们。不过在使用`.`操作符时需要注意。因为`.`是一个合法的数字字符，只要有可能，它首先会被识别为`数值`常量的一部分，而非对象属性访问操作符。

```
    // invalid syntax:
    42.toFixed( 3 );    // SyntaxError

    // these are all valid:
    (42).toFixed( 3 );  // "42.000"
    0.42.toFixed( 3 );  // "0.420"
    42..toFixed( 3 );   // "42.000"
```

`42.toFixed(3)`是非法语法，因为`.`被视为常量`42.`的一部分（如上所述），因此本例中并不存在`.`属性访问操作符来调用`.toFixed`。

`42..toFixed(3)`没有问题，因为第一个`.`被视为`数值`的一部分，第二个`.`才是属性访问操作符。不过这看起来有点奇怪，在实际的JavaScript代码中也很少见。事实上通过基本类型调用方法并不常见，不过不常见并不代表`不好`和`不对`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">有一些代码库扩展了Number.prototype的内置方法（见第三章），提供了更多操纵数值的功能，比如使用10..makeItRain()实现下十分钟金钱雨的动画，等等。</td>
    </tr>
</table>

以下语法也是合法的（注意空格）：

```
    42 .toFixed(3); // "42.000"
```

然而，对于`数值`常量而言，这样的语法很容易造成误导，不建议使用。

`数值`还可以使用指数格式，常用于较大的数字，如：

```
    var onethousand = 1E3;                      // means 1 * 10^3
    var onemilliononehundredthousand = 1.1E6;   // means 1.1 * 10^6
```

`数值`常量还可以用其他方式来表示，如：二进制，八进制，和十六进制。

当前版本的JavaScript都支持这些格式：

```
    0xf3; // hexadecimal for: 243
    0Xf3; // ditto

    0363; // octal for: 243
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从ES6的严格模式开始，不再支持0363八进制格式（新格式见下）。0363格式在非严格模式中仍然支持，但是考虑到将来的兼容性最好不要再使用（目前你使用的应该是严格模式）。</td>
    </tr>
</table>

ES6支持以下新格式：

```
    0o363;      // octal for: 243
    0O363;      // ditto

    0b11110011; // binary for: 243
    0B11110011; // ditto
```

考虑到代码的易读性，不推荐使用0O363格式。0和大写O在一起会导致误读。建议尽量使用小写字母0x，0b，和0o。

###小数值

使用二进制浮点数最大的副作用（不仅仅是JavaScript，对于所有使用IEEE 754规范的语言都是如此），是这样的情况：

```
    0.1 + 0.2 === 0.3; // false
```

从数学角度，我们觉得上面的表达式应该为`true`，但是为什么是`false`呢？

简单来说，二进制浮点数中的`0.1`和`0.2`并不是完全精确，它们相加的结果并非精确等于`0.3`，而是非常接近的一个数字，`0.30000000000000004`，所以在判断相等时结果为`false`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">JavaScript是否应该使用能够精确反映数字的数值实现方式？有些人这样认为。长期以来也出现了很多替代方案，只是它们都没有被认可，将来也许也不会。虽然这件事看起来象你举手示意“Bug解决了！”一样简单，事实却并非如此，否则问题早就已经解决了。</td>
    </tr>
</table>

现在的问题是，如果一些`数值`无法做到完全精确，那我们是不是就无法使用`数值`了呢？答案当然是否定的。

有一些应用程序在处理数字，特别是有小数的数字时需要特别精确。还有很大一部分（也许是大多数）应用程序仅仅需要处理整数，最大不超过百万或者万亿。JavaScript的数字操作对于这些应用程序来说一直是绝对有保障的。

如果我们确实需要比较两个`数值`，比如：`0.1 + 0.2`和`0.3`，并且我们已经知道相等测试结果为'false'，这时应该怎么办？

通常采用的方法是设置一个误差范围值。通常称为“机器小量（machine epsilon）”，对于JavaScript中的`数值`来说一般是`2^-52 (2.220446049250313e-16)`。

截至到ES6，这个误差范围值定义在`Number.EPSILON`中，你可以直接使用，或者也可以使用polyfill（JavaScript中的一种“衬垫”技术）来为ES6之前的版本定义改值：

```
    if (!Number.EPSILON) {
        Number.EPSILON = Math.pow(2,-52);
    }
```

现在我们可以使用`Number.EPSILON`来比较两个数字是否相等了（在指定的误差范围内）：

```
    function numbersCloseEnoughToEqual(n1,n2) {
        return Math.abs( n1 - n2 ) < Number.EPSILON;
    }

    var a = 0.1 + 0.2;
    var b = 0.3;

    numbersCloseEnoughToEqual( a, b );                  // true
    numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );  // false
```

能够被呈现的最大浮点值为`1.798e+308`（相当大的数字），定义在`Number.MAX_VALUE`中。此外，最小浮点值定义在`Number.MIN_VALUE`中，大约是`5e-324`，它不是负数，无限接近于`0`！

###整数的安全范围

由于`数值`的呈现方式，“整数”有一个远远小于`Number.MAX_VALUE`的安全值范围。

能被“安全”呈现的最大整数值（即该值能够保证被清晰地呈现）为`2^53 - 1`，即`9007199254740991`，在ES6中定义为`Num ber.MIN_SAFE_INTEGER`。

JS程序处理大数值的一个常见场景是处理来自数据库中的64位ID等等。`数值`类型无法精确处理64位数，所以它们在JavaScript中必须被保存（转换）为`字符串`。

幸运的是，对于这类大数值的操作（除了比较操作`字符串`能够处理）并不常见。不过如果你确实需要对这类大数值进行数学运算，目前你还是需要使用大数值相关工具。在将来的JavaScript版本中也许会加入对大数值的支持。

###整数检测

如果要检测一个值是否是整数，你可以使用ES6特定的`Number.isInteger(..)`方法：

```
    Number.isInteger( 42 );     // true
    Number.isInteger( 42.000 ); // true
    Number.isInteger( 42.3 );   // false
```

我们可以为ES6之前的版本polyfill`Number.isInteger(..)`方法：

```
    if (!Number.isInteger) {
        Number.isInteger = function(num) {
            return typeof num == "number" && num % 1 == 0;
        };
    }
```

要检测一个数值是否是`安全的整数`，可以使用ES6特定的`Number.isSafeInteger(..)`方法：

```
    Number.isSafeInteger( Number.MAX_SAFE_INTEGER );    // true
    Number.isSafeInteger( Math.pow( 2, 53 ) );          // false
    Number.isSafeInteger( Math.pow( 2, 53 ) - 1 );      // true
```

我们可以为ES6之前的版本polyfill`Number.isSafeInteger(..)`方法：

```
    if (!Number.isSafeInteger) {
        Number.isSafeInteger = function(num) {
            return Number.isInteger( num ) &&
                Math.abs( num ) <= Number.MAX_SAFE_INTEGER;
        }; 
    }
```

###32位有符号整数

虽然整数最大能够达到53位，一些数字操作（如：数位操作）只适用于32位的数字，因此这些操作中的数值的安全范围就要小得多。

这种情况下的安全范围是从`Math.pow(-2,31)`（-2147483648，约-21亿）到`Math.pow(2,31)`（2147483647，约21亿）。

要将变量`a`中的数值转换为32位有符号整数，可以使用`a | 0`。这个方法很有效，因为`|`数位操作符只针对32位整数（即它只关心32位以内的值，忽略其他的数位）。因此与0的`或`操作即为一个空的数位操作。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">有一些特殊的值（我们将在下节介绍），如：NaN和Infinity，并不是32位安全的。32位安全是指传递给数位操作符的值会执行一个虚拟操作ToInt32（见第四章），以便成为数位操作符要求的+0值。（JJ-??）</td>
    </tr>
</table>

###特数值

JavaScript的各种类型中有几个特数的值，它们提请JS程序员特别注意，并且小心使用。

####不是值的值

类型`undefined`只有一个值，即：`undefined`。类型`null`也只有一个值，即：`null`。对于这两个类型来说，它们的名称既是类型也是值。

`undefined`和`null`经常被用来表示“empty”值或“non”值。有人也倾向于区分出它们之间的细微差别。例如：

- `null`指空值。
- `undefined`指没有值。

或者：

- `undefined`指从未赋过值。
- `null`指曾被赋过值，但是目前没有值。

无论你如何定义和使用这两个值，`null`是一个特殊关键字，而非标识符，因此你不能将其当作变量来赋值。然而不幸的是，`undefined`却是一个标识符。

####Undefined

在非严格模式下，可以（虽然强烈不推荐）为全局标识符`undefined`赋值：

```
    function foo() {
        undefined = 2; // really bad idea!
    }
    
    foo();
    
    function foo() {
        "use strict";
        undefined = 2; // TypeError!
    }

    foo();
```

在非严格和严格模式下，你可以声明一个名为`undefined`的局部变量。不过再次强调，这样做很不好。

```
   function foo() {
        "use strict";
        var undefined = 2;
        console.log( undefined ); // 2
    }

    foo();
```

不要重载undefined，永远不要。

####void操作符

虽然`undefined`是一个内置的标识符（除非被修改，见前面的介绍），其值为`undefined`，另外还有一个方法可以得到该值，即void操作符。

`void ___`表达式不返回任何值，因此其返回结果永远是`undefined`。它并不更改现有的值，只是确保表达式不返回任何值：

```
    var a = 42;
    console.log( void a, a ); // undefined 42
```

按照惯例（大部分源自C语言），你可以使用`void 0`（`void true`或者其他`void`表达式也都返回相同的结果）。`void 0`，`void 1`，和`undefined`之间并没有区别。

但是`void`操作符在某些情况下非常有用，比如你想确保一个表达式不返回任何结果（即使它有副作用）。

例如：

```
    function doSomething() {
        // note: `APP.ready` is provided by our application
        if (!APP.ready) {
            // try again later
            return void setTimeout( doSomething,100 );
        }
    
        var result;
        
        // do some other stuff
        return result;
    }

    // were we able to do it right away?
    if (doSomething()) {
        // handle next tasks right away
    }
```

上例中，`setTimeout(..)`函数返回一个数值（时间间隔的唯一标识，如果你想要取消的话），但是为了让该函数的`if`声明不误报（false positive），我们就要`void`掉它。

有些程序员喜欢将它们分开实现，不使用`void`但是效果是一样的：

```
    if (!APP.ready) {
        // try again later
        setTimeout( doSomething,100 );
        return;
    }
```

通常，如果代码中某处需要一个值（来自某个表达式），你会觉得使用`undefined`比`void`更好些。这种情况可能并不十分常见，不过在需要的时候还是很好用。

####特殊数值

`数值`类型包括几个特殊的值，这里将详细介绍。

#####不是数值的数值

如果数学运算中的操作符不是`数值`（或者可以被解析为常规的10进制或16进制`数值`）的话，运算结果将无法返回有效的`数值`，这时返回值为`NaN`。

`NaN`意指“不是数值（not a number）”，虽然这个名字不太好，容易误导人，后面我们会讲到。把其视作“无效数值”，“失效数值”，甚至“坏数值”可能更贴切一些。

例如：

```
    var a = 2 / "foo";      // NaN

    typeof a === "number";  // true
```

换句话说，不是数值的数值的类型是`数值`。名字和意思一样绕。

`NaN`是一个“标记符号”(是一个具有特殊意思得非正常值)，用来表示数值中的某种错误情况。这个错误情况就是“我试图执行一个数学运算但是没有成功，这是相应的失败结果”。

如果你要测试变量中的数值是否是`NaN`，你也许会认为可以直接比较值和`NaN`，和其他值，如：`null`和`undefined`，一样。答案是否定的。

```
    var a = 2 / "foo";
   
    a == NaN;   // false
    a === NaN;  // false
```

`NaN`这个值很特殊，它永远不会和其他NaN值相等（即永远不等于它自己）。它是唯一一个非自反（reflexive，即无`x === x`特征）的值。因而`NaN != NaN`，有点奇怪不是吗？

如果我们无法比较`NaN`（其永远返回false），那么我们怎么测试它呢？

```
    var a = 2 / "foo";
   
    isNaN( a ); // true
```

很简单是不是？我们使用内建的全局工具函数`isNaN(..)`来告诉我们一个值是否是`NaN`。搞定！

没有这么简单。

`isNaN(..)`有一个严重的缺陷。它对`NaN`（“Not a Number”）按照字面来解读，即“测试传递进来的参数，如果它不是`NaN`既是`数值`”。但是这样并不十分精确：

```
    var a = 2 / "foo";
    var b = "foo";
    
    a; // NaN
    b; "foo"
    
    window.isNaN( a ); // true
    window.isNaN( b ); // true--ouch!
```

很明显"foo"不是一个`数值`，但是它也不是`NaN`。这个bug自JS问世以来一直存在（超过19年）。

从ES6开始，有一个替代工具函数`Number.isNaN(..)`。它是一个简单的polyfill，你可以在ES6之前的浏览器中安全地测试NaN值。

```
    if (!Number.isNaN) {
        Number.isNaN = function(n) {
            return (
                typeof n === "number" &&
                window.isNaN( n )
            ); 
        };
    }
    
    var a = 2 / "foo";
    var b = "foo";
    
    Number.isNaN( a ); // true
    Number.isNaN( b ); // false--phew!
```

实际上我们可以用更简单的方式实现`Number.isNaN(..)`polyfill，利用NaN不等于自己这个奇怪的特性。NaN是JavaScript中`唯一`一个不等于自己的值，其他的值都等于自己。

因此：

```
    if (!Number.isNaN) {
        Number.isNaN = function(n) {
            return n !== n;
        };
    }
```

虽然很奇怪，但是很有效。

`NaN`反映了很多JS程序的一个现实，无论是有意或是巧合。就是尽量使用可靠的测试方法，无论是系统自带或者polyfill，如：`Number.isNaN(..)`。

如果你的代码中正在使用`isNaN(..)`，你的代码不幸地包含bug，即使其还未显露。

#####无穷数

熟悉编译后运行语言的程序员可能遇到过诸如“除以0”这样的编译错误或者运行时错误，例如以下代码：

```
    var a = 1 / 0;
```

然而在JS中，以上代码的运行结果为`Infinity`（即Number.POSITIVE_INFINITY）。例如以下代码：

```
    var a = 1 / 0;  // Infinity
    var b = -1 / 0; // -Infinity
```

如果除法运算中的某个数为负数，则结果为`-Infinity`（即Number.NEGATIVE_INFINITY）。

JS使用有限数值规范（之前讨论过的IEEE 754 浮点数），所以和数学相反，它的数学运算有溢出的可能，此时运算结果为`Infinity`或者`-Infinity`。

例如：

```
    var a = Number.MAX_VALUE;   // 1.7976931348623157e+308
    a + a;                      // Infinity
    a + Math.pow( 2, 970 );     // Infinity
    a + Math.pow( 2, 969 );     // 1.7976931348623157e+308
```

根据规范，如果加法运算的结果超出了处理范围，IEEE 754规范的“就近取整”模式定义了应该返回的计算结果。例如：相对于`Infinity`来说，`Number.MAX_VALUE + Math.pow(2, 969)`与`Number.MA_VALUE`更为接近，因此它被“向下取整”，然而`Number.MAX_VALUE + Math.pow(2, 970）`与`Infinity`更为接近，所以它被“向上取整”。

关于这个问题想多了容易头疼，所以我们就此打住。

一旦你的计算结果溢出到两个无穷数中的一个，你将无法返回。说得有诗意一点，就是你可以从有穷走向无穷，但是无法从无穷回到有穷。

如果你有哲学思想，可能会问“那么如果无穷除以无穷会是什么结果呢？”。我们简单的大脑可能会回答“1“或者”无穷“。这两个答案都不正确。因为对于数学和JavaScript语言来说，`Infinity / Infinity`不是一个定义操作。JS中它的运算结果是`NaN`。

那么有穷数正数除以`Infinity`呢？很简单，结果是0。有穷负数除以`Infinity`呢？后面介绍。

#####零

这部分内容可能会对有数学头脑的读者带来困惑，JavaScript中有一个正常的0（也叫做`+0`）和一个负0（`-0`）。在解释为什么会有`-0`之前，我们来看看JS对其是如何处理的，因为这个概念容易让人困惑。

除了使用常量`-0`，一些数学运算也返回负零。例如：

```
    var a = 0 / -3; // -0
    var b = 0 * -3; // -0
```

加法和减法运算不会得到负零的结果。

在开发工具的调试控制台中，负零通常被显示为`-0`，不过这之前一些老的浏览器将其显示为`0`。

如果你将负零转换为字符串，根据规范中的定义，结果会是“`0`”：

```
    var a = 0 / -3;
    
    // (some browser) consoles at least get it right
    a;                          // -0
    
    // but the spec insists on lying to you!
    a.toString();               // "0"
    a + "";                     // "0"
    String( a );                // "0"

    // strangely, even JSON gets in on the deception
    JSON.stringify( a );   // "0"
```

有趣的是，如果你反过来将其从字符串转换为数值，会发现结果是正确的：

```
    +"-0";              // -0
    Number( "-0" );     // -0
    JSON.parse( "-0" ); // -0
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">JSON.stringify(-0)的返回结果为“0”，JSON.parse("-0")返回-0，和我们预想的不一致。</td>
    </tr>
</table>

负零转换为字符串的结果让人迷惑，其比较操作符也是这样：

```
    var a = 0;
    var b = 0 / -3;

    a == b;     // true
    -0 == 0;    // true

    a === b;    // true
    -0 === 0;   // true
    
    0 > -0;     // false 
    a > b;      // false
```

如果你想在代码中区分`-0`和`0`，而非依赖于开发调试窗口的输出结果，就需要处理得更聪明一些：

```
    function isNegZero(n) {
        n = Number( n );
        return (n === 0) && (1 / n === -Infinity);
    }

    isNegZero( -0 );        // true
    isNegZero( 0 / -3 );    // true
    isNegZero( 0 );         // false
```

除了学术方面的原因之外，为什么我们需要负零？

在一些应用程序中有一些信息需要使用值的级数来表示（如动画帧的移动速度），另外一些信息需要使用`数值`的符号来表示（如移动的方向）。

在这种情况下，如果一个包含0值的变量丢失了它的符号，其代表的方向信息也就会丢失。所以保留0值的符号可以防止此类信息的丢失。

#####特殊等式

如上所述，`NaN`和`-0`在进行相等比较时的表现得很特别。`NaN`和自身不相等，因此你必须使用ES6种的`Number.isNaN(..)`（或者polyfill）。同样令人费解地，`-0`和`0`相等（==甚至===都如此，见`第四章`），因此你必须使用某些工具函数来处理相等比较。

从ES6开始提供了一个新的工具方法来判断两个值是否严格相等，其考虑了所有的特殊情况。这个方法是`Object.is(..)`：

```
    var a = 2 / "foo";
    var b = -3 * 0;

    Object.is( a, NaN );    // true
    Object.is( b, -0 );     // true

    Object.is( b, 0 );      // false
```

对于ES6之前的版本，`Object.is(..)`有一个简单的polyfill：

```
    if (!Object.is) {
        Object.is = function(v1, v2) {
            // test for `-0`
            if (v1 === 0 && v2 === 0) {
                return 1 / v1 === 1 / v2;
            }
            // test for `NaN`
            if (v1 !== v1) {
                return v2 !== v2;
            }
            // everything else
            return v1 === v2;
        };
    }
```

在可以安全（见`第四章`）使用`==`和`===`的情况下，可能不该使用`Object.is(..)`，因为这两个操作符效率更高，也更地道和通用。`Object.is(..)`主要是针对特殊情况。

###值和引用

在很多其他语言中，赋值和传递参数值可以通过值拷贝来完成，也可以通过拷贝引用来完成，取决于你使用哪种语法。

例如，在C++中，如果你需要向一个函数传递一个`数值`变量，在函数中变量值要被更改，你可以将参数声明为`int& myNum`这样的形式，当你向其传递变量`x`时，`myNum`即为指向`x`的一个引用。引用是指针的一种特别形式，其中你得到一个指向变量的指针（类似`别名`）。如果你不将参数声明为引用，参数值将总是通过值拷贝的方式传递，即使值是复杂的对象也如此。

在JavaScript中没有指针，引用的工作原理也不太一样。JS中你不可能将一个引用从一个变量指向另一个变量，那不可能。

JS中的引用指向的是值（共享值），如果你有10个不同的引用，它们就是10个指向同一个共享值的不同的引用，它们之间没有任何引用／指向关系。

而且JavaScript的语法不区分通过值和引用复制／传递。而是仅由值的类型决定该值是否该通过值或引用传递。

让我们看一个例子：

```
    var a = 2;
    var b = a; // `b` is always a copy of the value in `a`
    b++;
    a; // 2
    b; // 3

    var c = [1,2,3];
    var d = c; // `d` is a reference to the shared `[1,2,3]` value
    d.push( 4 );
    c; // [1,2,3,4]
    d; // [1,2,3,4]
```

简单值（即标量基本值，scalar primitives）(JJ-??)总是通过值拷贝的方式赋值／传递，包括：`null`，`undefined`，`string`，`number`，`boolean`，和ES6的`symbol`。

复合值－`object（对象）`（包括数组，和所有的封装对象，见`第三章`）和`function（方法）`，总是通过引用拷贝来赋值／传递。

在前面的示例代码中，由于`2`是一个标量基本值，变量`a`包含该值的一个拷贝，`b`被赋值为该值的另一个拷贝。`b`中的值更改时，`a`中的值不变。

但是`c`和`d`却是两个不同的引用，指向同一个复合值`[1,2,3]`。值得一提的是，`c`和`d`都不拥有值`[1,2,3]`，仅仅同时指向该值。所以使用它们之间的任何一个来更改值（如`.push(4)`），两个引用都将指向更改后的值`[1,2,3,4]`。

由于引用指向的是值本身，而非变量，一个引用无法更改另一个引用指向的值。

```
    var a = [1,2,3];
    var b = a;
    a; // [1,2,3]
    b; // [1,2,3]
    
    // later
    b = [4,5,6];
    a; // [1,2,3]
    b; // [4,5,6]
```

当赋值时`b=[4,5,6]`，不影响`a`已经指向的值`[1,2,3]`。除非`b`不是指向该数组的引用，而是指向'a'的指针。但是这种情况在JS中不存在！

这些困扰经常体现在函数参数上：

```
    function foo(x) {
        x.push( 4 );
        x; // [1,2,3,4]
    
        // later
        x = [4,5,6];
        x.push( 7 );
        x; // [4,5,6,7]
    }

    var a = [1,2,3];
    
    foo( a );

     a; // [1,2,3,4]  not  [4,5,6,7]
```

当传递`a`到函数时，是将`a`引用的一个复本赋值给`x`，`a`仍然是一个单独的引用，指向值`[1,2,3]`。现在在函数内部，我们可以使用该引用来更改值（`push(4)`）。但是当我们为`x`赋值`x = [4,5,6]`时并不影响原来的值，`a`仍然指向原来的值，即更改后的`[1,2,3,4]`。

我们不可能使用引用`x`来更改`a`的指向，只能更改`a`和`x`共同指向的值的内容。

如果要将`a`指向的值更改为`[4,5,6,7]`，你必须更改`x`指向的数组的值，而非为`x`创建并赋值一个新数组。

```
    function foo(x) {
        x.push( 4 );
        x; // [1,2,3,4]

        // later
        x.length = 0; // empty existing array in-place
        x.push( 4, 5, 6, 7 );
        x; // [4,5,6,7]
    }
    
    var a = [1,2,3];

    foo( a );
    
    a; // [4,5,6,7] not [1,2,3,4]
```

如你所见，`x.length = 0`和`x.push(4,5,6,7)`没有创建一个新数组，而是对现有的数组进行更改。所以`a`指向的值变成了`[4,5,6,7]`。

请记住：你无法直接控制和重载值拷贝和引用，它们的语义由它们指向的值的类型来决定。

如果要有效率地通过值拷贝方式传递复合值（如数组），你需要为其创建一个拷贝，从而传递的引用不再指向原始值。例如：

```
    foo( a.slice() );
```

不带参数的`slice(..)`默认返回整个`数组`的一个浅（shallow）拷贝。由于传递到函数内的引用指向的是该数组的一个拷贝，因此函数`foo(..)`不会对`a`指向的值造成影响。

相反地，如果要将标量基本值传递到函数内且能够更改值，象引用那样，你需要将该值封装到另一个复合值（`对象`，`数组`等）中，通过引用拷贝传递。

```
    function foo(wrapper) {
        wrapper.a = 42;
    }

    var obj = { 
        a: 2
    };

    foo( obj );

    obj.a; // 42
```

这里`obj`是一个封装对象，其中包含了标量基本值`a`。引用`obj`的一个拷贝被赋值给参数`wrapper`并传递到`foo(..)`中。这样我们可以通过`wrapper`来访问共享对象并更改其属性。函数返回后，`obj.a`将得到一个新值`42`。

有时候你可能需要传递指向标量基本值（如`2`）的一个引用，你可以将该值封装到`Number`对象中（见`第三章`）。

虽然这里传递的是指向该`Number`对象的一个引用的拷贝，但并非象你设想的那样，指向共享对象的引用并不能让你更改其中的基本值：

```
    function foo(x) {
        x = x + 1;
        x; // 3 
    }
    
    var a = 2;
    var b = new Number( a ); // or equivalently `Object(a)`
    
    foo( b );
    console.log( b ); // 2, not 3
```

其中的原因是标量基本值是不可更改的（`String`和`Boolean`也是如此）。如果一个`Number`对象的值为`2`，你就不可能将其更改为其他值，除非创建一个不同值的新的`Number`对象。

当执行`x = x + 1;`时，`x`中的标量基本值`2`被从`Number`对象中提取出来，因此`x`悄悄地从引用变成了`Number`对象，它的值为`2 + 1`的结果`3`。然而，函数外部的`b`仍指向原来的值为`2`的`Number`对象。

你可以在`Number`对象上添加其他属性（这样可以不用更改其内部的基本值），通过这些属性来直接传递和交换信息。

不过这个方法不是很常见，程序员也不认为这是一个好的实践。

相比使用`Number`封装对象，在之前的示例代码中使用`obj`作为封装对象的方法可能更好些。这并不是说`Number`这样的封装对象没有什么用，只是对于大部分情况而言标量基本值应该是首选。

引用的功能很强大，但是有时候你不需要它时它却来了，你需要它时它却不在。对于引用和值拷贝，值的类型决定了它们的行为，所以赋值／参数传递的行为取决于你选择哪种值类型。

###回顾

在JavaScript中的`数组`是通过数字索引的一组任意类型的值，`字符串`有点象`数组`，但是它们的行为特征不同，你将`字符串`作为`数组`处理时需要特别小心。JavaScript中的`数值`包括“整型”和“浮点型”。

基本类型中定义了几个特殊值。

`null`类型只有一个值`null`，同样`undefined`类型只有一个值`undefined`。任何变量在赋值之前的默认值基本都是`undefined`。`void`操作符可以从任何值创建`undefined`值。

`数值`中有几个特殊值，`NaN`（意指“Not a Number”，更确切地说是“invalid number”），`+Infinity`，`-Infinity`，`-0`。

简单标量基本值（`字符串`，`数值`等）通过值拷贝来赋值／传递，但是复合值（`对象`等）通过引用拷贝来赋值／传递。这里的引用和其他语言中的引用／指针不同，它们不能指向另一个引用／指针，只能指向值。