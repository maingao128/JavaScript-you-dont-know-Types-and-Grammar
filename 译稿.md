#你不知道的JavaScript － 类型和语法

##序

有人说JavaScript是唯一一门先用后学的编程语言。

每次听到这话我都会心一笑，因为我自己就是这样，我想很多开发人员也是如此。JavaScript，也许还有CSS和HTML，在互联网早期的大学计算机课程中并不是主流教学语言。初学者大多通过搜索引擎和“查看源代码”的方式来自学。

我仍然记得自己高中时代做的第一个网站。那是搭建一个网上商店，因为是007的粉丝，所以我决定做一个“黄金眼”商店。它包罗万象，背景音乐是“黄金眼”主题曲，有一个用JavaScript做的瞄准器随着鼠标移动，每次点击鼠标时会发出一声枪响。想必Q（007中的一个角色）也应该会为这个杰作感到骄傲吧。

之所以讲到这个故事，是因为我当时使用的开发方式直到现在仍然有许多开发人员在使用，那就是“拷贝＋粘贴”。在项目中我“拷贝＋粘贴”了大量JavaScript代码，但根本没有真正理解它们。那些十分普及的JavaScript工具库，如：jQuery，也在潜移默化地影响着我们，使得我们不用再去深入了解JavaScript的本质。

我并不反对使用JavaScript工具库，实际上我还是MooTools JavaScript团队的成员之一。这些工具库之所以功能强大，原因正是它们的开发者理解这门语言的本质和精华，并且将它们运用到了极致。学会使用这些工具库非常有帮助，与此同时掌握这门语言的基础知识仍然是十分重要的。现在有了Kyle Simpson的《你不知道的JS》系列丛书，我们更有理由好好学习了。

《类型和语法》是该系列的第三本书，它介绍了JavaScript核心基础知识，这些东西我们永远不可能从“拷贝＋粘贴”和JavaScript工具库中学到。本书对强制类型转换（coercion）及其隐患、原生构造函数(natives as constructors)、以及JavaScript的所有基础知识都做了详细的介绍，并配以示例代码。同本系列的其他作品一样，Kyle的行文切中要点，没有多余的套话和修辞，正是我喜欢的技术书的风格。

希望大家喜欢《类型和语法》这本书，并能够常读常新。

-David Walsh ([http://davidwalsh.name](http://davidwalsh.name)),
Mozilla资深开发人员

------

##前言

本书使用了“JS”一词，这里并无贬义，虽然我们作为开发人员最喜欢做的事情就是吐槽编程语言。

JavaScript从互联网最早期开始就一直是实现交互体验的基本技术。虽然最初是用来实现诸如鼠标移动轨迹闪烁效果，和烦人的弹出消息框这些东西。将近二十年之后，JavaScript在技术和功能方面都得到了数量级的提升，没有人再质疑它在互联网中的重要地位。

但是作为一门编程语言它一直为人所诟病，包括它的历史沿革，更多的则是它的设计理念。Brendan Eich曾因为它的名字戏称它为“傻小弟”（相对于成熟的Java而言）。实际上这个名字完全是政治和市场考量下的产物。两个语言之间千差万别，“JavaScript”之于“Java”如同“Carnival”（嘉年华）之于“Car”（汽车）一样，没有半点关系。

JavaScript在概念和语法风格上借鉴了其他编程语言，包括C风格的程序根，和隐晦的Scheme/Lisp风格的函数根，这使得它能为不同背景的开发人员所接受，包括那些没有多少编程经验的人。用JavaScript编写一个“Hello World”程序非常简单。

JavaScript可能是最容易上手的编程语言之一，但其中的一些奇特之处使得它不像其他语言那样容易全面掌握。用C或者C++开发一个完整的应用程序要求开发者对这门语言有相当深入的了解。然而对于JavaScript，即使我们用它开发了一个完整的系统也不见得就能深入理解它。

这门语言中有些复杂的概念隐藏得很深，却常以一种看似简单的方式呈现，例如：将函数作为回调函数传递，JavaScript开发人员往往满足于使用这些现成便利的机制，而不愿去探究其中的原理。

JavaScript是一门简单易用的语言，应用广泛，同时它的语言机制又十分复杂和微妙。即使经验丰富的开发人员也需要用心学习才能真正掌握它。

JavaScript让人纠结的地方就在于此，它的阿基里斯之踵正是本书要解决的问题。因为人们毋需理解就能用它来编程，所以常常放松对它的学习。

###使命

碰到JavaScript中那些令人惊诧和抓狂的情况时，如果我们置之不理或者不求甚解，很快就会发现自己根本无从发挥这门语言的威力。

这些部分叫做JavaScript的“精华（The Good Parts）”，但我宁愿读者朋友们把它们视为“容易的部分”，“安全的部分”，或者是“不完整的部分”。

《你不知道的JS》系列旨在介绍JavaScript的另一面，让你深入掌握JavaScript的*全部*，特别是那些难点。

JS开发人员常常满足于一知半解，不愿更深入地去了解，本书要解决的正是这个问题。我们会直面那些疑难问题，而不是退避三舍。

我自己不会满足于仅仅让代码运行起来而不明就里，你也应该这样。在本书中我会逐步介绍JavaScript中那些不太为人知的地方，最终让你对这门语言有一个全面的了解。一旦掌握了这些知识，那些什么技巧、框架、和时髦术语都不在话下。

本系列丛书全面深入地介绍了JavaScript中最被误解和忽视的关键知识点。让你在读完之后从理论和实践上都能对掌握这门语言有足够的信心。

当前你对JavaScript的了解可能都来自于那些一知半解的“专家”。你知道的仅仅是冰山一角。读完本系列丛书后你将会真正了解这门语言。现在就让我们愉快地开始吧。

###回顾

JavaScript是一门优秀的语言。部分学习起来很容易，但是要整体掌握则很难。开发人员们遇到困惑时往往归咎于语言本身，而不是反省他们自身对语言的理解有多匮乏。本系列丛书旨在解决这个问题，使你能够发自内心地喜欢上这门语言。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">本书中的许多示例需要新版本的JavaScript引擎，比如：ES6。有些代码可能无法在老版本的引擎（ES6之前）中运行。</td>
    </tr>
</table>


###书写约定

本书使用以下书写约定：

*斜体字*
表示新术语，URL，电子邮件，文件名，和文件扩展名。

`等宽字`
用于程序代码，以及在段落中引用的程序代码内容，如：变量名，函数名，数据库，数据类型，环境变量，声明语句，和关键词等。

####`粗体等宽字`
需要用户输入的命令和其他文本。

*`斜体等宽字`*
需要用户提供替换值的文本，或者根据上下文计算的值。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">提示和建议</td>
    </tr>
</table>

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">注解</td>
    </tr>
</table>

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">警告和提醒</td>
    </tr>
</table>

###示例代码

本书附带的资料（如：示例代码，练习等）可以从[http://bit.ly/ydkjs-types-code](http://bit.ly/ydkjs-types-code)下载。

本书旨在帮助你解决实际问题。你可以在你的程序和文档中使用本书中的示例代码。除非大量使用，否则不需要经过我们许可。例如，你毋需征得我们的同意即可在程序中使用本书中的某几段示例代码。如果你欲将O'Reilly出版物中的示例代码制作为光盘出售则需要经过我们许可。如果你在回答别人的问题时引用了本书中的内容和示例代码，也不需要征得我们许可。如果你在产品文档中引用了大量本书中的示例代码，则需要征得我们许可。

如果你能够在使用到本书内容的地方注明出处，我们会非常感激，不过这不是强制的。注明出处通常包括书名，作者，出版方，和ISBN。例如：《你不知道的JS》，Kyle Simpson著，O'Reilly出版。Copyright 2015 Getify Solutions, Inc.，978-1-491-90419-0。

如果你的情况不属于上述种种，请通过[permissions@oreilly.com](permissions@oreilly.com)和我们联系。

###Safari Books Online

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/safari.png'></td>
        <td style="border: none;"><a href='http://safaribooksonline.com'>Safari Books Online</a>是一个即时点播数字图书馆，为您提供来自世界顶尖科技和商业作者的专业书籍和视频<a href='https://www.safaribooksonline.com/explore/'>内容</a>。</td>
    </tr>
</table>

科技工作者、软件开发人员、Web设计师、和商业创新从业者都将Safari Books Online作为他们研究、攻关、学习和认证培训的一个主要资源。

Safari Books Onine为[企业](https://www.safaribooksonline.com/enterprise/)、[政府](https://www.safaribooksonline.com/government/)、[教育](https://www.safaribooksonline.com/academic-public-library/)和个人提供不同的[计划和收费](https://www.safaribooksonline.com/pricing/)。

Safari Books Online的会员可以通过一个可检索数据库来访问数千本图书,教学视频，和正式出版前的稿件，它们来自[上百家出版方](https://www.safaribooksonline.com/our-library)，如：O'Reilly Media，Prentice Hall Prossional, Addison- Wesley Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders, McGraw-Hill, Jones & Bartlett, Course Tech‐ nology等。有关Safari Books Online更多的信息请访问我们的网站。

------

###联系我们

任何关于本书的看法和问题，可以通过以下方式和出版方联系：

O’Reilly Media, Inc.
1005 Gravenstein Highway North
Sebastopol, CA 95472
800-998-9938 (in the United States or Canada) 707-829-0515 (international or local) 707-829-0104 (fax)

我们为本书设立了一个网页，上面有勘误，示例，和其他信息。可以通过这个链接访问[http://bit.ly/ydkjs_types-and-grammar](http://bit.ly/ydkjs_types-and-grammar)。

有关本书的评论和技术问题，可以发送邮件到[bookquestions@oreilly.com](bookquestions@oreilly.com)。

有关其他图书的信息，课程，论坛，和新闻，请访问我们的网站[http://www.oreilly.com](http://www.oreilly.com)。

我们的Facebook页面：[http://facebook.com/oreilly](http://facebook.com/oreilly)

我们的Twitter：[http://twitter.com/oreillymedia](http://twitter.com/oreillymedia)

我们的Youtube频道：[http://www.youtube.com/oreillymedia](http://www.youtube.com/oreillymedia)

------

##第一章 类型

很多人认为JavaScript这样的动态语言是没有类型的。让我们看看ES5.1规范（[http://www.ecma-international.org/ecma-262/5.1/](http:// www.ecma-international.org/ecma-262/5.1/)）对此怎样解释：

```
本规范中的算法操纵的值均有相应的类型。本节中定义了所有可能出现的值类型。类型是对ECMAScript的语言类型和规范类型的进一步细分。
我们在ECMAScript语言中直接操纵的值均有一个ECMAScript语言类型与之对应。ECMAScript语言类型包括：Undefined，Null，Boolean，String，Number，和Object。
```

如果你喜欢强类型（又称为静态类型）语言，或许不认同在这里使用“类型（type）”一词。在强类型语言中，“类型”一词的含义比在JavaScript中广得多。

也有人认为JavaScript中的“类型”应该叫“标签（tags）”或者“子类型（subtypes）”更为恰当。

在本书中我们对类型做如下粗略的定义（与规范相同）：*类型*是值的一组内部特征，它定义了该值的行为特征，使其能够区别于其他值，该定义对于语言引擎和开发人员均适用。

换句话说，如果语言引擎和开发人员处理`42`（数字）和`"42"`（字符串）的方式不同，则说明它们的类型不同，一个是数字，一个是字符串。我们通常对数字`42`进行数学运算，而对字符串`"42"`进行字符串操作，如在网页上显示等。

这样定义并非无懈可击，不过对于本书而言已经足矣，并且这也与JavaScript语言对自身的描述一致。

###类型

JavaScript有没有类型真的那么重要吗？

为了合理准确地进行类型转换（见`第四章`），我们必须正确理解各个类型及其内部行为特征。几乎所有的JS程序都会涉及各式各样的强制类型转换，我们在处理这些情况时需要有充分的把握和信心。

如果要将`数字``42`当作`字符串`来处理，比如获得其中第二个字符`"2"`，我们就需要先将其从`数字`转换（强制类型转换）为`字符串`。

这看似简单明了，然而强制类型转换的方式可以有很多种。有些是显式的，比较好理解，也很安全。但如果稍不留神，强制类型转换就可能会产生意想不到的结果。

强制类型转换是令JavaScript开发人员最头疼的地方之一。它经常被人诟病为语言设计上的缺陷，太过*危险*，应该敬而远之。

在对JavaScript的类型有了一个全面的了解之后，我们或许能够改变对它的成见，认识到它的威力和好处，并且明白为什么强制类型转换的缺点被过分放大了。不过首先我们需要深入学习值（values）和类型（types）。

###内置类型

JavaScript有七种内置类型：

- null
- undefined
- boolean
- number
- string
- object
- symbol（ES6中新增）

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">除<i>object</i>之外，其他统称为基本类型。</td>
    </tr>
</table>

我们用`typeof`运算符来检测值的类型，它返回类型的字符串值。有趣的是以上七种类型和它们的字符串值并不一一对应：

```
    typeof undefined    === "undefined";    // true
    typeof true         === "boolean";      // true
    typeof 42           === "number";       // true
    typeof "42"         === "string";       // true
    typeof { life: 42 } === "object";       // true
    
    // added in ES6!
    typeof Symbol()     === "symbol";       // true
```

以上六种类型均有同名的字符串值与之对应。`Symbol`是ES6中新加入的类型，我们将在`第三章`中介绍。

你可能注意到类型`null`不在此列。它比较*特殊*，`typeof`针对它的返回结果有bug：

```
    typeof null === "object"; // true
```

正确的返回结果应该是`"null"`，这个bug由来已久，已经存在了将近20年，也许永远也不会被修复，因为牵涉到太多的Web系统，“修复”它会*产生*更多的bug，从而导致大量系统无法正常工作。

我们需要使用复合条件来检测`null`值的类型，：

```
    var a = null;

    (!a && typeof a === "object"); // true
```

`null`是基本类型中唯一的一个“假值”（falsy，也称作false-like，见`第四章`）类型，`typeof`对其仍旧返回`"object"`。

`typeof`的返回值还有一种情况，即：

```
    typeof function a(){ /* .. */ } === "function"; //
     true
```

通过上例似乎可以得出这样的结论，`函数（function）`也是JavaScript的一个内置类型。然而我们查阅规范就会知道，它实际上是`object`的一个“子类型（subtype）”。具体来说，函数是“可调用对象”（callable object），其内部有一个`[[Call]]`属性让它成为可调用对象。

函数是对象，这一点很有用，更重要的是函数还可以拥有属性。例如：

```
    function a(b,c) {
        /* .. */
    }
```

函数对象的`length`属性值是它正式声明的参数数目：

```
    a.length; // 2
```

因为该函数声明了两个命名参数（named parameters，即`b`和`c`），所以它的`length`值为`2`。

那么数组的情况又如何呢？JavaScript支持数组，那它是不是也是一个特殊类型？

```
    typeof [1,2,3] === "object"; // true
```

非也，数组也是对象。确切地说是`对象`的一个子类型（见`第三章`），其中的元素按数字顺序来索引（而非一般对象那样通过字符串键值），它的`length`属性会根据元素数量自动更新。

###值和类型

JavaScript中变量是没有类型的，只有值才有。变量随时可以持有任意类型的值。

从另一个角度来理解就是JavaScript不“强制指定类型”，也就是说语言引擎不要求变量总是持有与其初始值相同类型的值。一个变量可以当前被赋予字符串类型的值，随后又被赋予数字类型的值。

值`42`的类型为`数字（number）`，其类型无法更改。值`"42"`的类型为`字符串（string）`，数字`42`可以通过*强制类型转换（coercion）*（见`第四章`）转换为字符串`"42"`。

在对变量执行`typeof`操作时，得到结果的并非是该变量的类型，而是变量持有的值的类型，因为JavaScript中变量是没有类型的。

```
    var a = 42;
    typeof a; // "number"

    a = true;
    typeof a; // "boolean"
```

`typeof`运算符总是返回字符串：

```
    typeof typeof 42; // "string"
```

`typeof 42`首先返回字符串`"number"`，然后`typeof "number"`返回`"string"`。

###undefined和“undeclared”

变量在未持有值的时候为`undefined`。此时`typeof`返回`"undefined"`：

```
    var a;

    typeof a; // "undefined"

    var b = 42;
    var c;

    // later 
    b = c;

    typeof b; // "undefined"
    typeof c; // "undefined"
```

很多人容易将“undefined”等同为“未声明（undeclared）”。然而它们在JS中大相径庭。

对于已在作用域中声明过但是还未持有值的变量，它们的值为“undefined”。对于还没有在作用域中声明过的变量，它们的值为“undeclared”。

例如：

```
    var a;

    a; // undefined
    b; // ReferenceError: b is not defined
```

浏览器对于这类情况的报错信息很让人抓狂。上面的例子中，“b is not defined”容易让人理解为“b is undefined”。因此必须再次说明，“undefined”和“is not defined”截然不同。如果浏览器象“b is not found”或“b is not declared”这样报错的话就能避免很多不必要麻烦。

`typeof`在处理未声明（undeclared）变量时的一些特异功能让人更加抓狂。例如：

```
    var a;

    typeof a; // "undefined"

    typeof b; // "undefined"
```

对于“未声明（undeclared）”（或者“not defined”）变量，`typeof`同样返回`"undefined"`。请注意虽然`b`是一个未声明变量，但`typeof b`执行时并没有报错。这是由于`typeof`一个特殊的安全防范机制所致。

如果`typeof`能对未声明变量返回“undeclared”而非“undefined”的话情况会好很多。

###typeof Undeclared

这样的安全防范机制对于在浏览器中运行的JavaScript来说还是很有用的，因为不同的script文件能够将变量加载到共享的全局命名空间中。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px; "><img src='images/note.png'></td>
        <td style="border: none;">很多开发人员认为全局命名空间中不应该有变量，所有的东西应该被封装到模块和私有命名空间中。理论上这样没错，虽然在实际操作中基本不可行，但仍不失为一个值得努力的方向。好消息是ES6中加入了对模块的优先支持，最终会让其更具可操作性。
        </td>
    </tr>
</table>

举个简单的例子，在你的程序中通过一个全局变量`DEBUG`作为“调试模式”的开关。在执行诸如将信息写入控制台这样的调试任务前，你会检查`DEBUG`变量是否已经被声明过。最顶层的全局变量声明`var DEBUG = true`只包含在“debug.js”文件中，该文件只在开发和测试时才在浏览器中加载，在生产环境中不加载。

然而在程序的其他地方，你需要特别注意检查全局变量`DEBUG`的方式，以免出现`ReferenceError`错误。这时安全防范机制就很有用：

```
    // 这样做会产生错误
    if (DEBUG) {
        console.log( "Debugging is starting" );
    }

    // 这样做则是安全的，不会产生错误
    if (typeof DEBUG !== "undefined") {
        console.log( "Debugging is starting" );
    }

```

即使对非用户定义的变量来说，这样的检查也是很有用的。如果你要为内置的API做功能检查，它也可以让你避免产生错误：

```
    if (typeof atob === "undefined") {
        atob = function() { /*..*/ };
    }
```


<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">如果要为某个缺失的功能制作“polyfill”（衬垫代码或者补充代码，用来补充当前运行环境中缺失的功能），你也许不会使用<b>var atob</b>来声明变量atob。如果在<b>if</b>语句中使用<b>var atob</b>，该声明会被提升（hoisted，参见本系列的Scope &amp; Closures一书）到作用域（当前脚本或函数的作用域）的最顶层，即使<b>if</b>条件未通过也是如此（因为atob全局变量已经存在）。在一些浏览器中，对于一些特殊的内置全局变量（通常被称为“host objects”），这样重复声明会产生错误。去掉<b>var</b>可以防止声明被提升。
        </td>
    </tr>
</table>

另外有一种方法可以不使用`typeof`中的安全防范机制来检查全局变量是否已经存在，即检查全局变量是否也是全局对象中的属性，在浏览器中这个全局变量是`window`。所以前面的例子可以这样来实现：

```
    if (window.DEBUG) {
        // ..
    }
    
    if (!window.atob) {
        // ..
    }
```

和未声明变量不同的是，访问不存在的对象属性时并不会产生`ReferenceError`错误。

然而许多开发人员会尽量避免使用`window`来访问全局变量，特别是当代码需要在多个JS环境中运行时（不仅仅是浏览器，还有服务器端node.js等），因为此时的全局变量并不一定是`window`。

从技术角度来说，`typeof`中的安全防范机制对于非全局变量仍然是有用的，虽然这种情况不太常见，所以一些开发人员不大愿意使用。如果想让别人在他们的程序中拷贝粘贴你的工具函数，你需要在函数中做一些检查来确定某些变量是否已经在宿主程序中定义过：

```
    function doSomethingCool() {
        var helper =
            (typeof FeatureXYZ !== "undefined") ?
            FeatureXYZ :
            function() { /*.. default feature ..*/ };

        var val = helper();
        // .. 
    }
```

`doSomethingCool()`检查变量`FeatureXYZ`是否存在，如果是就使用之，否则使用自己定义的版本。如果这段代码在其他的模块和程序中使用，它会安全地检查变量`FeatureXYZ`是否已在宿主程序中定义：

```
    // an IIFE (see the "Immediately Invoked Function Expressions"
    // discussion in the Scope & Closures title in this series)
    (function(){
        function FeatureXYZ() { /*.. my XYZ feature ..*/ }

        // include `doSomethingCool(..)`
        function doSomethingCool() {
            var helper =
                (typeof FeatureXYZ !== "undefined") ?
                FeatureXYZ :
                function() { /*.. default feature ..*/ };

            var val = helper();
            // .. 
        }
        
        doSomethingCool();
    })();
```

这里`FeatureXYZ`不是一个全局变量，但我们还是使用`typeof`的安全防范机制来做检查。重要的是我们没有使用任何全局对象（如前面提到的`windows.___`），因此`typeof`在这里非常管用。

有些开发人员倾向使用一种方式叫“依赖注入”（dependency injection），即将需要的对象作为参数显式地传递进来，而不是通过函数`doSomethingCool()`来检查变量`FeatureXYZ`是否已经定义过，如：

```
    function doSomethingCool(FeatureXYZ) {
        var helper = FeatureXYZ ||
            function() { /*.. default feature ..*/ };
        var val = helper();
        // ..
    }
```

实现此类检查的方法有很多。它们之间没有“错”与“对”之分，各有利弊。`typeof`为我们提供了多一个选择，这总归是极好的。

###回顾

JavaScript有七种内置类型：`null`，`undefined`，`boolean`，`number`，`string`，`object`，和`symbol`。可以使用`typeof`运算符来标志。

变量没有类型，但是它们持有的值有类型。类型定义了值的内在行为特征。

很多开发人员认为“undefined“和“undeclared”基本上是相同的，但是在JavaScript中它们有很大区别。`undefined`是变量可以持有的一种值。“undeclared”表示变量还没有被声明过。

糟糕的是JavaScript将它们合二为一，在错误信息中是这样（“ReferenceError:a is not defined”），`typeof`的返回值"undefined"也是如此。

不过在某些情况下使用`typeof`的安全防范机制（阻止报错）来检查未声明（undeclared）变量还是非常有用的。

------

##第二章 值

`array`（array），`string`（string），和`number`（number）是计算机程序最基本的组成部分，然而在JavaScript中，它们的某些特性可以说是“让我欢喜让我忧”。

###数组

相比强类型语言，JavaScript中的`array`可以容纳任何类型的值，可以是`string`，`number`，`object`，甚至其他`array`（多维数组就是以此方式来实现的）：

```
    var a = [ 1, "2", [3] ];

    a.length;       // 3
    a[0] === 1;     // true
    a[2][0] === 3;  // true
```

你不需要预先设定数组的大小（参考`第44页的Array(..)`），你只需要对其进行声明，然后即可向其中加入适当的值：

```
    var a = [ ];

    a.length;   // 0
    
    a[0] = 1;
    a[1] = "2";
    a[2] = [ 3 ];

    a.length;   // 3
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">对<b>数组</b>中的值执行<b>delete</b>操作可将其移除，需要注意的是，即使值被移除后，数组的<b>length</b>属性并不会相应变化。我们会在<b>第五章</b>详细介绍<b>delete</b>操作。
        </td>
    </tr>
</table>

创建“稀疏”`array`（数组中有一些空白／空缺的单元）时需要特别注意：

```
    var a = [ ];

    a[0] = 1;
    // no `a[1]` slot set here
    a[2] = [ 3 ];
    
    a[1];       // undefined
    
    a.length;   // 3
```

上面的代码虽然可以正常运行，但是其中的“空白单元”会产生一些令人困惑的结果。`a[1]`当前的值为`undefined`，但这和我们显示将其赋值为`undefined`（`a[1] = undefined`）还是有区别。详情参见`第44页的“Array(..)”`。

`array`使用数字索引，因为数组也是`object`类型，所以可以包含字符串键值和属性（这些并不计算在数组长度`length`内）：

```
    var a = [ ];

    a[0] = 1;
    a["foobar"] = 2;
    
    a.length;       // 1
    a["foobar"];    // 2
    a.foobar;       // 2
```

然而有一个容易出错的地方需要我们注意，如果作为键值的`string`可以被强制类型转换为10进制`number`，则系统则视其为`number`索引而非`string`键值！

```
    var a = [ ];

    a["13"] = 42;
    
    a.length; // 14
```

通常来说，在`array`中使用`string`作为键值/属性并不是一个好办法。建议用`object`来存放通过键值/属性访问的值，用`array`来存放通过数字索引的值。

###类数组

有时候我们需要将类似`array`的值（一组使用数字索引的值）转换为真正的`array`，通常可以使用`array`工具函数来实现（如：`indexOf(..)`，`concat(..)`，`forEach(..)`等等）。

例如，一些DOM查询操作返回DOM元素列表，它们并非真正意义上的`array`，但却十分类似。另一个常见的例子，是一些函数通过`arguments`对象（类数组）以列表的方式来访问函数参数（ES6已经废止了）。

我们常用工具函数`slice(..)`来实现这类转换：

```
    function foo() {
        var arr = Array.prototype.slice.call( arguments );
        arr.push( "bam" );
        console.log( arr );
    }

    foo( "bar", "baz" ); // ["bar","baz","bam"]
```

如上例所示，如果`slice()`不带其他参数，它会返回当前的数组参数（本例中是一个类`array`）的一个复本。

在ES6有一个内置工具函数`Array.from(..)`也有相同的功能：

```
    ...
    var arr = Array.from( arguments );
    ...
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>Array.from(..)</b>有一些功能很强大，我们将在本系列的<i>《ES6规范及更多》</i>一书中详细介绍。
</td>
    </tr>
</table>

###字符串

`string`通常被认为是由字符组成的`array`。然其内部实现有没有使用`array`并不一定，对我们来说重要的是认识到JavaScript中的`string`和字符`array`并不一样。它们仅仅是表面上看起来相似罢了。

例如下面两个值：

```
    var a = "foo";
    var b = ["f","o","o"];
```

如上例所示，`string`和`array`确实有相似之处，都是类`array`。比如，它们都有`length`属性，`indexOf(..)`方法（从ES5开始`array`支持此方法），和`concat(..)`方法：

```
    [source,js]

    a.length;                           // 3
    b.length;                           // 3

    a.indexOf( "o" );                   // 1
    b.indexOf( "o" );                   // 1

    var c = a.concat( "bar" );          // "foobar"
    var d = b.concat( ["b","a","r"] );  // ["f","o","o","b","a","r"]

    a === c;                            // false
    b === d;                            // false

    a;                                  // "foo" 
    b;                                  // ["f","o","o"]
```

那是不是因此就可以说它们都是“由字符组成的数组”？答案是否定的，见下例：

```
    a[1] = "O";
    b[1] = "O";

    a; // "foo"
    b; // ["f","O","o"]
```

JavaScript中的`string`是不可变的，而`array`是可变的。并且`a[1]`这样的方式在JavaScript中并非总是合法的。老版本的IE就不允许这样（现在可以了）。*正确*的方式应该是`a.charAt(1)`。

`string`不可变的意思是`string`的成员函数都不会改动`string`的原始值，而是创建并返回一个新的`string`。而`array`的成员函数都是在其原始值上进行操作。

```
    c = a.toUpperCase();
    a === c;    // false
    a;          // "foo"
    c;          // "FOO"

    b.push( "!" );
    b;          // ["f","O","o","!"]
```

此外，很多`array`函数在处理`string`时非常有用，`string`中没有这些函数，但我们可以“借用”`array`的这些非变更方法（nonmutation）来处理`string`：

```
    a.join;         // undefined
    a.map;          // undefined

    var c = Array.prototype.join.call( a, "-" );
    var d = Array.prototype.map.call( a, function(v){
        return v.toUpperCase() + ".";
    } ).join( "" );
    
    c;              // "f-o-o"
    d;              // "F.O.O."
```

我们再来看看另外一个例子：`string`反转（经常在JavaScript面试中遇到的问题！）。`array`有一个可变更成员函数`reverse()`，而`string`没有：

```
    a.reverse;      // undefined

    b.reverse();    // ["!","o","O","f"]
    b;              // ["f","O","o","!"]
```

遗憾的是，此类“借用”对于`array`的可变更成员函数不适用，因为`string`是不可变的，其内容无法更改：

```
    Array.prototype.reverse.call( a );
    // 返回值仍然是"foo"的一个字符串封装对象（见第三章）:(
```

一个变通（破解）的办法是将`string`转换为`array`再执行需要的操作，然后再将结果转换回`string`：

```
    var c = a
        // split `a` into an array of characters
        .split( "" )
        // reverse the array of characters
        .reverse()
        // join the array of characters back to a string
        .join( "" );
    
    c; // "oof"
```

虽然看起来很丑陋，但对于简单的`string`来说是可以的，这类简单粗暴的方法有时往往很奏效。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">请注意！上述方法对于包含复杂字符（unicode，如：星号，多子节字符等等）的<b>字符串</b>来说并不适用。这时你需要功能更加完备，能够处理unicode的工具库。可以参考Mathias Bynen的<a href='https://github.com/mathiasbynens/esrever'>Esrever</a>。</td>
    </tr>
</table>

还有一种方法，如果需要经常用`字符数组`的方式来处理`string`，不如直接使用`array`。这样就不用在`string`和`array`之间折腾了。可以在需要时对`字符数组`执行`join("")`来将其转换为`string`。

###数值

JavaScript只有一种数字类型，即：`number`。它包括“整数”和带小数的十进制数。“整数“加引号是因为和其他语言不同，JavaScript中没有真正意义上的整数，这也是它一直以来为人诟病的地方。这个情况在将来或许会有所改观，不过就目前而言所有数值均为`number`类型。

JavaScript中的“整数”只是没有小数位的十进制数。所以`42.0`即等同于“整数”`42`。

和大多数现代编程语言一样，包括所有的脚本语言，JavaScript的`number`类型是基于“IEEE 754”标准来实现的，我们通常称之为“浮点数”。JavaScript具体使用的是“双精度”（即“64位二进制”）标准。

网上有很多优秀的文章详细介绍了二进制浮点数在内存中的存储方式，以及不同实现的各自的考量。正确使用JS的`number`类型并不一定要求我们掌握内存中数位的存储方式，所以本书对此不多做介绍，有兴趣的读者可以参考IEEE 754的相关细节。

###数字的句法

JavaScript中，数字常量一般用十进制表示。例如：

```
    var a = 42;
    var b = 42.3;
```

数字前半部分为0的话可以省略：

```
    var a = 0.42;
    var b = .42;
```

同样地，数字后半部分（小数）为0的话也可以省略：

```
    var a = 42.0;
    var b = 42.;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;"><b>42.</b>这种写法不太常见，虽然是合法的，但考虑到代码的可读性我们通常不建议使用。</td>
    </tr>
</table>

缺省情况下大部分`number`都以十进制显示，小数部分最后面的0省略。如：

```
    var a = 42.300;
    var b = 42.0;

    a; // 42.3
    b; // 42
```

那些特别大和特别小的`number`会默认用指数格式显示，与`toExponential()`函数的输出结果相同，例如：

```
    var a = 5E10;
    a;                  // 50000000000
    a.toExponential();  // "5e+10"

    var b = a * a;
    b;                  // 2.5e+21
    
    var c = 1 / a;
    c;                  // 2e-11
```

由于`number`类型的值可以使用`Number`对象来进行封装（boxed，见`第三章`），因此`number`类型的值可以使用`Number.prototype`中的方法（见`第三章`）。例如`toFixed(..)`方法能够让你指定小数部分显示的位数：

```
    var a = 42.59;

    a.toFixed( 0 ); // "43"
    a.toFixed( 1 ); // "42.6"
    a.toFixed( 2 ); // "42.59"
    a.toFixed( 3 ); // "42.590"
    a.toFixed( 4 ); // "42.5900"
```

请注意上例的输出结果实际上是该`number`的`string`，如果小数部分显示的位数多于实际的位数则用`0`补齐。

类似地，`toPrecision(..)`方法能够让你指定`有效数字`显示的位数：

```
    var a = 42.59;

    a.toPrecision( 1 ); // "4e+1"
    a.toPrecision( 2 ); // "43"
    a.toPrecision( 3 ); // "42.6"
    a.toPrecision( 4 ); // "42.59"
    a.toPrecision( 5 ); // "42.590"
    a.toPrecision( 6 ); // "42.5900"
```

这些方法不仅适用于`number`变量，也适用于`number`常量。不过在使用`.`运算符时需要特别注意，因为它是一个合法的数字字符，它会被尽可能优先识别为`number`常量的一部分，然后才是对象属性访问运算符。

```
    // invalid syntax:
    42.toFixed( 3 );    // SyntaxError

    // these are all valid:
    (42).toFixed( 3 );  // "42.000"
    0.42.toFixed( 3 );  // "0.420"
    42..toFixed( 3 );   // "42.000"
```

`42.toFixed(3)`是非法语法，因为`.`被视为常量`42.`的一部分（如前所述），因此上例中并没有`.`访问运算符来调用`toFixed`方法。

`42..toFixed(3)`没有问题，因为第一个`.`被视为`42.`的一部分，第二个`.`是访问运算符。只是这样看起来有点奇怪，在现实中也很少见。事实上这种基本类型值直接调用方法的形式并不常见，不过不常见并不代表`不好`和`不对`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">有一些代码库扩展了<b>Number.prototype</b>的内置方法（见<b>第三章</b>b），提供了更多数值操纵功能，比如使用<b>10..makeItRain()</b>实现下十分钟金钱雨的动画等。</td>
    </tr>
</table>

下面的语法也是合法的（请注意空格）：

```
    42 .toFixed(3); // "42.000"
```

然而对于`number`常量而言这样的语法很容易造成误导，我们不建议使用。

`number`还可以用指数格式表示，常用于较大的数字，如：

```
    var onethousand = 1E3;                      // means 1 * 10^3
    var onemilliononehundredthousand = 1.1E6;   // means 1.1 * 10^6
```

`number`常量还可以用其他格式来表示，如：二进制，八进制，和十六进制。

这些格式当前版本的JavaScript都支持：

```
    0xf3; // hexadecimal for: 243
    0Xf3; // 同上

    0363; // octal for: 243
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从ES6开始，<b>严格模式</b>不再支持0363八进制格式（新格式见下）。0363格式在<b>非严格模式</b>中仍然支持，但是考虑到将来的兼容性最好不要再使用（目前你使用的应该是<b>严格模式</b>）。</td>
    </tr>
</table>

ES6支持以下新格式：

```
    0o363;      // octal for: 243
    0O363;      // 同上

    0b11110011; // binary for: 243
    0B11110011; // 同上
```

考虑到代码的易读性，我们不推荐使用`0O363`格式，因为`0`和大写`O`在一起容易混淆。建议尽量使用小写`0x`，`0b`，和`0o`。

###较小的数值

使用二进制浮点数最大的问题（不仅仅JavaScript，所有遵循IEEE 754规范的语言都是如此），是会出现下面的情况：

```
    0.1 + 0.2 === 0.3; // false
```

从数学角度来说上面的条件判断应该为`true`，但为什么是`false`呢？

简单来说，二进制浮点数中的`0.1`和`0.2`并不特别精确，它们相加的结果并非刚刚好等于`0.3`，而是一个比较接近数字`0.30000000000000004`，所以上面的条件判断结果为`false`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">有人认为JavaScript应该采用可以精确表示数字的实现方式。一直以来也出现了很多替代方案，只是都没有获得认可，或许永远也不会。虽然这个问题看起来挺简单，，实际却并非如此，否则早就解决了。</td>
    </tr>
</table>

现在的问题是，如果有些`number`无法做到完全精确，是否意味着我们完全不能使用`number`类型了呢？答案当然是否定的。

有一些应用程序在处理数字，特别是带有小数的数字时需要特别精确。还有很大一部分（或许占绝大多数）应用程序仅需要处理整数，最大不超过百万或者万亿。JavaScript的数字操作对于这些应用程序来说是绝对可靠的。

如果我们了解了以上知识，再要比较两个`number`，比如：`0.1 + 0.2`和`0.3`，时应该怎么做呢？

通常的方法是设置一个误差范围值。通常称为“机器小量（machine epsilon）”，对于JavaScript中的`number`来说一般是`2^-52 (2.220446049250313e-16)`。

自ES6起，该误差范围值定义在`Number.EPSILON`中，你可以直接使用，或者可以通过polyfill来为ES6之前的版本定义该值：

```
    if (!Number.EPSILON) {
        Number.EPSILON = Math.pow(2,-52);
    }
```

现在我们可以使用`Number.EPSILON`来比较两个`number`是否相等了（在指定的误差范围内）：

```
    function numbersCloseEnoughToEual(n1,n2) {
        return Math.abs( n1 - n2 ) < Number.EPSILON;
    }

    var a = 0.1 + 0.2;
    var b = 0.3;

    numbersCloseEnoughToEqual( a, b );                  // true
    numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );  // false
```

能够呈现的最大浮点值为`1.798e+308`（这是一个相当大的数字），定义在`Number.MAX_VALUE`中。最小浮点值定义在`Number.MIN_VALUE`中，大约是`5e-324`，它不是负数，但无限接近于`0`！

###整数的安全范围

`number`的呈现方式决定了“整数”有一个远远小于`Number.MAX_VALUE`的安全值范围。

能够被“安全”呈现的最大整数值（即能够确保该值被清晰无误地呈现）是`2^53 - 1`，即`9007199254740991`，在ES6中定义为`Number.MIN_SAFE_INTEGER`。

有时JS程序需要处理一些比较大的数字，常见的情况是数据库中的64位ID等。由于JavaScript的`number`类型无法精确处理64位数值，所以必须将它们保存（转换）为`string`来处理。

庆幸的是大数值操作并不常见（除了比较操作，其可以通过`string`来处理）。不过如果我们确实需要对这类较大的数值进行数学运算，目前来说还是需要使用相关的工具库。在未来的JavaScript版本中也许会加入对大数值的支持。

###整数检测

如果要检测一个值是否是整数，可以使用ES6中的`Number.isInteger(..)`方法：

```
    Number.isInteger( 42 );     // true
    Number.isInteger( 42.000 ); // true
    Number.isInteger( 42.3 );   // false
```

我们可以为ES6之前的版本polyfill一个`Number.isInteger(..)`方法：

```
    if (!Number.isInteger) {
        Number.isInteger = function(num) {
            return typeof num == "number" && num % 1 == 0;
        };
    }
```

要检测一个值是否是`安全的整数`，可以使用ES6中的`Number.isSafeInteger(..)`方法：

```
    Number.isSafeInteger( Number.MAX_SAFE_INTEGER );    // true
    Number.isSafeInteger( Math.pow( 2, 53 ) );          // false
    Number.isSafeInteger( Math.pow( 2, 53 ) - 1 );      // true
```

我们可以为ES6之前的版本polyfill一个`Number.isSafeInteger(..)`方法：

```
    if (!Number.isSafeInteger) {
        Number.isSafeInteger = function(num) {
            return Number.isInteger( num ) &&
                Math.abs( num ) <= Number.MAX_SAFE_INTEGER;
        }; 
    }
```

###32位有符号整数

虽然整数最大能够达到53位，一些数字操作（如：数位操作）只适用于32位的`number`，因此这些操作中的`number`的安全范围就要小得多。

这种情况下的安全范围是从`Math.pow(-2,31)`（-2147483648，约-21亿）到`Math.pow(2,31)`（2147483647，约21亿）。

如果要将变量`a`中的数值转换为32位有符号整数，可以这样：`a | 0`。这个方法很管用，因为`|`数位运算符只适用于32位整数（即它只关心32位以内的值，忽略其他的数位）。因此与0进行`或`操作即可截取`a`中的32位数位。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">有一些特殊的值并不是32位安全（32-bit safe）的，如：<b>NaN</b>和<b>Infinity</b>（我们将在下节介绍）。32位安全是指传递给数位运算符的值会执行一个虚拟操作<b>ToInt32</b>（见第四章），用来转换为符合数位运算符要求的<b>+0</b>值。</td>
    </tr>
</table>

###特殊的数值

JavaScript的类型涉及几个特殊的值，JS开发人员需要对它们特别注意。

####不是值的值

`undefined`类型只有一个值，即：`undefined`。`null`也只有一个值类型，即：`null`。对于这两个类型，它们的名称即是类型也是值。

`undefined`和`null`经常被用来表示“空（empty）”值或“非值（non）”值。它们之间存在一些细微的差别。例如：

- `null`指空值。
- `undefined`指还未赋值。

或者：

- `undefined`指从未赋过值。
- `null`指曾被赋过值，但是目前没有值。

无论你如何定义和使用这两个值，`null`都是一个特殊关键字，而非标志符，因此你不能将其当作变量来赋值。然而`undefined`却是标志符。

####Undefined

在`非严格（non-strict）`模式下，我们可以为全局标志符`undefined`赋值（这个设计实在是脑残！）：

```
    function foo() {
        undefined = 2; // really bad idea!
    }
    
    foo();
    
    function foo() {
        "use strict";
        undefined = 2; // TypeError!
    }

    foo();
```

在`非严格`和`严格`模式下，你可以声明一个名为`undefined`的局部变量。再次强调我们不建议这样做。

```
   function foo() {
        "use strict";
        var undefined = 2;
        console.log( undefined ); // 2
    }

    foo();
```

永远不要重新定义`undefined`。

####void运算符

`undefined`是一个内置的标志符（除非被修改，见前面的介绍），其值为`undefined`，要得到该值还有另外一个方法，即通过`void`运算符。

表达式`void ___`不返回任何值，因此其返回结果永远是`undefined`。它并不更改其操作的值，只是让表达式不返回任何值：

```
    var a = 42;

    console.log( void a, a ); // undefined 42
```

按照惯例（大部分源自C语言），我们使用`void 0`来得到`undefined`（显然`void true`和其他`void`表达式也返回相同的结果）。`void 0`，`void 1`，和`undefined`之间并没有实质区别。

`void`运算符在其他一些情况下也非常有用，比如你需要确保表达式不返回任何结果时，即使它有边缘效应（side effects）。

例如：

```
    function doSomething() {
        // note: `APP.ready` is provided by our application
        if (!APP.ready) {
            // try again later
            return void setTimeout( doSomething,100 );
        }
    
        var result;
        
        // do some other stuff
        return result;
    }

    // were we able to do it right away?
    if (doSomething()) {
        // handle next tasks right away
    }
```

上例中，`setTimeout(..)`函数返回一个数值（计时器间隔的唯一标志，用来取消计时），但是为了让该函数的`if`语句不产生误报（false positive），我们就要`void`掉它。

很多开发人员喜欢把它们分开，不用`void`但效果是一样的：

```
    if (!APP.ready) {
        // try again later
        setTimeout( doSomething,100 );
        return;
    }
```

一般来说，如果你想将代码中的某个值（由一些表达式产生）设为`undefined`，就使用`void`运算符。这种用法可能并不常见，不过在需要时还是很有用。

####特殊数值

`number`类型包括几个特殊的值，我们将在这里详细介绍。

#####不是数字的数值

如果数学运算中的操作数不是`number`类型（或者不能够被解析为常规的10进制或16进制`number`），那么运算将无法返回一个合法的`number`结果，这种情况下返回值为`NaN`。

`NaN`字面上意指“不是一个数字（not a number）”，这个名字不太好，容易引起误导，后面我们会讲到。把它解释为“无效数值”，“失效数值”，或者“坏的数值”可能更贴切一些。

例如：

```
    var a = 2 / "foo";      // NaN

    typeof a === "number";  // true
```

换句话说，“不是数字的数值”的类型仍然是`number`。名字和意思一样的绕啊！

`NaN`是一个“标记符号”(sentinel value，具有特殊意义的正常值)，用来表示`number`类型中的某种出错状况，就是“我试图执行一个数学运算但是没有成功，这是操作失败返回的`number`结果”。

如果你要检查变量中的数值是否是`NaN`，也许会认为可以直接拿该数值和`NaN`来比较，就象比较`null`和`undefined`那样。答案是否定的。

```
    var a = 2 / "foo";
   
    a == NaN;   // false
    a === NaN;  // false
```

`NaN`这个值很特殊，它永远不会和其他的`NaN`值相等（即永远不等于它自己）。它是唯一一个非自反（reflexive，即`x === x`不成立）的值。因而`NaN != NaN`为`true`，很奇怪不是吗？

如果我们无法比较两个`NaN`（永远返回false），那应该怎样对它做判断呢？

```
    var a = 2 / "foo";
   
    isNaN( a ); // true
```

很简单，我们使用内建的全局工具函数`isNaN(..)`来判断一个值是否是`NaN`。搞定！

问题并没有这么简单。

`isNaN(..)`有一个严重缺陷。它是按照字面来解读`NaN`（“Not a Number”），即“判断传递进来的参数是`NaN`还是`number`”。但是这样做结果并不十分准确：

```
    var a = 2 / "foo";
    var b = "foo";
    
    a; // NaN
    b; "foo"
    
    window.isNaN( a ); // true
    window.isNaN( b ); // true--ouch!
```

很明显"foo"不是一个`数值`，但是它也不是`NaN`。这个bug自JS问世以来一直存在（超过19年）。

从ES6开始，有一个替代工具函数`Number.isNaN(..)`。它是一个简单的polyfill，你可以在ES6之前的浏览器中安全地测试`NaN`值。

```
    if (!Number.isNaN) {
        Number.isNaN = function(n) {
            return (
                typeof n === "number" &&
                window.isNaN( n )
            ); 
        };
    }
    
    var a = 2 / "foo";
    var b = "foo";
    
    Number.isNaN( a ); // true
    Number.isNaN( b ); // false--phew!
```

实际上我们可以用更简单的方式来实现`Number.isNaN(..)`polyfill，利用`NaN`不等于自己这个奇怪的特性。`NaN`是JavaScript中*唯一*一个不等于自己的值，其他的值都等于自己。

因此我们可以这样做：

```
    if (!Number.isNaN) {
        Number.isNaN = function(n) {
            return n !== n;
        };
    }
```

虽然奇怪，但是有效。

`NaN`有意无意地反映了很多JS程序面临的一个现实问题。它使得我们尽量使用`Number.isNaN(..)`这样的可靠的测试方法，无论是系统内置还是polyfill都是如此。

如果你用到了`isNaN(..)`，很不幸你的代码会有bug，即便目前还未显露。

#####无穷数

熟悉传统编译型语言的开发人员可能遇到过“除以0”这样的编译错误或者运行时错误，例如：

```
    var a = 1 / 0;
```

然而在JS中，上面代码的结果为`Infinity`（即`Number.POSITIVE_INFINITY`）。例如：

```
    var a = 1 / 0;  // Infinity
    var b = -1 / 0; // -Infinity
```

如果除法运算中有一个操作数为负，则结果为`-Infinity`（即`Number.NEGATIVE_INFINITY`）。

JS遵循有限数值规范（即之前讨论过的IEEE 754浮点数），所以和纯粹的数学运算不同，它的运算结果有可能溢出，此时运算结果即为`Infinity`或者`-Infinity`。

例如：

```
    var a = Number.MAX_VALUE;   // 1.7976931348623157e+308
    a + a;                      // Infinity
    a + Math.pow( 2, 970 );     // Infinity
    a + Math.pow( 2, 969 );     // 1.7976931348623157e+308
```

根据规范，如果加法运算的结果超出处理范围，则运算结果由IEEE 754规范中的“就近取整（round-to-nearest）”模式来决定。例如：相对于`Infinity`来说，`Number.MAX_VALUE + Math.pow(2, 969)`与`Number.MAX_VALUE`更为接近，因此它被“向下取整（round down）”，然而`Number.MAX_VALUE + Math.pow(2, 970）`与`Infinity`更为接近，所以它被“向上取整（round up）”。

这个问题想多了容易让人头疼，我们就此打住吧。

一旦计算结果溢出到`无穷数`就无法再产生任何有穷数结果。说得诗意一点就是，你可以从有穷走向无穷，但无法从无穷回到有穷。

如果你有哲学家式的思维可能会问：“那么无穷除以无穷会得到什么结果呢？”。我们的第一反应可能会是“1“或者”无穷“，可惜都不对。因为从数学运算和JavaScript语言的角度来说，`Infinity / Infinity`是一个未经定义的运算操作。JS中它的运算结果是`NaN`。

那么有穷数正数除以`Infinity`呢？很简单，结果是`0`。有穷负数除以`Infinity`呢？这里卖个关子，我们后面介绍。

#####零值

这部分内容对于有数学思维的读者可能会带来困惑，JavaScript中有一个正常的`0`（也叫做`+0`）和一个`-0`。在解释为什么会有`-0`之前，我们先来看看JS是如何处理它的，因为这很容易令人费解。

除了将`-0`作为常量，一些数学运算也返回负零。例如：

```
    var a = 0 / -3; // -0
    var b = 0 * -3; // -0
```

加法和减法运算不会得到负零的结果。

在开发调试控制台中，负零通常被显示为`-0`，不过一些老的浏览器会将其显示为`0`。

根据规范，负零转换为字符串结果是“`0`”：

```
    var a = 0 / -3;
    
    // (some browser) consoles at least get it right
    a;                          // -0
    
    // but the spec insists on lying to you!
    a.toString();               // "0"
    a + "";                     // "0"
    String( a );                // "0"

    // strangely, even JSON gets in on the deception
    JSON.stringify( a );   // "0"
```

有意思的是如果我们反过来将其从`string`转换为`number`，得到的结果都是准确的：

```
    +"-0";              // -0
    Number( "-0" );     // -0
    JSON.parse( "-0" ); // -0
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;"><b>JSON.stringify(-0)</b>返回<b>“0”</b>，而<b>JSON.parse("-0")</b>返回<b>-0</b>。</td>
    </tr>
</table>

负零转换为字符串的结果令人费解，它的比较操作也是如此：

```
    var a = 0;
    var b = 0 / -3;

    a == b;     // true
    -0 == 0;    // true

    a === b;    // true
    -0 === 0;   // true
    
    0 > -0;     // false 
    a > b;      // false
```

如果要在代码中区分`-0`和`0`，我们就需要处理得更巧妙些，不能依赖开发调试窗口的输出结果：

```
    function isNegZero(n) {
        n = Number( n );
        return (n === 0) && (1 / n === -Infinity);
    }

    isNegZero( -0 );        // true
    isNegZero( 0 / -3 );    // true
    isNegZero( 0 );         // false
```

除了那些理论上的考量外，我们为什么需要负零呢？

在某些特殊的应用程序中开发人员需要使用级数形式来表示数据（如动画帧的移动速度），用`number`的符号来表示其他一些信息（如移动的方向）。

在这种情况下，如果一个包含`0`值的变量丢失了它的符号，其代表的方向信息也就会丢失。所以保留`0`值的符号可以防止此类信息丢失。

#####特殊等式

如上所述，`NaN`和`-0`在进行相等比较时特别一些。`NaN`和自身不相等，因此你必须使用ES6中的`Number.isNaN(..)`（或者polyfill）来做判断。同样令人费解地是，`-0`等于`0`（甚至`===`也是如此，见`第四章`），因此你必须使用`isNegZero(..)`这样的工具函数来做判断。

从ES6开始有一个新的工具方法`Object.is(..)`来判断两个值是否严格相等，它可以处理上述所有的特殊情况：

```
    var a = 2 / "foo";
    var b = -3 * 0;

    Object.is( a, NaN );    // true
    Object.is( b, -0 );     // true

    Object.is( b, 0 );      // false
```

对于ES6之前的版本，`Object.is(..)`有一个简单的polyfill：

```
    if (!Object.is) {
        Object.is = function(v1, v2) {
            // test for `-0`
            if (v1 === 0 && v2 === 0) {
                return 1 / v1 === 1 / v2;
            }
            // test for `NaN`
            if (v1 !== v1) {
                return v2 !== v2;
            }
            // everything else
            return v1 === v2;
        };
    }
```

在能够安全使用`==`和`===`的情况下（见`第四章`），可以尽量不用`Object.is(..)`，因为前两者效率更高，也更符合习惯，更为通用。`Object.is(..)`主要是针对那些特殊情况。

###值和引用

在很多其他语言中，赋值和参数值传递可以通过值拷贝，也可以通过引用拷贝来完成，这取决于你用到的语法。

例如，在C++中，如果要向一个函数传递一个`number`参数，在函数中参数值会被更改，你可以将该参数声明为`int& myNum`，当你向该函数传递变量`x`时，`myNum`即为指向`x`的引用。引用是指针的一种特别形式，让你得到一个指向该变量的指针（类似于*别名*）。如果你不将参数声明为引用，则参数值*总是*通过值拷贝的方式传递，即使对复杂的对象也是如此。

JavaScript中没有指针，引用的工作机制也不尽相同。JS中你不可能将一个引用从一个变量指向另一个变量。

JS中的引用指向的是值（共享值），如果你有10个不同的引用，则它们分别指向同一个共享值，*相互之间没有任何引用／指向关系*。

JavaScript在语法上对值和引用的赋值／传递不做区分，*仅仅*根据值的*类型*来决定采取哪种方式。

让我们来看一个例子：

```
    var a = 2;
    var b = a; // `b` is always a copy of the value in `a`
    b++;
    a; // 2
    b; // 3

    var c = [1,2,3];
    var d = c; // `d` is a reference to the shared `[1,2,3]` value
    d.push( 4 );
    c; // [1,2,3,4]
    d; // [1,2,3,4]
```

简单值（即标量基本类型值，scalar primitives）*总是*通过值拷贝的方式赋值／传递，包括：`null`，`undefined`，`string`，`number`，`boolean`，和ES6中的`symbol`。

复合值，即`object（对象）`（包括`array`，所有的封装对象，见`第三章`）和`function（方法）`，*总是*通过引用拷贝的方式来赋值／传递。

在前面的示例代码中，由于`2`是一个标量基本类型值，则变量`a`持有的是该值的一个拷贝，`b`被赋值为该值的另一个拷贝。`b`中的值更改时`a`中的值保持不变。

然而`c`和`d`却是两个不同的引用，指向同一个复合值`[1,2,3]`。值得注意的是，`c`和`d`并不拥有值`[1,2,3]`，仅仅是同时指向它。所以通过它们之间的任何一个来更改值（如`.push(4)`）的时候，它们都将指向更改后的值`[1,2,3,4]`。

由于引用指向的是值本身而非变量，所以一个引用无法更改另一个引用的指向。

```
    var a = [1,2,3];
    var b = a;
    a; // [1,2,3]
    b; // [1,2,3]
    
    // later
    b = [4,5,6];
    a; // [1,2,3]
    b; // [4,5,6]
```

`b=[4,5,6]`给'b'赋新值时，并不影响`a`指向的值`[1,2,3]`。除非`b`不是指向`array`的引用，而是指向'a'的指针。但是这种情况在JS中不存在！

此类困扰经常发生在函数参数上：

```
    function foo(x) {
        x.push( 4 );
        x; // [1,2,3,4]
    
        // later
        x = [4,5,6];
        x.push( 7 );
        x; // [4,5,6,7]
    }

    var a = [1,2,3];
    
    foo( a );

     a; // [1,2,3,4]  not  [4,5,6,7]
```

我们将`a`传递给函数的时候，实际是将`a`的一个复本赋值给`x`，而`a`仍然是指向`array`object`[1,2,3]`的一个单独的引用。在函数中我们可以通过引用`x`来更改该`array`的值（`push(4)`）。赋值语句`x = [4,5,6]`并不影响`a`原来指向的值，`a`仍旧指向`[1,2,3,4]`。

我们不可能使用引用`x`来更改引用`a`的指向，只能更改`a`和`x`共同指向的值的内容。

如果要将`a`指向的值更改为`[4,5,6,7]`，你必须更改`x`指向的`array`的值，而非为`x`创建并赋值一个新的`array`。

```
    function foo(x) {
        x.push( 4 );
        x; // [1,2,3,4]

        // later
        x.length = 0; // empty existing array in-place
        x.push( 4, 5, 6, 7 );
        x; // [4,5,6,7]
    }
    
    var a = [1,2,3];

    foo( a );
    
    a; // [4,5,6,7] not [1,2,3,4]
```

如你所见，`x.length = 0`和`x.push(4,5,6,7)`没有创建一个新`array`，而是对现有的`array`进行更改。所以`a`指向的值变成了`[4,5,6,7]`。

请记住：你无法直接控制和重载值拷贝和引用，它们的语义由它们所指向的值的类型来决定。

如果要有效地通过值拷贝的方式传递复合值（如`array`），你需要为其创建一个拷贝，使得传递到函数中的参数不再指向原始值。例如：

```
    foo( a.slice() );
```

`slice(..)`不带参数的话会返回一个当前`array`的浅（shallow）拷贝。由于传递给函数的引用指向的是一个拷贝，所以`foo(..)`中的操作不会影响`a`指向的值。

反过来如果要象引用那样，将标量基本类型值传递到函数内并进行更改，就需要将该值封装到一个复合值（`object`，`array`，或其他）中，通过引用拷贝的方式传递。

```
    function foo(wrapper) {
        wrapper.a = 42;
    }

    var obj = { 
        a: 2
    };

    foo( obj );

    obj.a; // 42
```

这里`obj`是一个封装对象，其中包含了标量基本类型值`a`。`obj`引用的一个拷贝赋值给参数`wrapper`并传递到`foo(..)`中。这样我们就可以通过`wrapper`来访问共享对象并更改其属性。函数返回后`obj.a`的值将变为`42`。

有时我们需要传递指向标量基本类型值（如`2`）的引用，这时可以将该值封装到`Number`对象中（见`第三章`）。

虽然这里传递的是指向一个`Number`对象的引用拷贝，但并非如我们预想的那样，指向共享对象的引用并不能更改其中的基本类型值：

```
    function foo(x) {
        x = x + 1;
        x; // 3 
    }
    
    var a = 2;
    var b = new Number( a ); // or equivalently `Object(a)`
    
    foo( b );
    console.log( b ); // 2, not 3
```

原因是标量基本类型值是不可更改的（`String`和`Boolean`也是如此）。如果一个`Number`对象的标量基本类型值是`2`，那么该值就不可能被更改，除非创建一个新的包含不同值的`Number`对象。

当执行`x = x + 1;`时，`x`中的标量基本类型值`2`被从`Number`对象中提取出来，`x`神不知鬼不觉地从引用变成了`Number`对象，它的值为`2 + 1`等于`3`。然而函数外部的`b`仍然指向原来那个值为`2`的`Number`对象。

你可以往`Number`对象中添加属性（只要不更改其内部的基本类型值就行），从而间接地通过它们来交换信息。

不过这种方式不是很常见，多数人也并不认为这是一个好方法。

相对而言，我们在前面的示例代码中介绍过的使用`obj`作为封装对象的方法可能更好。这并不是说`Number`这样的封装对象没有什么用，只是大多数情况下标量基本类型值应该是首选。

引用的功能很强大，但是经常产生出人意料的结果。对于引用和值拷贝来说，值的类型决定了它们的行为方式，所以赋值／参数传递的行为取决于我们选择哪种值类型。

###回顾

JavaScript中的`array`是通过数字索引的一组任意类型的值，`string`有点象`array`，但是它们的行为特征不同，在将`string`作为`array`处理时需要特别小心。JavaScript中的`number`包括“整型”和“浮点型”。

基本类型中定义了几个特殊值。

`null`类型只有一个值`null`，同样`undefined`类型也只有一个值`undefined`。任何变量在赋值之前的默认值都是`undefined`。`void`运算符可以从任何值得到`undefined`。

`number`中有几个特殊值，包括：`NaN`（意指“Not a Number”，更确切地说是“invalid number”），`+Infinity`，`-Infinity`，`-0`。

简单标量基本类型值（`string`，`number`等）通过值拷贝来赋值／传递，但是复合值（`object`等）通过引用拷贝来赋值／传递。这里的引用和其他语言中的引用／指针不同，它们不能指向其他引用／指针，只能指向值。

------

##第三章 原生函数

在`第一章`和`第二章`里，我们提到过一些JavaScript的内建函数，通常叫做“原生函数”，如：`string`和`array`。本章我们将对它们做详细介绍。

以下是常用的原生函数：

- String() 
- Number() 
- Boolean()
- Array()
- Object()
- Function()
- RegExp()
- Date()
- Error()
- Symbol()－ES6中新增!

如你所见，它们实际上是内建函数。

如果你熟悉Java语言，会发现JavaScript中的`String()`看起来很象Java中字符串的构造函数`String(..)`。因此你可以象下面这样：

```
    var s = new String( "Hello World!" );

    console.log( s.toString() ); // "Hello World!"
```

这些原生函数可以当做构造函数来使用。但是它们构造出的对象可能和我们预想的不同：

```
    var a = new String( "abc" );
    
    typeof a;                            // "object" ... not "String"
    
    a instanceof String;                 // true
    
    Object.prototype.toString.call( a ); // "[object String]"
```

通过构造函数的方式（如`new String("abc")`）创建的对象是包含基本类型值（如`"abc"`）的封装对象。

值得注意的是`typeof`显示的不是这些对象本身的*类型*，而是`object`类型的子类型。

我们可以使用下面的代码来进一步查看封装对象：

```
    console.log( a );
```

以上代码的输出结果在不同的浏览器中有区别，取决于浏览器处理对象序列化（serialization）的方式。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">在写作本书时，Chrome的最新版本是这样显示的：<a>String {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}</b>。但是老版本显示为：<a>String {0: "a", 1: "b", 2: "c"}</a>。最新版本的Firefox显示为：<a>String ["a","b","c"]</a>，但是老版本显示为：<a>"abc"</a>，并且可以点击打开对象查看。这些输出结果随着浏览器的不断演进而变化。</td>
    </tr>
</table>

简单来说就是`new String("abc")`创建的是字符串`"abc"`的封装对象，而非基本类型值`"abc"`。

###内部类

`typeof`返回`"object"`的值（如`array`）包含一个额外的内部属性`[[Class]]`（你可以把它看作是一个内部的分类，而非传统意义上的类）。我们无法直接访问这个属性，一般都是通过`Object.prototype.toString(..)`来访问它。例如：

```
    Object.prototype.toString.call( [1,2,3] );
    // "[object Array]"

    Object.prototype.toString.call( /regex-literal/i );
    // "[object RegExp]"
```

上例中的数组的内部`[[Class]]`属性值是`"Array"`，正则表达式是`"RegExp"`。通常内部`[[Class]]`属性是与创建值使用的内建原生构建函数相对应（见下），但也并非总是如此。

那基本类型值呢？我们先来看看`null`和`undefined`：

```
    Object.prototype.toString.call( null );
    // "[object Null]"
    
    Object.prototype.toString.call( undefined );
    // "[object Undefined]"
```

虽然`Null()`和`Undefined()`这样的原生构建函数并不存在，但是内部`[[Class]]`属性值仍然是`"Null"`和`"Undefined"`。

对于其他基本类型值来说情况又有所不同，如：`string`，`number`，和`boolean`。我们通常称之为“封装（boxing）”（参见`第42页的“封装对象包装”`）：

```
    Object.prototype.toString.call( "abc" );
    // "[object String]"
    
    Object.prototype.toString.call( 42 );
    // "[object Number]"
    
    Object.prototype.toString.call( true );
    // "[object Boolean]"
```

上面的示例代码中，基本类型值自动被打包（boxed）为对应的封装对象，所以它们的内部`[[Class]]`属性值分别为`"String"`，`"Number"`，和`"Boolean"`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从ES5到ES6，<a>toString()</a>和<a>[[Class]]</a>发生了一些变化，我们将会在本系列的<i>《ES6 &amp; Beyond》</i>一书中详细介绍。</td>
    </tr>
</table>

###封装对象包装

封装对象扮演的角色十分重要。因为基本类型值没有属性和方法，我们需要通过封装对象来访问`.length`和`.toString()`，此时JS会自动为基本类型值*包装*（box或者wrap）一个封装对象：

```
    var a = "abc";
    
    a.length; // 3
    a.toUpperCase(); // "ABC"
```

如果你需要经常访问这些`string`中的属性和方法，比如在`for`循环中使用`i < a.length`，或许从一开始就创建一个封装对象会比较好，这样JS引擎就不需要每次自动为你创建封装对象了。

但实际上这并不是一个好办法。因为浏览器早就为`.length`这样的常见情况做了性能优化，如果试图通过直接使用封装对象的方式来“预先优化（preoptimize）”代码，*实际上会让执行速度更慢*。

通常我们不需要直接使用封装。最好是让JS引擎自己决定什么时候使用封装。换句话说就是应该优先考虑使用`"abc"`和`42`这样的基本类型值，而非`new String("abc")`和`new Number(42)`。

###封装对象释疑

使用封装对象时，有一些地方需要特别注意。

例如`Boolean`：

```
    var a = new Boolean( false );
    
    if (!a) {
        console.log( "Oops" ); // never returns
    }
```

问题出在这里，我们为`false`值创建了一个封装对象，但对象是真值（即“truthy”，总是返回`true`，见`第四章`），所以使用封装对象和使用`false`值的结果大相径庭。

如果你想要自己对基本类型值进行封装，可以使用`Object(..)`函数（不带`new`）：

```
    var a = "abc";
    var b = new String( a );
    var c = Object( a );

    typeof a; // "string"
    typeof b; // "object"
    typeof c; // "object"
    
    b instanceof String; // true
    c instanceof String; // true

    Object.prototype.toString.call( b ); // "[object String]"
    Object.prototype.toString.call( c ); // "[object String]"
```

再次强调，我们不推荐直接使用封装对象（如上例中的`b`和`c`），不过在一些特殊情况下可能确实需要这样做。

###拆封

如果你想要得到封装对象内的基本类型值，可以使用`valueOf()`函数：

```
    var a = new String( "abc" );
    var b = new Number( 42 );
    var c = new Boolean( true );

    a.valueOf(); // "abc"
    b.valueOf(); // 42
    c.valueOf(); // true
```

当封装对象需要使用基本类型值的时候也会自动地进行拆封（unboxing）。这个过程我们称为`强制类型转换（coercion）`，我们将在`第四章`详细介绍。

```
    var a = new String( "abc" );
    var b = a + ""; // `b` has the unboxed primitive value "abc"
    
    typeof a;       // "object"
    typeof b;       // "string"
```

###使用原生方法作为构造函数

对于`array`，`object`，`函数`，和`正则表达式`来说，我们一般倾向通过常量的方式来创建值，实际上使用常量和使用构造函数的效果是一样的（创建的值都通过封装对象来包装）。

前面我们讲过应该尽量避免使用这些构造函数，除非确实有必要，因为它们常常会产生意想不到的结果。

####Array(..)

```
    var a = new Array( 1, 2, 3 );
    a; // [1, 2, 3]

    var b = [1, 2, 3];
    b; // [1, 2, 3]
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">构造函数<b>Array(..)</b>前不要求一定有<b>new</b>关键字。没有时它会被自动加上。因此<b>Array(1,2,3)</b>和<b>new Array(1,2,3)</b>的效果是一样的。</td>
    </tr>
</table>

`array`构造函数只带一个`number`参数时，该参数会被当作数组的预设大小（length），而非数组中的一个元素。

这实在不是一个明智的做法，容易让人忽视和犯错。

更要命的是，`array`并没有预设大小这个概念。这样创建出来的只是一个空数组（empty array），只不过其`length`属性被设置成了指定的值。

一个数组中没有任何元素，但是它的`length`属性却告诉我们元素的数量，这样的数据结构很奇特，会导致一些怪异的行为。这来自那些已被废弃的陈旧的特性（比如`arguments`这样的“类数组对象”）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">我们将有至少一个“空单元（empty slot）”的<b>数组</b>称为“稀疏数组（sparse array）”。</td>
    </tr>
</table>

对于这种情况，不同浏览器的开发调试控制台显示的结果也各异，让问题变得更加扑朔迷离。

例如：

```
    var a = new Array( 3 );
    
    a.length; // 3
    a;
```

在Chrome中（到本书写作时）`a`被序列化为`[ undefined x 3 ]`，表示数组中有三个值为`undefined`的单元，实际上并不存在任何单元（“空单元（empty slots）”并不是一个很好的叫法）。

下面的例子反映了这种差别：

```
    var a = new Array( 3 );
    var b = [ undefined, undefined, undefined ];
    var c = [];
    c.length = 3;
    
    a; 
    b; 
    c;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">我们可以创建包含空单元的数组，如上例中的<b>c</b>。如果将<b>length</b>属性设置为超过实际单元数的值，就会隐式地制造出空单元。实际上我们还可以通过<b>delete b[1]</b>在数组<b>b</b>的中制造出一个空单元。</td>
    </tr>
</table>

`b`（在Chrome的当前版本中）显示为`[ undefined, undefined, undefined ]`，而`a`和`c`显示为`[ undefined x 3 ]`。是不是很晕？我也一样。

更糟糕的是，到本书写成为止，`a`和`c`在Firefox中显示为`[ , , , ]`。有没有发现问题在哪里？在仔细看看，三个逗号代表了四个空单元，而非我们认为的三个。

Firefox在输出结果末尾额外多加了一个`,`，这是怎么回事！？因为从ES5开始允许在列表（数组、属性列表等）的末尾加上一个逗号（其在处理中会被忽略不计）。所以如果我们在代码或者调试控制台中输入的是`[ , , , ]`，实际得到的则是`[ , , ]`（包含三个空单元的数组）。这样做看起来令人费解，目的是让拷贝粘贴的结果更加准确。

读到这里你也许是一头雾水，没关系，你不是一个人在战斗！

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">对于上面这种情况Firefox显示<b>[ <3 empty slots> ]</b>，比起<b>[ , , , ]</b>来说要好得多。</td>
    </tr>
</table>

不仅控制台的输出结果让人费解，还有更糟糕的情况。前面示例代码中的`a`和`b`有时表现一致，有时却不一样：

```
    a.join( "-" ); // "--"
    b.join( "-" ); // "--"

    a.map(function(v,i){ return i; }); // [ undefined x 3 ]
    b.map(function(v,i){ return i; }); // [ 0, 1, 2 ]
```

额...。

`a.map(..)`之所以返回无效结果，是因为数组中并没有任何单元，所以`map(..)`无从遍历。而`join(..)`又有所不同。我们可以将其等同为下面的代码：

```
    function fakeJoin(arr,connector) {
        var str = "";
        for (var i = 0; i < arr.length; i++) {
            if (i > 0) {
                str += connector;
            }
            if (arr[i] !== undefined) {
                str += arr[i];
            } 
        }
        return str; 
    }
    
    var a = new Array( 3 );
    fakeJoin( a, "-" ); // "--"
```

我们可以看到，`join(..)`首先假定数组不为空，然后通过`length`属性值来遍历其中的元素。而`map(..)`并不做这样的假定，所以它对“空单元（empty slots）”`array`的处理结果出乎我们的预料，也容易导致各种问题。

如果要创建包含`undefined`单元（而非“空单元”）的数组，我们可以这样：

```
    var a = Array.apply( null, { length: 3 } );
    a; // [ undefined, undefined, undefined ]
```

是不是不太好理解？下面我们详细解释一下。

`apply(..)`是一个工具函数，适用于任何函数对象，它以一种特殊的方式来调用传递给它的函数。

第一个参数是`this`对象（在本系列的<i>《this & Object Prototypes》</i>一书中有介绍），我们这里不用管，将其设为`null`。第二个参数应该是一个`array`或者类似数组的值（即“类数组对象”）。该“数组”中的值作为被调用函数的参数。

因此`Array.apply(..)`调用`Array(..)`方法，将`{ length: 3 }`中的值作为参数（本例中该参数是三个空值`{ undefined, undefined, undefined }`）。

我们设想`apply(..)`内部有一个`for`循环（类似之前的`join(..)`），从`0`开始循环到`length`（本例中为`3`，即循环到`2`，不包括`3`）。

假如在`apply(..)`函数内部，数组对象参数名为`arr`，那么`for`循环会通过`arr[0]`，`arr[1]`，`arr[2]`来遍历数组对象参数。由于`{ length: 3 }`中并不存在这些属性，所以返回值为`undefined`。

换句话说，我们实际上调用的是`Array(undefined, undefined, undefined)`，所以最后的结果是单元值为`undefined`的数组，而非空单元数组。

虽然使用`Array.apply( null ,{ length: 3 } )`来创建单元值为`undefined`的数组显得有些奇怪和繁琐，但是远比使用`Array(3)`更好更可靠。

我们必须遵循一个基本原则：任何情况下都不要创建和使用空单元数组。

###Object(..)，Function(..)，和RegExp(..)

`Object(..)`／`Function(..)`／`RegExp(..)`等构造函数也并非是必须的（因此除非确实有必要，否则应尽量不要使用）：

```
    var c = new Object();
    c.foo = "bar";
    c; // { foo: "bar" }

    var d = { foo: "bar" };
    d; // { foo: "bar" }
    
    var e = new Function( "a", "return a * 2;" );
    var f = function(a) { return a * 2; }
    function g(a) { return a * 2; }
    
    var h = new RegExp( "^a*b+", "g" );
    var i = /^a*b+/g;
```

实际操作中我们并没有必要通过`new Object()`这样的方式来创建对象，并且如果使用这种方式，我们必须逐一设定对象的属性，而无法通过常量形式（literal form）一次设定多个属性。

构造函数`Function`在极少数情况下才会被用到，比如需要动态定义函数参数和函数体的时候。不要将`Function(..)`当做`eval(..)`的替代。你基本上不需要通过这种方式来定义函数。

我们强烈建议使用常量形式（如：`/^a*b+/g`）来定义正则表达式，这样不仅语法简单，性能也更佳，因为JS引擎在执行代码之前会将其预编译并缓存。和前面介绍的构造函数不同，`RegExp(..)`还是很有用处的，比如动态定义正则表达式规则：

```
    var name = "Kyle";
    var namePattern = new RegExp( "\\b(?:" + name + ")+\\b", "ig" );

    var matches = someText.match( namePattern );
```

上面这样的情况在JS中会不时出现，所以我们需要用到`new RegExp("pattern","flags")`。

###Date(..)和Error(..)

`Date(..)`和`Error(..)`这两个原生构造函数的用处则相对大得多，因为没有常量形式可以替代它们。

创建日期对象必须使用`new Date()`。`Date(..)`构造函数可以带参数，用来指定日期和时间，不带参数的话则使用当前的日期和时间。

`Date(..)`最主要的用途是获得当前Unix系统时间（从1970年1月1日开始计算，以秒为单位）。你可以通过日期对象中的`getTime()`来获得这个值。

从ES5开始引入了一个更简单的方法，即静态函数`Date.now()`。对于ES5之前的版本我们可以使用下面的polyfill：

```
    if (!Date.now) {
        Date.now = function(){
            return (new Date()).getTime();
        };
    }
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">如果在调用<b>Date()</b>的时候不带<b>new</b>关键字会得到当前日期的字符串值。在规范中没有指定它的具体格式，但是浏览器会使用类似这样的格式“Fri Jul 18 2014 00:31:02 GMT-0500 (CDT)”来显示。</td>
    </tr>
</table>

构造函数`Error(..)`（和前面的`Array()`类似）带不带`new`关键字效果都一样。

创建错误对象主要目的是获得当前运行堆栈的上下文信息（在大部分JS引擎中通过只读属性`.stack`来访问）。堆栈上下文信息包括函数调用栈信息和产生错误的代码行号，让代码调试更方便。

错误对象通常结合`throw`运算符一起使用：

```
    function foo(x) {
        if (!x) {
            throw new Error( "x wasn't provided" );
        }
    // .. }
```

一般来说，错误对象至少会包含`message`属性，有时可能还会有其他属性（作为只读属性），如：`type`。然而除了前面介绍的`stack`属性外，通常最好的办法是直接调用`toString()`方法来获得经过格式化便于查看的错误信息（通过隐式或者显式强制类型转换，见`第四章`）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">从技术角度来说，除了<b>Error(..)</b>之外，还有针对某些特定错误类型的原生构造函数，如：<b>EvalError(..)</b>，<b>RangeError(..)</b>，<b>ReferenceError(..)</b>，<b>SyntaxError(..)</b>，<b>TypeError(..)</b>，和<b>URIError(..)</b>。但我们很少直接用到它们。在程序产生异常时这些方法会被自动调用（比如使用未经声明的变量时会产生<b>ReferenceError</b>错误）。</td>
    </tr>
</table>

###Symbol(..)

从ES6开始加入了一个新的基本数据类型－“标志”（Symbol）。标志是一种特殊的具有唯一性的值（不绝对保证唯一！），可以用做对象属性名且不容易产生命名冲突。该类型的引入主要是考虑到ES6中的一些特殊构造，不过我们也可以自定义标志。

标志可以被用作属性名，但是我们无法在代码中看到和访问标志实际的值，在调试控制台中也是如此。如果试图在调试控制台中查看标志会看到`Symbol(Symbol.create)`这样的内容。

ES6中有一些预定义标志，作为`Symbol`方法对象的静态属性，如：`Symbol.create`，`Symbol.iterator`等。它们可以这样来使用：

```
    obj[Symbol.iterator] = function(){ /*..*/ };
```

我们可以使用`Symbol(..)`原生构造函数来自定义标志。它有点特别，不能使用`new`，否则会产生错误：

```
    var mysym = Symbol( "my own symbol" );
    mysym;              // Symbol(my own symbol)
    mysym.toString();   // "Symbol(my own symbol)"
    typeof mysym;       // "symbol"
    
    var a = { };
    a[mysym] = "foobar";
    Object.getOwnPropertySymbols( a );
    // [ Symbol(my own symbol) ]
```

虽然标志事实上并非私有（private）（用`Object.getOwnPropertySymbols(..)`可以得到对象中的所有标志），但它主要的应用范围还是私有和特殊属性。很多开发人员用它来替换那些名称中含有下划线（_）前缀的属性，下划线前缀通常用于命名私有和特殊属性。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>标志</b>并非<b>对象</b>，它是简单标量基本类型。</td>
    </tr>
</table>

###原生Prototypes

原生构造函数有自己的`.prototype`对象，如：`Array.prototype`，`String.prototype`等等。

这些对象包含对应子类型特有的行为特征。

例如，通过封装（boxing）对`string`基本类型进行扩展后，所有字符串对象都能够访问`String.prototype`对象中定义的方法。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">根据文档规范，我们将<b>String.prototype.XYZ</b>简写为<b>String#XYZ</b>，对于其他<b>.prototypes</b>也如此。</td>
    </tr>
</table>

`String#indexOf(..)`
    在字符串中找到指定子字符串的位置

`String#charAt(..)`
    获得字符串中指定位置的字符

`String#substr(..)`，`String#substring(..)`，和` String#slice(..)`
    将字符串中的某部分提取出来形成新的字符串

`String#toUpperCase()`和`String#toLowerCase()`
    将字符串转换为大写和小写形式的新字符串

`String#trim()`
    去掉字符串前面和后面的空格，返回新的字符串

这些方法并不更改原字符串的内容，而是返回一个新字符串。

任何字符串值都可以通过prototype delegation（参考本系列的*《this & Object Prototypes》*）来访问这些方法：

```
    var a = " abc ";
    
    a.indexOf( "c" ); // 3
    a.toUpperCase();  // " ABC "
    a.trim();         // "abc"
```

其他构造函数的prototype中包含它们各自类型特有的行为特征，比如：`Number#toFixed(..)`（将数字转换为指定长度的整数字符串），和`Array#concat(..)`（合并数组）。所有函数（function）都可以访问`Function.prototype`中定义的`apply(..)`，`call(..)`，和`bind(..)`。

但有些原生prototype并非单纯的对象：

```
    typeof Function.prototype;          // "function"
    Function.prototype();               // it's an empty function!
    
    RegExp.prototype.toString();        // "/(?:)/" -- empty regex
    "abc".match( RegExp.prototype );    // [""]
```

糟糕的是，你甚至可以更改这些原生prototypes（不单是向其中添加属性这些你已熟知的更改）：

```
    Array.isArray( Array.prototype );   // true
    Array.prototype.push( 1, 2, 3 );    // 3
    Array.prototype;                    // [1,2,3]

    // don't leave it that way, though, or expect weirdness!
    // reset the `Array.prototype` to empty
    Array.prototype.length = 0;
```

你可以看到，`Function.prototype`是一个函数，`RegExp.prototype`是一个正则表达式，而`Array.prototype`是一个数组。是不是很有意思？

###使用Prototypes作为默认值

`Function.prototype`是一个空函数，`RegExp.prototype`是一个“空”正则表达式（例如：没有任何匹配），而`Array.prototype`是一个空数组，对于还没有赋值的变量来说它们是不错的缺省值。

例如：

```
    function isThisCool(vals,fn,rx) {
        vals = vals || Array.prototype;
        fn = fn || Function.prototype;
        rx = rx || RegExp.prototype;
        return rx.test(
            vals.map( fn ).join( "" )
        ); 
    }

    isThisCool();       // true
    
    isThisCool(
        ["a","b","c"],
        function(v){ return v.toUpperCase(); },
        /D/
    );                  // false
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从ES6开始我们不再需要使用<b> vals = vals || .. </b>这样的方式来设置缺省值（见<b>第四章</b>），因为我们可以通过函数声明中的原生语法来设置缺省值（见<b>第五章</b>）。</td>
    </tr>
</table>

这样做有一点好处就是`.prototypes`已经创建好并且*只创建一次*。相比之下如果使用`[]`，`function(){}`，和`/(?:)/`作为缺省值，每次调用`isThisCool(..)`的时候这些缺省值都有可能被重新创建一次（具体取决于JS引擎，稍后可能被垃圾回收）。这会造成内存和CPU资源的浪费。

有一点需要注意，就是如果缺省值在后面会被改动的话，就不要使用`Array.prototype`作为缺省值。前面的例子中的`vals`是作为只读变量来使用，更改`vals`实际上是更改`Array.prototype`本身，这样会导致前面提到过的一系列问题！

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这里我们介绍了原生prototypes及其用途，对于它们的使用需要十分小心，特别是要对它们做更改时。详情请见<b>第167页，Appendix A一节的“Native Prototypes”</b>。</td>
    </tr>
</table>

###回顾

JavaScript为基本数据类型值提供了封装对象，我们称为原生构造函数（`String`，`Number`，`Boolean`等）。它们为基本数据类型值提供了其子类型特有的方法和属性（`String#trim()`和`Array#concat(..)`）。

对于一个简单标量基本类型值`"abc"`，如果要访问它的`length`属性或者`String.prototype`方法，JS引擎会自动对该值进行封装（box，即使用相应类型的封装对象来包装它）以实现对这些属性和方法的访问。

------

##第四章 强制类型转换

对JavaScript的类型和值有了一个更全面的了解之后，我们来讨论一个非常具有争议性的主题：强制类型转换（coercion）。

我们在`第一章`中提到过，有关强制类型转换是一个设计缺陷还是真的有用的争论从JS诞生的第一天就开始了。其他JS书籍普遍将其描述为怪异、有害、难懂，是一个彻头彻尾的糟糕设计。

在这里我们秉承本系列丛书的主旨，不会象很多人那样对这个主题退避三舍，或者一朝被蛇咬十年怕井绳。对于不了解的知识我们应该迎难而上。

本章旨在全面介绍强制类型转换的优缺点（它确实有优点！），让你对它有一个合理清晰的判断。

###值类型转换

将值从一种类型转换为另一种类型通常称为“类型转换”（type casting），这是指显式的情况，在隐式的情况下我们称为“强制类型转换”（coercion，具体怎么转换由值的使用规则来决定）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">JavaScript中强制类型转换总是返回标量基本类型值（见<b>第二章</b>），如：<b>string</b>，<b>number</b>，和<b>boolean</b>常量。强制类型转换不会返回<b>object</b>和<b>function</b>。在<b>第三章</b>中我们介绍过“封装”，即为标量基本类型值封装一个对应类型的对象，但这并非严格意义上的强制类型转换。</td>
    </tr>
</table>

也可以这样来区分它们：“类型转换”发生在静态类型语言的编译阶段，而“强制类型转换”是发生在动态语言的运行时。

然而在JavaScript中大都将它们统称为*强制类型转换*，我个人倾向于“隐式类型转换”和“显式类型转换”。

它们之间的区别显而易见：代码中我们能够看出哪些地方是“显式类型转换”，而“隐式类型转换”则不那么明显，通常是某些操作的边缘效应。

例如下面两个强制类型转换的例子：

```
    var a = 42;
    
    var b = a + "";         // implicit coercion
    
    var c = String( a );    // explicit coercion
```

对于变量`b`而言，强制类型转换是隐式的，由于`+`运算符有一个操作数是`string`，所以这实际是`string`拼接操作，作为它的一个隐式边缘效应，数字`42`被强制类型转换为相应的字符串值：`"42"`。

函数`String(..)`则是显式地将`a`强制类型转换为`string`。

两者均将数字`42`转换为字符串`"42"`。但是它们进行转换的方式引发了诸多争论。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从技术角度来说，除了形式上的差别外，这里还有一些细微的行为上的差别。我们将在下一章详细介绍，<b>“Implicitly: Strings &lt;--&gt; Numbers”，第87页</b>。</td>
    </tr>
</table>

这里的“显式”和“隐式”，以及“明显边缘效应”和“隐式边缘效应“等都是*相对而言的*。

在理解了`a + ""`的前提下，如果你有意识地以这样的方式来进行`string`转换，可能觉得它是“显式”的。反之如果你根本不知道`String(..)`能够被用于`string`强制类型转换，就可能会觉得它是“隐式”的。

这里我们是以一个普遍公认的尺度来谈“显式”和“隐式”，而不是以专家和JS规范的尺度。如果这与你自己的定义不符，你可能需要根据我们的定义来进行调整。

请记住一点：我们编写的代码大都是需要给别人看的。即便你已经是一个JS专家，也需要顾及到其他水平层次的开发人员，考虑他们是否能读懂你的代码，以及别人对于“显式”和“隐式”的定义是否和你一致？

###抽象值操作

在介绍“显式”和“隐式”强制类型转换之前，我们需要掌握值转换的基本规则（将值转换为`string`，`number`，和`boolean`）。ES5规范第9节中定义了一些“抽象操作”（“仅内部使用的操作”的规范用语）及其转换规则。我们这里着重介绍`ToString`，`ToNumber`，和`ToBoolean`，附带讲一讲`ToPrimitive`。

####ToString

规范第9.8节中定义了抽象操作`ToString`，它负责从非字符串值到`string`值的强制类型转换。

内建基本类型值有自己的字符串化操作（stringification）：`null`转换为`"null"`，`undefined`转换为`"undefined"`，`true`转换为`"true"`。`number`的字符串化遵循我们熟知的规则，但是`第二章`中介绍过那些非常小和非常大的`number`使用的是指数形式：

```
    // multiplying `1.07` by `1000`, seven times over
    var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;

    // seven times three digits => 21 digits
    a.toString(); // "1.07e21"
```

对于普通对象来说，除非特别指定，否则`toString()`（在`Object.prototype.toString()`中）返回其内部`[[Class]]`属性值（见`第三章`），例如：`"[object Object]"`。

但是之前我们介绍过，如果对象有自定义的`toString()`方法，在其转换为`string`时该方法会被调用，得到的结果`string`即是它的返回值。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">将对象强制类型转换为<b>字符串</b>是通过抽象操作<b>ToPrimitive</b>来完成的（ES5规范，第9.1节），我们稍后将在本章的<b>ToNumber</b>一节中详细介绍，在此略过。</td>
    </tr>
</table>

`array`有一个经过重载的缺省`toString()`方法，将所有单元的值字符串化后通过`","`连接起来：

```
    var a = [1,2,3];

    a.toString(); // "1,2,3"
```

重要的话说两遍，`toString()`可以被显式调用，在非字符串值需要转换为字符串的时候也会被自动调用。

####JSON字符串化

在使用工具函数`JSON.stringify(..)`将JSON对象序列化为`string`时也涉及到`ToString`。

请特别注意，这里的字符串转换并非严格意义上的强制类型转换。不过由于涉及前面提到的`ToString`规则，我们就此岔开话题介绍一下JSON字符串化。

对于大部分简单值来说，JSON字符串化基本和`toString()`的效果一样，只不过序列化总是返回一个`string`：

```
    JSON.stringify( 42 );   // "42"
    JSON.stringify( "42" ); // ""42"" (a string with a
                            // quoted string value in it)
    JSON.stringify( null ); // "null"
    JSON.stringify( true ); // "true"

```

任何安全的JSON值（JSON-safe）都可以用`JSON.stringify(..)`来字符串化。安全的JSON值就是能够使用JSON格式来呈现的值。

为了更好理解，让我们来看看什么是不安全的JSON值。比如：`undefined`，`functions`，`symbols`（ES6+），和包含循环引用（即对象之间相互引用，形成一个无限循环）的`objects`，对于标准JSON结构来说这些都是非法值，主要是因为它们让其他支持JSON的语言无法处理。

`JSON.stringify(..)`工具在遇到`undefined`，`function`，和`symbol`时会返回`undefined`，在`array`中会用`null`替代（从而保证单元位置索引不变），如果是对象属性则会被忽略。

例如：

```
    JSON.stringify( undefined );        // undefined
    JSON.stringify( function(){} );     // undefined
 
    JSON.stringify(
       [1,undefined,function(){},4]
    );                                  // "[1,null,null,4]"
    JSON.stringify(
       { a:2, b:function(){} }
    );                                  // "{"a":2}"
```

对含有循环引用的对象运行`JSON.stringify(..)`会产生错误。

JSON字符串化对于包含`toJSON()`方法的对象有一点特别，这时`toJSON()`方法会首先被调用，然后用它的返回值来做序列化。

如果我们要对含有非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要为该对象定义`toJSON()`方法，使之返回一个安全的JSON值。

例如：

```
    var o = { };

    var a = { 
        b: 42,
        c: o,
        d: function(){}
    };

    // create a circular reference inside `a`
    o.e = a;
    
    // would throw an error on the circular reference
    // JSON.stringify( a );
    
    // define a custom JSON value serialization
    a.toJSON = function() {
        // only include the `b` property for serialization
        return { b: this.b };
    };
    
    JSON.stringify( a ); // "{"b":42}"
```

我们通常会误以为`toJSON()`方法必须返回一个经过JSON字符串化的值。这并不准确，除非我们确实需要字符串化`string`（通常不会！）.`toJSON()`应该返回一个适当的值（可以是任何类型），然后再由`JSON.stringify(..)`对其进行字符串化。

换句话说，`toJSON()`应该被理解为“返回一个能够被字符串化的安全的JSON值”，而非很多人误解的“返回一个JSON字符串”。

例如：

```
    var a = {
        val: [1,2,3],

        // probably correct!
        toJSON: function(){
            return this.val.slice( 1 );
        }
    };
    
    var b = {
        val: [1,2,3],
        // probably incorrect!
        toJSON: function(){
            return "[" +
                this.val.slice( 1 ).join() +
            "]"; 
        }
    };
    
    JSON.stringify( a ); // "[2,3]"
    
    JSON.stringify( b ); // ""[2,3]""
```

在上例的第二个函数中，我们是对`toJSON`返回的`string`做字符串化，而非`array`本身，这可能并非是我们想要的结果。

借讨论`JSON.stringify(..)`的机会，我们在这里介绍几个不太为人知但却非常有用的功能。

我们可以向`JSON.stringify(..)`传递第二个参数，即可选参数（optional argument）*replacer*。它可以是`array`或者`函数`，通过某种过滤机制来指定哪些属性应该被处理和排除，然后对结果进行序列化，以此来实现对象递归序列化的定制，类似`toJSON()`。

如果`replacer`是一个`array`，那么它必须是一个`string``array`，其中包含序列化要处理的对象的属性名称。`array`之外的属性被忽略。

如果`replacer`是一个`函数`，它会对`object`本身调用一次，然后对`object`的每个属性调用一次，每次调用传递两个参数，`key`和`value`。如果要在序列化中忽略某个`key`，则返回`undefined`，否则返回指定的*值*。

```
    var a = { b: 42,
        c: "42",
        d: [1,2,3] 
    };
    
    JSON.stringify( a, ["b","c"] ); // "{"b":42,"c":"42"}"
    
    JSON.stringify( a, function(k,v){
        if (k !== "c") return v;
    } );
    // "{"b":42,"d":[1,2,3]}"
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><i>replacer</i>函数的key参数在第一次调用时为undefined（就是对对象本身调用时）。<b>if</b>语句将属性<b>"c"</b>排除掉。字符串化是递归的，因此数组<b>[1,2,3]</b>中的每个元素都通过参数<b>v</b>传递给*replacer*，参数<b>k</b>则是它们的索引值（0，1，和2）。</td>
    </tr>
</table>

`JSON.string`还可以带第三个参数，即可选参数*space*，它用来指定人性化输出的缩进。*space*值为正整数时是指定每一级缩进的字符数，该值还可以是`string`，此时最前面的10个字符会被用来作为每一级的缩进：

```
    var a = { 
        b: 42,
        c: "42",
        d: [1,2,3] 
    };
    
    JSON.stringify( a, null, 3 );
    // "{
￼   //      "b": 42,
    //      "c": "42",
    //      "d": [
    //          1, 
    //          2,
    //          3
    //      ]
    // }"

    JSON.stringify( a, null, "-----" );
    // "{
    // -----"b": 42,
    // -----"c": "42",
    // -----"d": [
    // ----------1,
    // ----------2,
    // ----------3
    // -----]
    // }"
```

请记住`JSON.stringify(..)`本身并不属于强制类型转换。在这里介绍它是因为它涉及到`ToString`强制类型转换，具体表现在以下两点：

1. 将`string`，`number`，`boolean`，和`null`等值字符串化为JSON，与通过`ToString`将它们强制类型转换为`stirng`效果是一样的。

2. 如果向`JSON.stringify(..)`函数传递定义了`toJSON()`方法的`object`，那么`toJSON()`方法会在字符串化之前被调用，将对象“强制类型转换”（类似于）为*安全的JSON值*。

####ToNumber

在有些情况下非`number`值需要被当作`number`来使用，比如数学运算。为此ES5规范在第9.3节定义了抽象操作`ToNumber`。

`true`转换为`1`，`false`转换为`0`。`undefined`转换为`NaN`，`null`转换为`0`。

`ToNumber`对`string`值的处理基本遵照`number`常量相关规则／语法（见`第三章`）。处理失败则返回`NaN`（在处理`number`常量失败时会产生语法错误）。另外`ToNumber`对以`0`开头的十六进制数并不按十六进制处理（而是按十进制，见`第二章`）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>数字常量</b>的语法规则与<b>ToNumber</b>对<b>字符串</b>的操作规则之间差别不大，这里不做进一步介绍，可参考ES5规范第9.3.1节。</td>
    </tr>
</table>

对象（以及数组）会首先被转换为相应的基本类型值，然后（返回结果为基本类型，但还不是`number`）再根据上述规则被强制转换为`number`。

为了进行基本类型值转换，抽象操作`ToPrimitive`（见ES5规范第9.1节）会首先（通过内部操作`DefaultValue`，见ES5规范第8.12.8节）检查待转换的值，看其是否包含`valueOf()`方法。如果有`valueOf()`并且返回的是基本类型值，则使用该值进行强制类型转换。如果没有`valueOf()`方法，则使用`toString()`的返回值（如果有的话）来进行强制类型转换。

如果两者均不返回基本类型值则产生`TypeError`错误。

从ES5开始，如果使用`Object.create(null)`来创建对象，则对象的`[[Prototype]]`为`null`，并且没有`valueOf()`和`toString()`方法，无法进行强制类型转换。详情请参考本系列的*《this & Object Prototypes》*一书中`[[Prototype]]`相关部分。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">我们稍后将详细介绍数字的强制类型转换，在下面的示例代码中我们假定函数Number(..)已经实现了此功能。</td>
    </tr>
</table>

例如：

```
    var a = {
        valueOf: function(){
            return "42";
        }
    };
    
    var b = {
        toString: function(){
            return "42";
        }
    };
    
    var c = [4,2];
    c.toString = function(){
        return this.join( "" ); // "42"
    };

    Number( a );            // 42
    Number( b );            // 42
    Number( c );            // 42
    Number( "" );           // 0
    Number( [] );           // 0
    Number( [ "abc" ] );    // NaN
```

####ToBoolean

下面将介绍JS中的`boolean`类型。关于这个话题存在着许多困惑和误解，值得我们高度重视。

首先也是最重要的一点是，JS有两个关键词`true`和`false`，分别代表`boolean`类型的真和假两个值。我们常误以为数值`1`和`0`分别等同于`true`和`false`。在有些语言中可能如此，而在JS中`boolean`和`number`是不同的。虽然我们可以将`1`强制类型转换为`true`（反之亦然），将`0`强制类型转换为`false`（反之亦然）。但它们本质上是不同的。

#####假值（Falsy values）

下面我们介绍其他值如何被强制类型转换为`boolean`值。

JavaScript中的值可以分为两类：

1. 可以被强制类型转换为`boolean`值`false`
2. 其他情况（可以被强制类型转换为`boolean`值`true`）

JS规范具体定义了一小撮可以被强制类型转换为`false`的值。

ES5规范第9.2节定义了抽象操作`ToBoolean`，其中列出了`boolean`强制类型转换所有可能的结果。

下面这些值我们称为假值（“falsy” values）：

- `undefined`
- `null`
- `false`
- `+0`，`-0`和`NaN`
- `""`

它们在`boolean`强制类型转换中为`false`。

按理说该列表以外的值应该会被转换为`true`，我们称为真值（“truthy” values）。但JS规范对此并没有明确定义，只给出了一些例子，比如明确规定所有对象都是真值，通常我们可以认为*所有不在假值列表中的值都是真值*。

#####假值对象（Falsy objects）

本节的标题似乎有点相互矛盾。前面介绍规范中规定所有对象都是真值，怎么还会有假值对象呢？

你可能会以为这是用来包装假值的封装对象（如：`""`，`0`，和`false`，见`第三章`），但实际不是这样。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这只是规范给我们开的一个小玩笑。</td>
    </tr>
</table>

例如：

```
    var a = new Boolean( false );
    var b = new Number( 0 );
    var c = new String( "" );
```

它们都是封装了假值的对象（见`第三章`）。那它们是`true`还是`false`呢？答案很简单：

```
    var d = Boolean( a && b && c );
    
    d; // true
```

`d`的值为`true`，所以它们都为`true`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">请注意Boolean(..)对<b>a &amp;&amp; b &amp;&amp; c</b>进行了封装，你可能会问为什么需要这样做。这里我们暂且记下，本章稍后会作说明。你可以不使用Boolean(..)，然后看看<b>d = a &amp;&amp; b &amp;&amp; c</b>的结果是什么。</td>
    </tr>
</table>

如果`假值对象`不是封装假值的对象，那它到底是什么玩意？

有趣的是我们虽然可以在代码中使用`假值对象`，但它实际上并不属于JavaScript语言。

在某些情况下，在JS语法之外，浏览器会自己创建一些*外来（exotic）*值，即“假值对象”。

“假值对象”看起来和普通对象一样（有属性等），但是将其强制类型转换为`boolean`值时会得到`false`。

不明觉厉！？

最常见的一个例子是`document.all`，它是一个类数组（array-like）对象，包含了页面上的所有元素，由*DOM*提供给JS代码使用（而非JS引擎提供）。在老版本的浏览器中它是一个真正意义上的对象，`boolean`强制类型转换为`true`值，但现在它是一个“假值对象”。

`document.all`是一个非标准用法，很早就被废止了。

我们也许会问：“既然这样，那浏览器能否将它彻底去掉？”，这个想法是好的，只是目前很多JS程序仍在使用它。

那为什么它要是假值（`falsy`）呢？因为我们经常用将`document.all`强制类型转换为`boolean`（比如在`if`语句中）的方法来检测浏览器是否是老版本的非IE浏览器。IE自诞生以来就一（cong）直 （wei）遵循浏览器标准，较其他浏览器更有（keng）力（die）地推动了Web的发展。

那些陈旧的`if(document.all) { /* it's IE */ }`依然存在于许多程序中，并且可能会一直存在下去。这些代码仍然假设自己运行在老版本的IE中，这对IE用户而言并非一个好的使用体验。

虽然我们无法彻底抛弃`document.all`，但为了让新版本更符合标准，IE并不打算继续支持`if (document.all) { .. }`。

“那我们应该拿它怎么办呢？”

“也许我们可以修改JS的类型机制，将`document.all`当作假值处理！”。

这并不是一个好办法。对于这个问题许多JS开发人员并不太了解，但如果我们对其放任自流只会让情况变得更糟。

现实很无奈。

#####真值

让我们回到真值列表。什么是真值？假值列表之外的都是真值。

例如：

```
    var a = "false";
    var b = "0";
    var c = "''";

    var d = Boolean( a && b && c );
    
    d;
```

你认为`d`的值应该是`true`还是`false`？

答案是`true`。虽然它们看起来象是`假值`，实际上`string`都是`真值`，除了`""`，它是`假值`列表中唯一的一个`string`。

再如：

```
    var a = [];             // empty array--truthy or falsy?
    var b = {};             // empty object--truthy or falsy?
    var c = function(){};   // empty function--truthy or falsy?

    var d = Boolean( a && b && c );
    
    d;
```

`d`仍然是`true`。为什么呢？还是同样的道理。`[]`，`{}`，和`function(){}`都不在`假值`列表中，因此它们都是`真值`。

换句话说，`真值`列表可以无限大，从而无法对其进行明确的定义，所以我们只能定义一个`假值`列表作为参考。

你可以花五分钟时间将`假值`列表写出来贴在显示器上，或者记在脑子里。这样遇到真／假值的时候就可以轻松做出判断。

真／假值的重点在于理解`boolean`强制类型转换（显式和隐式），之后我们就可以深入讨论强制类型转换实例。

####显式强制类型转换（Explicit Coercion）

显式强制类型转换是明确表示的类型转换，很多类型转换都属于此类。

我们力图将代码中的类型转换表达清楚，以免给别的开发人员留坑。代码越清晰可读性越高。

显式强制类型转换的好处毋庸置疑，它与我们所熟悉的静态语言的类型转换差不多，因而对它应该不存在什么争议，我们后面会再讨论这个话题。

#####字符串和数字之间的显式强制类型转换

让我们从最常见的`string`和`number`之间的强制类型转换开始。

`string`和`number`之间的转换使用的是`String(..)`和`Number(..)`这两个内建函数（我们称为“原生构造函数”，见`第三章`），值得注意的是它们前面没有`new`关键字，因此并不创建封装对象。

下面是两个类型之间的显式强制类型转换：

```
    var a = 42;
    var b = String( a );
    
    var c = "3.14";
    var d = Number( c );
    
    b; // "42"
    d; // 3.14
```

`String(..)`遵循前面介绍的`ToString`规则，将其他类型的值转换为`string`。`Number(..)`遵循前面介绍的`ToNumber`规则，将其他类型的值转换为`number`。

之所以将它们称为*显式*强制类型转换，是因为转换结果很明确地指定为某个类型。

实际上这和许多静态语言很相似。

例如在C/C++中，你可以使用`(int)x`或`int(x)`将值`x`转换为整数。大多数人喜欢后者，因为它看起来象一个方法调用。我们在JavaScript中使用`Number(x)`等也非常类似。至于它们是否真的是函数这个问题并不重要。

除了`String(..)`和`Number(..)`外，还有其他方法可以实现`string`和`number`之间的转换：

```
    var a = 42;
    var b = a.toString();
    
    var c = "3.14";
    var d = +c;

    b; // "42"
    d; // 3.14
```

`a.toString()`看起来非常显式（很明显“toString”表示“to a string”），不过它有一些隐蔽的隐式转换行为。因为`toString()`不能在`42`这样的基本类型值上使用，所以JS引擎会自动为`42`创建一个封装对象（见`第三章`），然后在该对象上调用`toString()`。这里的显式转换中含有隐式转换。

上例中`+c`是`+`运算符的*一元（unary，即只有一个操作数）*形式。`+`运算符显式地将操作数`c`转换为`number`，而非对其进行数学加法运算（也不是字符串拼接操作－－见下）。

那么`+c`是不是显式强制类型转换呢？这取决于我们自己的经验和理解。如果我们已经知道一元运算符`+`会将操作数显式强制类型转换为`number`，那么它就是显式的。如果我们不知道的话，它就是令人困惑的、有隐藏边缘效应的隐式强制类型转换。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">JS开源社区普遍认为一元运算<b>+</b>是显式强制类型转换。</td>
    </tr>
</table>

即使你已经很熟悉并喜欢`+c`这样的形式，在有些情况下它也会显得十分令人困惑。例如：

```
    var c = "3.14";
    var d = 5+ +c;

    d; // 8.14
```

一元运算符`-`和`+`类似，不过它还会将数字的符号位进行反转（flip）。我们不能使用两个`-`（--）来实现撤销反转，因为`--`会被当作递减运算符来处理。所以我们需要使用`- -"3.14"`这样的形式，在中间加一个空格，这样结果才是`3.14`。

下面是一个让人抓狂的例子：

```
    1 + - + + + - + 1;  // 2
```

我们应该极力避免一元运算符`+`（和`-`）和其他运算符相邻。上面的例子运行起来没问题，但并不是一个很好的做法。另外`d = +c`（和`d =+ c`）也很容易与`d += c`混淆起来，它们之间的区别大了去了。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">另一个非常容易混淆的情况是一元运算符和<b>++</b>及<b>--</b>相邻。例如<b>a +++b</b>，<b>a + ++b</b>，和<b>a + + +b</b>。有关<b>++</b>请参见<b>第125页“表达式的边缘效应”</b>。</td>
    </tr>
</table>

#####日期转换为数字

一元运算符`+`的另一个常见用途是将`日期`对象强制类型转换为`number`，因为其结果值是Unix时间戳格式，以微秒为单位（从1970年1月1日00:00:00 UTC起到现在的时间）：

```
    var d = new Date( "Mon, 18 Aug 2014 08:53:06 CDT" );

    +d; // 1408369986000
```

我们常用这种方式来获得当前时间的时间戳格式，例如：

```
    var timestamp = +new Date();
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">JavaScript中有一个特殊的语法，调用不带参数的构造函数时<b>()</b>是<i>可选</i>的。所以你可能会碰到<b> var timestamp = +new Date; </b>这样的写法。然而并非所有人都认为这样能让代码更易读，因为它只适用于<b> new fn() </b> 这样的情况，对一般的函数调用<b> fn() </b>并不适用。</td>
    </tr>
</table>

将`日期`对象转换为时间戳并非只有强制类型转换这一种方式。使用其他更显式的方式比较好些：

```
    var timestamp = new Date().getTime();
    // var timestamp = (new Date()).getTime();
    // var timestamp = (new Date).getTime();
```

从ES5开始使用静态方法`Date.now()`*更好*：

```
    var timestamp = Date.now();
```

为老版本浏览器polyfill `Date.now()`功能也很简单：

```
    if (!Date.now) {
        Date.now = function() {
            return +new Date();
        };
    }
```

建议不要对`日期`类型使用强制类型转换，而是使用`Date.now()`来获得当前时间戳，使用`new Date(..).getTime()`来获得指定时间的时间戳。

#####奇特的~运算符

`~`运算符（即字位操作“非”）也涉及强制类型转换，它令人费解，又常常被忽视。以至于理解它的开发人员也对其避而远之。秉承本书的一贯宗旨，让我们来深入探讨一下`~`有哪些用途。

在`第23页，“32位有符号整数”`一节中，我们说过字位运算符只适用于32位整数，即操作数会被强制使用32位表示。这是通过`ToInt32`抽象操作来实现的（ES5规范第9.5节）。

`ToInt32`首先进行`ToNumber`强制类型转换，如`"123"`将会首先被转换为`123`，然后再执行`ToInt32`。

当字位运算符（如`|`和`~`）和某些特殊`number`一起使用时会产生强制类型转换的效果，从而导致结果值为另一个`number`。

让我们先来看看`|`运算符（字位操作“或”）在空操作（no-op）`0 | x`中的情况，这时它仅执行`ToInt32`转换（在`第二章`介绍过）：

```
    0 | -0;         // 0
    0 | NaN;        // 0
    0 | Infinity;   // 0
    0 | -Infinity;  // 0
```

上面这些特殊数字无法以32位方式呈现（因为它们源自64位IEEE 754标准，见`第二章`），因此`ToInt32`对它们返回`0`。

至于`0 | ___`是`显式`还是`隐式`还有争议。根据规范，这毫无疑问是`显式`的，但如果对字位运算符没有理解到一定程度，它可能就是`隐式`的。考虑到本书的一致性，我们将其视为*显式*的。

让我们回到`~`。它首先将值“强制类型转换”为`32位数字`，然后执行字位操作“非”（反转每一个字位）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这和<b>!</b>很相像，它不仅将值强制类型转换为<b>boolean</b>，还对其做字位反转（见第83页上的“显式：*-->Boolean”）。</td>
    </tr>
</table>

我们为什么要特别介绍字位反转，这个主题太晦涩，JS开发人员也很少需要处理到字位级别。

对`~`的另外一种定义源自早先的计算机科学和离散数学：`~`得到二的补码。这样解释就清楚多了！

我们再来看看`~x`，它和`-(x+1)`基本相同。看起来奇怪，但也更容易理解一些：

```
    ~42;    // -(42+1) ==> -43
```

或许至此你仍未完全理解`~`，并且不明白为什么我们会把它放在强制类型转换一章中一并介绍，原因如下。

以`-(x+1)`为例。唯一能得到结果`0`（或者严格来说是`-0`）的`x`是哪个值？答案是`-1`。换句话说，如果输入值为`-1`，`~`和一组`number`一起能够得到一个假值`0`（能够被很简便地强制类型转换为`false`），否则则得到其他的真值`number`。

这和我们的讨论内容有什么关系？

`-1`通常被称为“哨位值”，意指一个值在其同类型值（`number`）中被赋予了特殊的含义。在C语言中我们用返回值`-1`来表示函数执行失败，用大于等于`0`的返回值来表示函数执行成功。

JavaScript在定义`string`操作`indexOf(..)`时也遵循此惯例，该操作在给定字符串中搜索一个子字符串，如果找到则返回子字符串的位置（从0开始），否则返回`-1`。

通常我们不仅使用`indexOf(..)`来获得子字符串的位置，也用它来检查`string`是否包含子字符串，相当于一个`boolean`判断。例如：

```
    var a = "Hello World";
    
    if (a.indexOf( "lo" ) >= 0) {   // true
        // found it!
    }
    if (a.indexOf( "lo" ) != -1) {  // true
        // found it }
    if (a.indexOf( "ol" ) < 0) {    // true
        // not found!
    }
    if (a.indexOf( "ol" ) == -1) {  // true
        // not found!
    }
```

`>= 0`和`== -1`这样的判断不是很好，属于“抽象渗漏”，就是在代码中暴露了底层的具体实现，即使用`-1`作为失败返回值这一实现细节，这些细节应该被隐藏。

现在我们明白`~`能起到什么作用了！`~`和`indexOf()`一起可以将结果“强制类型转换”（实际上是转换）为适当的`boolean`值：

```
    var a = "Hello World";
    
    ~a.indexOf( "lo" );         // -4 <-- truthy!
    
    if (~a.indexOf( "lo" )) {   // true
        // found it!
    }
    
    ~a.indexOf( "ol" );         // 0  <-- falsy!
    !~a.indexOf( "ol" );        // true
    
    if (!~a.indexOf( "ol" )) {  // true
        // not found!
    }
```

如果`indexOf(..)`返回值为`-1`，`~`将其转换为`假值0`，其他情况则转换为`真值`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>-(x+1)</b>似乎说明<b>~-1</b>的结果是<b>-0</b>，但实际上结果是<b>0</b>，因为它是字位操作而非数学运算。</td>
    </tr>
</table>

从技术角度来说，`if (~a.indexOf(..))`仍然是将`indexOf(..)`的返回结果进行*隐式*强制类型转换，`0`转换为`false`，其他情况为`true`。但总的来说`~`感觉更象*显式*强制类型转换，如果我们对它有足够了解的话。

个人认为`~`比`>= 0`和`== -1`更为简洁。

#####字位截除

有些开发人员会使用`~~`来截除`number`值的小数部分（例如将其转换为整数），他们觉得这与`Math.floor(..)`的效果一样，实际上并非如此。

`~~`是这样处理的，第一个`~`执行“强制类型转换”`ToInt32`并反转字位，然后第二个`~`再进行一次字位反转，即将所有字位反转回原来的状态。最后得到的是“强制类型转换”`ToInt32`（也叫做截除，truncation）的结果值。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>~~</b>和<b>!!</b>很相似，我们在<b>第83页的“显式：*-->Boolean”</b>中介绍。</td>
    </tr>
</table>

对于`~~`我们要多加注意。首先它仅适用于32位数值。更重要的是它对负数的处理结果与`Math.floor(..)`不同。

```
    Math.floor( -49.6 );    // -50
    ~~-49.6;                // -49
```

抛开它们之间的差异不谈，`~~x`能够将值截除为一个32位整数。`x | 0`同样也可以，并且看起来还更简洁一些。

那我们为什么倾向于用`~~x`而不是`x | 0`呢？这是出于运算符优先级（详见`第五章`）的考虑：

```
    ~~1E20 / 10;        // 166199296
    1E20 | 0 / 10;      // 1661992960
    (1E20 | 0) / 10;    // 166199296
```

建议在完全掌握`~`和`~~`之后再使用它们来进行显式强制类型转换。

#####显式：解析数字字符串

解析`string`中的`number`也能够达到将`string`强制类型转换为`number`的效果。但这和我们之前介绍过的方法还是有很大区别。

例如：

```
    var a = "42";
    var b = "42px";

    Number( a );    // 42
    parseInt( a );  // 42
    
    Number( b );    // NaN
    parseInt( b );  // 42
```

解析`string`中的`number`时允许字符串含有非数字字符，按从左自右的顺序，如果遇到非数字字符则解析停止。然而强制类型转换不允许非数字字符，否则会失败并返回`NaN`。

字符串解析和强制类型转换之间并非替代关系。它们虽然相似，但用途不同。如果字符串右边的非数字字符可以被忽略，那么使用字符串解析没有问题。而将`string`强制类型转换为`number`则要求字符串中所有的字符都是数字，象"42px"这样的非数字字符串是不行的。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">
            <b>parseInt(..)</b>之外还有一个解析函数parseFloat(..)，即解析字符串中的浮点数。
        </td>
    </tr>
</table>

请记住，`parseInt(..)`针对的是字符串值。向`parseInt(..)`传递数字和其他类型的参数是没有意义的，比如：`true`，`function(){...}`，和`[1,2,3]`。

非字符串参数会首先被强制类型转换为`string`（见`第59页上的“ToString”`），显然这是*隐式*强制类型转换，并非很好的编码风格，所以应该避免向`parseInt(..)`传递非字符串参数。

在ES5之前，`parseInt(..)`有一个不太为人知的特性，导致了很多bug。如果没有第二个参数来指定转换基数（也叫做radix），`parseInt(..)`将根据字符串的第一个字符来自己决定使用哪个基数。

如果第一个字符是`x`或`X`，则将字符串转换为十六进制数字。如果第一个字符是`0`，则转换为八进制数字。

十六进制数字（以'x'或者'X'开头）不是很容易搞混，八进制数字则不然。例如：

```
    var hour = parseInt( selectedHour.value );
    var minute = parseInt( selectedMinute.value );
    
    console.log(
       "The time you selected was: " + hour + ":" + minute
);
```

上面的代码看似没有问题。但是当小时数为`08`、分钟数为`09`时返回结果为`0:0`，因为`8`和`9`都不是有效的八进制数。

ES5之前这个问题很容易解决，同时也很容易被忽略，即*总是将第二个参数设置为10*：

```
    var hour = parseInt( selectedHour.value, 10 );
    var minute = parseInt( selectedMiniute.value, 10 );
```

从ES5开始，除非另行指定，否则`parseInt(..)`默认转换为十进制数。如果代码要在ES5之前的环境下运行，我们还是要注意将第二个参数设置为`10`。

#####对非字符串的解析

`parseInt(..)`有一个地方恶名在外，曾经有个恶搞帖专门针对它：

```
    parseInt( 1/0, 19 ); // 18
```

我们想当然地认为（实际上是完全错误的）“如果传递`Infinity`参数，那么解析结果也应该是`Infinity`而非`18`”。返回`18`也太搞了。

抛开这个纯属杜撰的例子不谈，让我们来看看JS是否真有这么搞。 

首先，上例中的第一个错误是向`parseInt(..)`传递了一个非字符串，这完全是在自找麻烦。这时JS会将参数强制类型转换为它能够处理的`string`。

有人可能会觉得这样做没有道理，`parseInt(..)`应该拒绝接受非字符串参数。那么它是不是应该抛出一个错误呢？这是Java的做法。一想到JS代码中到处是抛出的错误，必须用`try..catch`来处理时，我整个人都不好了。

那么它是不是应该返回`NaN`？或许是，但是对于下面的情况又怎么办：

```
    parseInt( new String( "42") );
```

是否应该运行失败？因为它也是一个非字符串参数。如果我们认为这个字符串封装对象会被拆解（unbox）为`"42"`，那么将数字`42`首先转换为`"42"`，然后再解析为`42`不是很正常吗？

我个人认为这样半显式、半隐式的强制类型转换很多时候是非常有用的。例如：

```
    var a = {
        num: 21,
        toString: function() { return String( this.num * 2 ); }
    };

    parseInt( a ); // 42
```

`parseInt(..)`将参数强制类型转换为字符串然后进行解析是合情合理的。就如同垃圾箱里充满了垃圾并非垃圾箱本身的问题，因为垃圾是我们自己扔进去的。

那么`Infinity`（`1/0`的计算结果）应该被强制类型转换成什么最为合理呢？我只想到两种可能：`"Infinity"`和`"∞"`，JS选择了`"Infinity"`，很好。

JS中所有的值都有一个对应的字符串表示，能够方便我们调试。

现在我们来看看基数19是怎么回事？显然这纯属虚构，在实际的JS代码中不会用到基数19。对于基数19来说，有效的数字字符是`0-9`和`a-i`（区分大小写）。

回到例子`parseInt(1/0, 19)`。它实际上是执行`parseInt("Infinity", 19)`。第一个字符是"I"，以19为基数时的值为`18`。第二个字符`"n"`不是一个有效的数字字符，解析到此停止，和解析`"42px"`中的`"p"`情况一样。

结果是什么呢？是`18`，而不是`Infinity`或者产生`错误`。理解了它的运行机制之后，我们发现得到这个结果非常合乎情理。

下面是其他一些有关`parseInt(..)`的看起来奇怪但却合乎情理的例子：

```
    parseInt( 0.000008 );       // 0   ("0" from "0.000008")
    parseInt( 0.0000008 );      // 8   ("8" from "8e-7")
    parseInt( false, 16 );      // 250 ("fa" from "false")
    parseInt( parseInt, 16 );   // 15  ("f" from "function..")
    
    parseInt( "0x10" );         // 16
    parseInt( "103", 2 );       // 2
```

事实上`parseInt(..)`的运行方式是前后一致并且可预测的。使用得当的话返回结果都不会有问题。如果由于使用不当而导致一些莫名其妙的结果，并不能归咎于JavaScript本身。

#####显式：*-->Boolean

现在让我们来看一看从非`boolean`值强制类型转换为`boolean`值的情况。

和前面介绍过的`String(..)`和`Number(..)`一样，`Boolean(..)`（没有new关键字）是一种显式的`ToBoolean`强制类型转换：

```
    var a = "0";
    var b = [];
    var c = {};

    var d = "";
    var e = 0;
    var f = null;
    var g;
    
    Boolean( a ); // true
    Boolean( b ); // true
    Boolean( c ); // true
    
    Boolean( d ); // false
    Boolean( e ); // false
    Boolean( f ); // false
    Boolean( g ); // false
```

虽然`Boolean(..)`是显式的，但却并不常见。

就象一元运算符`+`将值强制类型转换为数字（见前面的介绍），一元运算符`!`显式地将值强制类型转换为`boolean`。*问题*是它同时还将正值反转为负值（或者反之）。所以JS开发人员经常使用`!!`运算符将值显式强制类型转换为`boolean`值，因为第二个`!`会将结果反转为原值：

```
    var a = "0";
    var b = [];
    var c = {};

    var d = "";
    var e = 0;
    var f = null;
    var g;

    !!a; // true
    !!b; // true
    !!c; // true

    !!d; // false
    !!e; // false
    !!f; // false
    !!g; // false
```

在`if(..)..`这样的`boolean`上下文中，如果不使用`Boolean(..)`和`!!`，上述的`ToBoolean`转换都是隐式的。为了让这些地方更加清晰，我们使用`Boolean(..)`和`!!`来进行显式转换。

`ToBoolean`的另外一个例子，是在JSON序列化过程中将值强制类型转换为`true`或`false`：

```
    var a = [ 1,
            function(){ /*..*/ },
            2,
            function(){ /*..*/ }
    ];

    JSON.stringify( a ); // "[1,null,2,null]"

    JSON.stringify( a, function(key,val){
        if (typeof val == "function") {
            // force `ToBoolean` coercion of the function
            return !!val;
        }
        else {
            return val;
    } } );
    // "[1,true,2,true]"
```

如果你熟悉Java的话可能知道下面这样的语法：

```
    var a = 42;

    var b = a ? true : false;
```

三元运算符`? :`判断条件是否为真，如果为真则将变量b赋值`true`，否则赋值`false`。

表面上这是一个*显式*的`ToBoolean`强制类型转换，因为返回结果是`true`或者`false`。

然而其中含有*隐式*强制类型转换，因为表达式首先必须被强制类型转换为`boolean`以便进行判断。我将其称为“显式的隐式”。建议大家不要写这样的代码，它非但没有任何好处，有时还会造成误解。

用`Boolean(a)`和`!!a`来进行显式强制类型转换要好得多。

####隐式强制类型转换

*隐式*强制类型转换指的是那些隐蔽的类型转换，其边缘效应（side effects）也不是很明显。换而言之，任何你觉得不明显的类型转换都是*隐式*类型转换。

*显式*强制类型转换旨在让代码更加清晰易读，而*隐式*强制类型转换则恰恰相反，会让代码更加晦涩难懂。

从表面上看这是强制类型转换最为人诟病的地方。对“JavaScript强制类型转换”的抱怨针对的大都是*隐式*强制类型转换。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><i>《JavaScript: The Good Parts》</i>的作者Douglas Crockford在许多场合和文章中都主张尽量不要使用JavaScript强制类型转换。在他看来<i>隐式</i>强制类型转换是很糟糕的。然而如果我们看看他的代码就会发现，他也使用了许多<i>隐式</i>和<i>显式</i>强制类型转换。事实上他的抱怨大都来自于<b>==</b>运算符，但在本章中你会发现这仅仅是强制类型转换的冰山一角。</td>
    </tr>
</table>

那么问题来了，隐式强制类型转换真有这么糟糕和危险吗？它是JavaScript语言的设计缺陷吗？我们应该对它退避三舍吗？

也许大部分读者会毫不犹豫地回答“是！”。

其实不然，请听我细细道来。

让我们从另一个角度来看看*隐式*强制类型转换是怎么回事，应该如何使用，而不是仅仅将其看作“显式强制类型转换的对立面”，这样理解太过狭隘，忽略了它们之间一个重要细微的差别。

*隐式*强制类型转换的目是减少代码冗余。

#####隐式简化

首先让我们来看看下面这个例子，它不是JavaScript代码，而是某种强类型语言的伪代码：

```
    SomeType x = SomeType( AnotherType( y ) )
```

上例中变量`y`的值被转换为`SomeType`类型。问题是该语言无法直接将`y`转换为`SomeType`。它需要一个中间步骤，首先将其转换为`AnotherType`类型，然后再从`AnotherType`转换为`SomeType`。

如果我们可以这样来写这段代码：

```
    SomeType x = SomeType( y )
```

这样省去了中间步骤，类型转换变得更简洁了。因为变量`y`在转换为`SomeType`类型之前先转换为`AnotherType`类型这一步骤并不一定要展现在代码中。

有人或许仍持有异议。但是我认为通过语言本身或者自定义方法来抽象和隐藏一些琐碎的细节，对于*提高代码可读性*来说是很有必要的。

虽然这些中间步骤仍然会存在于幕后的某处。但是如果我们在代码中隐藏了这些琐碎的细节，就可以只关注问题本身，即将变量`y`转换为`SomeType`类型。

虽然JS的隐式强制类型转换与上例并非完全是一码事，但是本章中我想表达的观点是，*隐式*强制类型转换同样能够提高代码可读性。

但凡事无绝对，*隐式*强制类型转换也会带来一些负面影响，有时甚至大过它带来的好处。因此我们更应该学习如何避免这些不好的东西。

许多开发人员认为如果某个机制能够带来好处*A*但是同时又有坏处*Z*，为了保险起见就干脆别碰。

我不同意这种“因噎废食”的想法。不要因为你看到的都是负面影响而想当然地认为*隐式*强制类型转换一无是处。它也有好的方面，希望越来越多的人能够发现并接受它。

#####隐式：字符串 <--> 数字

前面我们介绍了`string`和`number`之间的*显式*强制类型转换。现在让我们来看看它们之间的*隐式*强制类型转换。不过开始之前我们需要了解一些引发*隐式*强制类型转换的操作。

通过重载（overload），`+`运算符同时支持`number`的加法和`string`的拼接。那么JS如何知道我们要执行哪种操作呢？例如：

```
    var a = "42";
    var b = "0";

    var c = 42;
    var d = 0;
    
    a + b; // "420"
    c + d; // 42
```

为什么我们会得到`"420"`和`42`这两个不同的结果？通常的理解是因为某一个或者两个操作数为`string`，所以`+`进行`string`拼接。这样理解只对了一半，实际情况要复杂得多。

例如：

```
    var a = [1,2];
    var b = [3,4];

    a + b; // "1,23,4"
```

两个操作数都不是`string`，但是它们都被强制转换为`string`然后进行拼接。这是为什么呢？

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">下面两个段落是规范中有关该问题的详细解释，如果觉得太难理解可以跳过。</td>
    </tr>
</table>

根据ES5规范第11.6.1节，如果某个操作数为`string`，或者能够通过以下步骤得到`string`值的话，`+`将进行拼接操作。如果`+`的其中一个操作数为`object`（包括`array`），它首先对该操作数调用`ToPrimitive`抽象操作（第9.1节），该抽象操作接着调用`[[DefaultValue]]`（第8.12.8节），以`number`作为上下文。

如果我们多加留意会发现该操作和`ToNumber`抽象操作处理`object`的方式一样（见`第65页“ToNumber”`）。因为`array`的`valueOf()`操作无法产生简单基本类型值，所以它转而调用`toString()`来得到`string`值。因此上例中的两个数组变成了`"1,2"`和`"3,4"`。`+`将这两个`string`拼接起来产生你要的结果：`"1,23,4"`。

简而言之就是，如果`+`其中一个操作数是`string`（或者通过以上步骤可以产生`string`值），则执行`string`拼接。否则执行`number`加法。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">一个常被提及的强制类型转换陷阱是<b>[] + {}</b>和<b>{} + []</b>，它们的结果不同，分别是"[object Object]"和0。我们将在<b>第134页的“块”一节</b>详细介绍。</td>
    </tr>
</table>

对于*隐式*强制类型转换来说这意味着我们可以通过将`number`和空字符串`""`相加来将其转换为`string`：

```
    var a = 42;
    var b = a + "";
    
    b; // "42"
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;"><b>+</b>在数字加法操作中是可互换的，即<b>2 + 3</b>等同于<b>3 + 2</b>。<b>+</b>在字符串拼接操作中则不是这样，但是对于空字符串""来说，<b>a + ""</b>和<b>"" + a</b>的结果是一样的。</td>
    </tr>
</table>

通过`a + ""`这样的方式将`number`*隐式*强制类型转换为`string`非常常见。有趣的是许多诟病隐式强制类型转换的人也这样做，而不是使用*显式*强制类型转换。

这很能说明问题，不管*隐式强制类型转换*如何被诟病，也仍然有它适用的地方。

我们来比较一下`a + ""`（隐式）和之前介绍过的`String(a)`（显式），两者之间有一个细微的差别需要注意。根据`ToPrimitive`抽象操作的工作原理，`a + ""`中会对`a`调用`valueOf()`方法，其返回值通过`ToString`抽象操作转换为`string`。而`String(a)`中则是直接调用`ToString()`。

两者最后都返回一个`string`值，但是如果值不是`number`基本类型而是`object`，就有可能得到另外的结果！

例如：

```
    var a = {
        valueOf: function() { return 42; },
        toString: function() { return 4; }
    };
    
    a + ""; // "42"
    
    String( a );    // "4"
```

通常如果代码中没有这些令人费解的数据结构和操作的话，是不太可能碰到这个问题的，但是如果我们对某些对象自定义了`valueOf()`和`toString()`方法，就需要特别小心，因为这会影响到强制类型转换的结果。

那么反过来从`string`强制类型转换为`number`又如何呢？

```
    var a = "3.14";
    var b = a - 0;
    
    b; // 3.14
```

运算符`-`只应用于数字减法，因此`a - 0`会将`a`强制类型转换为`number`。`a * 1`和`a / 1`也能得到相同的结果，因为这两个运算符也只能用于数字，只不过这种方式很少见。

那么对`object`执行`-`操作会怎样呢？和`+`类似：

```
    var a = [3];
    var b = [1];
    
    a - b; // 2
```

上面两个数组都会被转换为`number`，但首先它们会被转换为`string`（通过`toString()`），然后再转换为`number`，以便减法运算符`-`能够执行。

所以`string`和`number`之间的*隐式*强制类型转换真如传说中的那样糟糕吗？我并不这样认为。

我们来比较一下`b = String(a)`（*显式*）和`b = a + ""`（*隐式*），两者都有各自的用处，`b = a + ""`更为常见一些，所以无论怎样备受争议，*隐式*强制类型转换仍然有它的用武之地。

#####隐式：布尔值-->数字

*隐式*强制类型转换在有种情况下非常有用，就是将一些复杂的`boolean`逻辑转换为数字加法。当然这并不常见，但是特殊情况需要特殊处理。

例如：

```
    function onlyOne(a,b,c) {
        return !!((a && !b && !c) ||
            (!a && b && !c) || (!a && !b && c));
    }
    
    var a = true;
    var b = false;
    
    onlyOne( a, b, b ); // true
    onlyOne( b, a, b ); // true
    
    onlyOne( a, b, a ); // false
```

如果其中有且仅有一个参数为`true`（或者为真值），则函数`onlyOne(..)`返回`true`。它在判断是否为真时使用了*隐式*强制类型转换，其他地方则是*显式*的，包括最后的返回值。

如果该函数需要处理四个、五个、或者二十个参数，就很难用上面的代码来实现了。

这时我们就可以使用从`boolean`到`number`（`0或1`）的强制类型转换：

```
    function onlyOne() {
        var sum = 0;
        for (var i=0; i < arguments.length; i++) {
            // skip falsy values. same as treating
            // them as 0's, but avoids NaN's.
            if (arguments[i]) {
        sum += arguments[i];
    }
    }
        return sum == 1;
    }
   
    var a = true;
    var b = false;
   
    onlyOne( b, a );                // true
    onlyOne( b, a, b, b, b );       // true
   
    onlyOne( b, b );                // false
    onlyOne( b, a, b, b, b, a );    // false
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">除了在<b>onlyOne(..)</b>中使用loop循环，我们也可以直接使用ES5规范中的reduce(..)函数，上例只是为了说明问题。</td>
    </tr>
</table>

上例中我们累加真值（true/truthy）强制类型转换的结果`1`。`sum += arguments[i]`中涉及*隐式*强制类型转换。如果有且仅有一个参数为`true`，累加结果为`1`，否则结果不为`1`，`if`条件不成立。

同样的方法也可以通过*显式*强制类型转换来实现：

```
    function onlyOne() {
        var sum = 0;
        for (var i=0; i < arguments.length; i++) {
            sum += Number( !!arguments[i] );
        }
        return sum === 1;
    }
```

首先通过`!!arguments[i]`将值强制类型转换为`true`或`false`。因此我们可以传递非`boolean`参数，如：`onlyOne("42", 0)`也是可以的（否则会返回`string`拼接结果，这样结果就不对了）。

将参数转换为`boolean`后，再通过`Number(..)`进行*显式*强制类型转换以确保返回值为`0`或`1`。

在这里用*显式*强制类型转换是不是更好些？代码注释中说这样的确能够避免`NaN`带来的问题。但这最终取决于我们自身的需要。我觉得前者，即*隐式*强制类型转换，更为简洁（前提是我们不会传递`undefined`和`NaN`这样的值），而*显式*强制类型转换会带来一些冗余。

总之如本书一贯强调的那样，一切都取决于我们自己的判断和权衡。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">无论是<i>隐式</i>还是<i>显式</i>强制类型转换，我们都能轻易地修改<b>onlyTwo(..)</b>或者<b>onlyFive(..)</b>来处理更多的情况，只需要将最后的比较从<b>1</b>改为<b>2</b>或者<b>5</b>。这比加入一大堆<b>&amp;&amp;</b>和<b>||</b>表达式要简洁的多。所以强制类型转换在这里是很有用的。</td>
    </tr>
</table>

#####隐式：**-->布尔值

现在让我们来看看到`boolean`的*隐式*强制类型转换，它最为常见，也最容易出错。

请记住这其中涉及的是*隐式*强制类型转换。对于`number`和`string`操作来说这个转换很明显。

下面这些操作涉及到`boolean`的*隐式*强制类型转换：

1. `if (..)`语句中的条件判断表达式
2. `for ( .. ; .. ; .. )`语句中的条件判断表达式（第二个）
3. `while (..)`和`do..while(..)`循环中的条件判断表达式
4. `? :`中的条件判断表达式
5. 逻辑运算符`||`（逻辑或）和`&&`（逻辑与）左边的操作数（作为条件判断表达式）。

以上情况中的值如果不是`boolean`，则会被*隐式*强制类型转换为`boolean`，根据本章之前介绍过的`ToBoolean`抽象操作规则。

例如：

```
    var a = 42;
    var b = "abc";
    var c;
    var d = null;
    
    if (a) {
        console.log( "yep" );   // yep
    }

    while (c) {
        console.log( "nope, never runs" );
    }

    c = d ? a : b; 
    c;                          // "abc"
    
    if ((a && d) || c) {
        console.log( "yep" );   // yep
    }
```

上面的例子中，非`boolean`值会被*隐式*强制类型转换为`boolean`值，以便进行条件判断。

#####||和&&运算符

你可能已经在其他语言中见过`||`（逻辑或）和`&&`（逻辑与）运算符，所以自然而然地认为它们在JavaScript中的工作原理与在其他语言中一样。

然而其中有一个十分重要，却不太为人所知的细微差别。

实际上我不太赞成将它们称为“逻辑运算符”，因为这并不能完全体现它们的功能。如果可以用更精确（也更冗长）的词来描述，我会用“选择器运算符（selector operators）”，或者“操作数选择器运算符（operand selector operators）”。

原因是和其他语言不同，JavaScript中它们的返回值并不是`boolean`。

它们的返回值是其两个操作数中的一个（且仅一个）的值。换句话说，就是它们选择其两个操作数中的一个，然后返回它的值。

这里我们引述ES5规范的第11.11节：

*&&和||运算符的返回值并不一定是`boolean`类型，而是两个操作数其中的一个的值。*

举个例子：

```
    var a = 42;
    var b = "abc";
    var c = null;

    a || b;     // 42 
    a && b;     // "abc"
    
    c || b;     // "abc" 
    c && b;     // null
```

这是什么情况？在C和PHP这样的编程语言中，以上表达式返回`true`或`false`，而JS（以及Python和Ruby）返回的是操作数的值。

`||`和`&&`运算符首先会对*第一个操作数*（`a`和`c`）进行`boolean`条件判断。如果它不是`boolean`值（如上例）则执行`ToBoolean`强制类型转换，以便执行条件判断。

对于`||`运算符来说，如果条件判断结果为`true`，`||`表达式返回第一个操作数（`a`和`c`）的值。如果条件判断结果为`false`则返回第二个操作数（`b`）的值。

相反，对于`&&`操作数，如果条件判断结果为`true`，`&&`表达式返回第二个操作数（`b`）的值。如果条件判断结果为`false`则返回第一个操作数（`a`和`c`）的值。

`||`和`&&`运算符的返回值是它们其中一个操作数的值，而非条件判断的结果值（可能涉及强制类型转换）。如`c && b`, `c`为`null`，是个假值。因而`&&`表达式的返回结果是`null`（即`c`的值），而非条件判断的结果`false`。

现在你理解为什么称它们为“操作数选择器”了吧？

从另一个角度来理解：

```
    a || b;
    // roughly equivalent to:
    a ? a : b;

    a && b;
    // roughly equivalent to:
    a ? b : a;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">之所以说<b>a || b</b>大致等价于（roughly equivalent）<b>a ? a : b</b>是因为它们的返回结果相同，但是它们之间存在一个细微的差别。在<b>a ? a : b</b>中，如果<b>a</b>是更为复杂一些的表达式（比如：一个有边缘效应的函数调用，等等），则<b>a</b>表达式有可能被执行两次（如果第一次结果为真）。相反，对于<b>a || b</b>，表达式只会执行一次，其结果值会被用于条件判断以及返回值（如果适用的话）。<b>a &amp;&amp; b</b>和<b>a ? b : a</b>也一样。</td>
    </tr>
</table>

下面是一个常见用例，你可能已经用到过但仍然是一知半解：

```
    function foo(a,b) {
        a = a || "hello";
        b = b || "world";
     
        console.log( a + " " + b );
    }

    foo();                  // "hello world"
    foo( "yeah", "yeah!" ); // "yeah yeah!"
```

我们通过`a = a || "hello"`这样的方式（也叫做C#中“空合并运算符，null coallescing operator”的JavaScript版本）来检查变量`a`，如果它未被赋值（或者为假值），就赋予它一个缺省值（`"hello"`）。

有一点需要注意！

```
    foo( "That's it!", "" ); // "That's it! world" <-- Oops!
```

知道问题出在哪里吗？第二个参数`""`是一个`假值`（`falsy value`，见`第67页上的“ToBoolean”`），因此`b = b || "world"`条件判断结果为假，返回缺省值`"world"`。

`||`这样的用法很常见，但我们要避免传递`假值`，否则就需要在条件判断中写清楚，或者换而使用`? :`三元表达式。

通过这样的方式来设置`缺省值`很普遍，也很实用。甚至那些公开诟病JavaScript强制类型转换的开发人员也在使用。

`&&`的情况又如何？

有一种方式对于开发人员不太常见，但经常被JS代码压缩工具使用。即如果第一个操作数为真值，`&&`运算符“选择”第二个操作数的值作为返回值，这种方式也称为“守护运算符”（见`第五章``第140页的“短路”`），第一个表达式“守护”第二个表达式：

```
    function foo() {
        console.log( a );
    }
    
    var a = 42;
    
    a && foo(); // 42
```

只有在`a`条件测试通过的时候`foo()`才会被调用。如果条件测试不通过，`a && foo()`语句就会默默地终止（也称为“短路，short circuiting”），`foo()`不会被调用。

对于开发人员来说这样的用法不太常见，通常我们会使用`if (a) { foo(); }`。但是JS代码压缩工具会使用`a && foo()`，因为它更精简。以后我们如果再看到这样的代码就能知其所以然了。

`||`和`&&`还是很有用的，前提是我们能够理解并愿意在代码中使用*隐式*强制类型转换。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>a = b || "something"</b>和<b>a &amp;&amp; b()</b>中使用到了“短路”机制，我们将在第五章第140页的“短路”一节中详细介绍。</td>
    </tr>
</table>

可能你还有疑问，因为`if`和`for`中包含`a && (b || c)`这样的表达式也没出现问题。

这些代码（或许）真的没有问题。唯一的问题是你不知道那些复合条件表达式在执行之后还涉及一个`boolean`*隐式*强制类型转换的步骤。

例如：

```
    var a = 42;
    var b = null;
    var c = "foo";
    
    if (a && (b || c)) {
        console.log( "yep" );
    }
```

以上代码的执行结果和我们预期的一样，除了一处细节，`a && (b || c)`表达式的返回值实际上是`"foo"`，而非`true`。随后由`if`表达式将`foo`强制类型转换为`boolean`，最后结果为`true`。

现在明白了吧？你的代码很可能不会有问题，并且你也知道其中的原因了。

现在我们知道了这些地方涉及`隐式`强制类型转换。如果不想使用（隐式）强制类型转换，代码就得这样写：

```
    if (!!a && (!!b || !!c)) {
        console.log( "yep" );
    }
```

#####Symbol强制类型转换

*显式*和*隐式*强制类型转换的返回结果并没有什么不同，它们的差异仅体现在代码可读性方面。

但是ES6中的symbols带来了一个容易出错的地方，需要在这里简单介绍一下。ES6允许`symbol`到`string`的*显式*强制类型转换，然而相应的*隐式*强制类型转换则会产生`错误`，具体的原因不在本书讨论范围之内。

例如：

```
    var s1 = Symbol( "cool" );
    String( s1 );     // "Symbol(cool)"
   
    var s2 = Symbol( "not cool" );
    s2 + "";      // TypeError
```

`Symbol`值不能被强制类型转换为`number`（`显式`和`隐式`都会产生`错误`），但可以被强制类型转换为`boolean`（`显式`和`隐式`都行，结果均为`true`）。

由于规则缺乏一致性，我们需要对ES6 `symbol`值的强制类型转换多加点小心。

幸运的是，鉴于`symbol`的用途（见`第三章`），我们不太可能经常用到`symbol`值的强制类型转换。

####宽松相等和严格相等

宽松相等（loose equals）运算符`==`和严格相等（strict equals）运算符`===`均用于判断两个值是否“相等”，但是宽松相等和严格相等在判断条件上有一个非常重要的区别。

一个极为常见的误区是：“`==`检查值是否相等，`===`检查值和类型是否相等”。听起来很有道理，但是不准确。很多颇有口碑的JavaScript书籍和博客也是这样解释的，不幸的是他们都*错*了。

正确的解释是：“在相等比较中，`==`允许强制类型转换，而`===`不允许”。

#####相等比较操作的性能

我们来看一看第一种解释（不准确）和第二种解释（准确）之间的区别。

第一种解释中，`===`似乎比`==`做的事情多一些，因为它还需要检查值的类型。第二种解释中，`==`的工作量更大，因为如果值的类型不同还需要进行强制类型转换。

很多人觉得`==`比`===`执行得更慢，实际上虽然强制类型转换确实要多花费点时间，但也仅是微秒级（100万分之一秒）。

如果进行比较的两个值类型相同，`==`和`===`就使用相同的算法，所以除了JS引擎实现上细微的差别之外，它们之间并没有不同。

如果进行比较的两个值类型不同，我们需要考虑的是有没有必要进行强制类型转换，而非性能。

如果需要强制类型转换就使用`==`宽松相等运算符，如果不需要就使用`===`严格相等运算符。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>==</b>和<b>===</b>都会检查操作数的类型。区别在于当操作数类型不同时，它们各自的处理方式不同。</td>
    </tr>
</table>

#####抽象相等

ES5规范中第11.9.3节“抽象相等比较算法”定义了`==`运算符的工作机制。这是一个简单而全面的算法，涵盖了所有可能出现的类型组合情况，以及每种情况下强制类型转换的执行方式。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">这些“抽象相等”规则导致<i>隐式</i>强制类型转换被诟病为过于复杂以及容易出错。开发人员觉得它们太晦涩，很难掌握和使用，其带来的坏处（导致bug）多过好处（提高代码可读性）。这样的观点我不敢苟同，因为本书的读者都是优秀的开发人员，整天与算法和代码打交道，掌握“抽象相等”简直是小菜一碟。不过我还是推荐大家看一下ES5规范的11.9.3节，你会发现其中说的很有道理。</td>
    </tr>
</table>

其中第一段（11.9.3.1）规定如果比较的两个值类型相同，就只比较它们的值是否相等。例如，`42`等于`42`，`"abc"`等于`"abc"`。

有几处小例外需要注意：

- `NaN`不等于`NaN`（见`第二章`）。
- `+0`等于`-0`（见`第二章`）。 

11.9.3.1的最后一段定义了针对`object`（包括`function`和`array`）的宽松相等`==`。当两个对象指向同一个值时它们才算相等。这里不涉及强制类型转换。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">严格相等<b>===</b>的定义和11.9.3.1一样，包括两个对象的相等比较。有一点不太为人所知，即在比较两个对象的时候，<b>==</b>和<b>===</b>的工作原理是一样的。</td>
    </tr>
</table>

11.9.3中还规定，如果使用`==`来比较两个不同类型的值，这些值（一个或两个）会进行*隐式*强制类型转换，以便成为相同的类型，然后再进行相等比较。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>!=</b>宽松不相等（loose not-equality）的定义和我们设想的一样，即<b>==</b>的相反值。<b>!==</b>也是同理。</td>
    </tr>
</table>

#####字符串和数字之间的相等比较

为了举例说明`==`的强制类型转换，我们先来看看本章之前介绍过的`string`和`number`的例子：

```
    var a = 42;
    var b = "42";

    a === b;    // false
    a == b;     // true
```

不出意料，`a === b`为`false`，因为其中不涉及强制类型转换，`42`和`"42"`两个值不相等。

而`a == b`是宽松相等，即如果两个值的类型不同，则对其中之一或两者进行强制类型转换。

这里涉及的强制类型转换是怎样的呢？是`a`从`42`转换为`string`，还是`b`从`"42"`转换为`number`？

ES5规范11.9.3.4-5中是这样定义的：

```
1. 如果Type(x)是数字，Type(y)是字符串，则返回x == ToNumber(y)的结果。
2. 如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x) == y的结果。
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">规范中使用<b>Number</b>和<b>String</b>代表数字和字符串类型，而本书使用<b>number</b>和<b>string</b>。切勿将规范中的<b>Number</b>和原生函数<b>Number()搞混</b>。本书中首字符大写的类型名和小写的是一回事。</td>
    </tr>
</table>

规范中明确规定字符串`"42"`被强制类型转换为`number`以便进行相等比较。前面我们已经介绍过强制类型转换的规则，特别是`ToNumber`抽象操作规则。所以本例中两个值相等，均为`42`。

#####其他类型和布尔类型之间的相等比较

`true`和`false`与其他类型之间的相等比较是宽松相等`==`中的*隐式*强制类型转换最容易出错的地方之一。

例如：

```
    var a = "42";
    var b = true;

    a == b; // false
```

这是怎么回事？我们都知道`"42"`是一个真值（见本章前面的介绍）。为什么`==`的结果不是`true`呢？原因既简单又复杂，很容易让人掉坑里，很多JS开发人员对此并未引起足够的重视。

还是引述规范，11.9.3.6-7节：

```
1. 如果Type(x)是`boolean`值，则返回ToNumber(x) == y的结果。
2. 如果Type(y)是`boolean`值，则返回x == ToNumber(y)的结果。
```

现在来分析一下这个例子。首先：

```
    var x = true;
    var y = "42";

    x == y; // false
```

`Type(x)`是`boolean`类型，所以执行`ToNumber(x)`将`true`强制类型转换为`1`。现在变成`1 == "42"`，它们的类型仍然不同，根据规则`"42"`被强制类型转换为`42`，最后变成`1 == 42`，结果为`false`。

反过来的结果也是一样：

```
    var x = "42";
    var y = false;

    x == y; // false
```

`Type(y)`是`boolean`类型，所以执行`ToNumber(y)`将`false`强制类型转换为`0`。`"42" == 0`进而变成`42 == 0`，结果为`false`。

也就是说，字符串`"42"`既不`== true`，也不`== false`。太奇怪了，一个值怎么可以既非真值也非假值呢？

这样问本身就是错误的，实际情况和我们想的是两回事。

`"42"`是一个真值，但和我们想的不一样，`"42" == true`并非`boolean`值的相等比较和强制类型转换。`"42"`并没有被强制类型转换为`boolean`（`true`），而是`true`被强制类型转换为`1`，`"42"`被转换为`42`。

其中并未涉及`ToBoolean`，所以`"42"`是真值还是假值与`==`操作没有关系！

我们需要理解`==`算法如何处理不同的类型组合。它首先会将`==`两边的`boolean`值强制类型转换为`number`。

这的确显得很古怪。我个人建议无论什么情况，永远不要使用`== true`和`== false`。

但是请注意，这里讨论的只是`==`，`=== true`和`=== false`不允许强制类型转换，所以并不涉及`ToNumber`转换。

例如：

```
    var a = "42";
    
    // bad (will fail!):
    if (a == true) {
        // .. 
    }
    
    // also bad (will fail!):
    if (a === true) {
        // .. 
    }
    
    // good enough (works implicitly):
    if (a) {
        // ..
    }
  
    // better (works explicitly):
    if (!!a) {
        // .. 
    }
    
    // also great (works explicitly):
    if (Boolean( a )) {
        // .. 
    }
```

如果我们避免在代码中使用`== true`和`== false`（也叫做`boolean`值的宽松相等），就不用担心掉这些坑里了。

#####null和undefined之间的相等比较

`null`和`undefined`之间的宽松相等`==`也涉及*隐式*强制类型转换。再次引述ES5规范，11.9.3.2-3节：

```
1. 如果x为null，y为undefined，则结果为true。
2. 如果x为undefined，y为null，则结果为true。
```

在`==`中`null`和`undefined`相等（同时它们也和自身相等），除它们之外其他值都不存在这种情况。

这意味着`null`和`undefined`在宽松相等`==`时是没有区别的，即相互间可以*隐式*强制类型转换：

```
    var a = null;
    var b;

    a == b;     // true
    a == null;  // true
    b == null;  // true
    
    a == false; // false
    b == false; // false
    a == "";    // false
    b == "";    // false
    a == 0;     // false
    b == 0;     // false
```

`null`和`undefined`之间的强制类型转换是安全且可预测的，此处任何其他值都无法得到假阳（false positive）结果。建议通过这种形式的强制类型转换将`null`和`undefined`当作等同的值来处理。

例如：

```
    var a = doSomething();
    
    if (a == null) {
        // ..
    }
```

仅当`doSomething()`的返回非`null`和`undefined`的值时，条件判断`a == null`才会通过，除此之外的其他值都会失败，即便是诸如`0`，`false`和`""`这样的假值。

下面是*显式*的条件判断，其中没有上述的强制类型转换，相对而言更繁琐一些（或许执行效率也更低）：

```
    var a = doSomething();
    if (a === undefined || a === null) {
        // ..
    }
```

在我看来，`a == null`这样的*隐式*强制类型转换既能提高代码可读性，又安全可靠。

#####对象到非对象之间的相等比较

对于`object`／`function`／`array`和标量基本类型值（`string`／`number`／`boolean`）之间的相等比较，ES5规范的11.9.3.8-9一节有如下规定：

```
1. 如果Type(x)是字符串或者数字，Type(y)是对象，返回x == ToPrimitive(y)的结果。
2. 如果Type(x)是对象，Type(y)是字符串或者数字，返回ToPromitive(x) == y的结果。
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这些条款只提到字符串和数字，没有提到<b>boolean</b>值。因为我们之前引用了条款11.9.3.6-7，其中规定了<b>boolean</b>值会首先被强制类型转换为数字。</td>
    </tr>
</table>

例如：

```
    var a = 42;
    var b = [ 42 ];
    
    a == b; // true
```

`[ 42 ]`首先调用它的`ToPromitive`抽象操作（见`第59页`，`“抽象值操作”`），返回结果`"42"`，从而成为`"42" == 42`，然后象之前介绍的那样，又成为`42 == 42`，最终两个值通过强制类型转换视作相等。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">之前介绍过的有关<b>ToPromitive</b>抽象操作的所有特性（如：<b>toString()</b>，<b>valueOf()</b>）在这里都适用。这在数据结构很复杂，需要自定义<b>valueOf()</b>函数来返回一个简单值以便进行相等比较的时候会很有帮助。</td>
    </tr>
</table>

在`第三章`中我们介绍了“拆封（unboxing）”，即对包装基本数据类型的封装对象（例如：`new String("abc"）`）进行拆封，然后返回其中的基本数据类型值（`"abc"`）。`==`中的`ToPromitive`强制类型转换也涉及这个操作：

```
    var a = "abc";
    var b = Object( a );    // same as `new String( a )`

    a === b;                // false
    a == b;                 // true
```

`a == b`返回`true`，因为`b`通过`ToPromitive`被强制类型转换（也称为“拆封”或者unwrapped）并返回标量基本类型值返回`"abc"`，与`a`的值相等。

由于`==`中其他更优先的规则，一些值出现了例外情况。例如：

```
    var a = null;
    var b = Object( a );    // same as `Object()`
    a == b;                 // false

    var c = undefined;      
    var d = Object( c );    // same as `Object()`
    c == d;                 // false
    
    var e = NaN;            
    var f = Object( e );    // same as `new Number( e )`
    e == f;                 // false
```

`null`和`undefined`不能被封装（boxed），因为它们没有对应的封装对象（object wrapper），因此`Object(null)`和`Object()`均返回一个普通对象。

`NaN`能够被封装为`number`类型的封装对象，但在`==`中拆封时，`NaN == NaN`返回`false`，因为`NaN`不等于`NaN`（见`第二章`）。

####非常见情况

至此我们全面介绍了`==`中的*隐式*强制类型转换（常规和非常规的情况），现在我们来看一下那些需要特别注意和避免的极端情况。

首先我们来看看更改内置原生原型（built-in native prototypes）会导致哪些奇怪的结果：

```
    Number.prototype.valueOf = function() {
        return 3;
    };

    new Number( 2 ) == 3;   // true
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;"><b>2 == 3</b>不会有这样的问题，因为<b>2</b>和<b>3</b>都是数字基本类型值，不会调用<b>Number.prototype.valueOf()</b>方法。然而<b>Number(2)</b>涉及<b>ToPrimitive</b>强制类型转换，因此会调用<b>valueOf()</b>。</td>
    </tr>
</table>

很诡异是吧？确实。这也是强制类型转换和`==`被诟病的原因之一。但这并不是JavaScript本身的问题，而是我们这些*开发人员*。不要有这样的想法，即“编程语言应该设法防止开发人员犯错”。

还有更诡异的例子：

```
    if (a == 2 && a == 3) {
        // ..
    }
```

你可能觉得不会出现这种情况，因为`a`不可能同时等于`2`和`3`。但“同时”一词并不准确，因为`a == 2`在`a == 3`之前被判断。

如果让`a.valueOf()`在每次调用时都产生边缘效应，如第一次调用时返回`2`，第二次调用时返回`3`，就会出现这样的情况。很简单：

```
    var i = 2;
    
    Number.prototype.valueOf = function() {
        return i++;
    };
   
    var a = new Number( 42 );
    
    if (a == 2 && a == 3) {
        console.log( "Yep, this happened." );
    }
```

再次强调，这些做法十分糟糕，千万别用。但也不要因此而诟病强制类型转换。对机制的错误使用并不能成为诟病它的借口。我们应该避免这些极端的情况，正确合理地运用强制类型转换。

#####假值的相等比较

`==`中的*隐式*强制类型转换最为人诟病的一点，是在比较假值时的怪异行为。

下面分别列出了那些正常的和怪异的行为：

```
    "0" == null;        // false
    "0" == undefined;   // false
    "0" == false;       // true -- 晕！
    "0" == NaN;         // false
    "0" == 0;           // true
    "0" == "";          // false

    false == null;      // false
    false == undefined; // false
    false == NaN;       // false
    false == 0;         // true -- 晕！
    false == "";        // true -- 晕！
    false == [];        // true -- 晕！
    false == {};        // false

    "" == null;         // false
    "" == undefined;    // false
    "" == NaN;          // false
    "" == 0;            // true -- 晕！
    "" == [];           // true -- 晕！
    "" == {};           // false

    0 == null;          // false
    0 == undefined;     // false
    0 == NaN;           // false
    0 == [];            // true -- 晕！
    0 == {};            // false
```

以上24种情况中，有17种比较正常。比如，我们知道`""`不等于`NaN`，因为它们在宽松相等比较时不进行强制类型转换，而`"0"`和'0'相等，因为它们在宽松相等比较时进行强制类型转换。

然而有7种情况我们加了“晕！”注释，因为它们是假阳性，很容易产生误会。`""`和`0`很明显是不同的值，我们很少需要将它们视作相等，所以很容易搞错。请注意这里不存在假阴性（false negatives）。

#####极端的情况

这还不算完，还有更极端的例子：

```
    [] == ![]   // true
```

这看起来更疯狂了。我们会以为是这是真值和假值之间相等比较，因此不应该得到`true`的结果，因为一个值不可能同时既是真值也是假值！

但是事实并非如此。让我们细细探来，看看`!`运算符都做了些什么？它根据`ToBoolean`规则将值显式强制类型转换为`boolean`值（同时反转奇偶校验位）。所以在`[] == ![]`执行之前已经成为这样了：`[] == false`。从前面的例子中我们知道`false == []`，所以最后的结果一点也不出人意外。

那么其他情况呢？

```
    2 == [2];       // true
    "" == [null];   // true
```

我们在介绍`ToNumber`时说过，右边的值`[2]`和`[null]`会执行`ToPrimitive`强制类型转换，以便能够和左边的基本类型值进行比较（`2`和`""`）。因为`数组`的`valueOf()`返回`数组`本身，所以强制类型转换将对`数组`进行字符串化。

第一行的`[2]`会被转换为`"2"`，然后通过`ToNumber`转换为`2`。第二行的`[null]`会被直接转换为`""`。

因此`2 == 2`和`"" == ""`的结果完全可以理解。

如果你对这样的情况还是无法适应，那么你的困惑可能并非如你所想是源自于强制类型转换，而实际上是来自`array`的`ToPrimitive`，它将`array`转换为`string`。你很可能没有想到`[2].toString()`返回的是`"2"`，`[null].toString()`返回的是`""`。

但是如果不这样做的话，这些`string`又应该被如何转换呢？我实在想不出其他可行的办法。或许`[2]`应该被转换为`"[2]"`，但这在其他情况下会显得很古怪。

你也许会觉得因为`String(null)`的结果是`"null"`，所以`String([null])`也应该返回`"null"`。的确有道理，这就是问题产生的根源。

*隐式*强制类型转换不是问题的根源。*显式*强制类型转换也是将`[null]`转换为`""`。问题是将`array`字符串化为对应的`string`是否合理，具体如何处理。所以根源是`String([..])`的相关规则。又或许根本就不应该将`array`字符串化？但是这样的话在其他情况下又会产生很多问题。

还有经常被提到的坑是：

```
    0 == "\n";  // true
```

我们前面介绍过，`""`，`"\n"`（或者`" "`等其他空格组合）等空字符串通过`ToNumber`强制类型转换时返回`0`。`Number(" ")`返回`0`没有问题吧，不然你要它咋整？

或许空字符串和空格字符串可以转换为另一个值，即`NaN`。但是这会让情况更好吗？当然`" " == NaN`会失败，但是个中原因并未得以清楚地体现。

现实情况中由于`0 == "\n"`造成程序错误的几率小之又小，这样的特殊情况也很容易避免。

类型之间的转换*总*会出现一些特殊情况，并非只有强制类型转换是这样，任何编程语言都是如此。问题出在我们对一些特殊情况返回结果的猜测上（或许有时能猜对！？），但这并不能成为诟病强制类型转换机制的理由。

前面列出的7个坑基本上涵盖了我们可能碰到的*正常*值间强制类型转换的情况（除了修改`valueOf()`和`toStrign()`的情况以外）。

与上述24种情况相反的是下面这个列表：

```
    42 == "43";         // false
    "foo" == 42;        // false
    "true" == true;     // false
   
    42 == "42";         // true
    "foo" == [ "foo" ]; // true    
```

这些是非假值的一般情况（实际上还可以加上无限大数字的相等比较），转换结果完全没有问题。

#####完整性检查

我们深入介绍了*隐式*强制类型转换中的一些特殊情况。也难怪大多数开发人员都觉得它太晦涩，唯恐避之不及。

让我们回过头来看看完整性检查（sanity check）。

我们列出了相等比较中的强制类型转换的7个坑，但另外还有至少17种情况是绝对安全合理的。

因为强制类型转换的这几种特殊情况而放弃其为数更多的安全有用的特性，或许有点因噎废食了。

应该是考虑怎样才能够充分运用强制类型转换*好*的地方，同时避开那些*不好*的地方。

再来看一下那些不好的地方：

```
    "0" == false;   // true -- 晕！
    false == 0;     // true -- 晕！
    false == "";    // true -- 晕！
    false == [];    // true -- 晕！
    "" == 0;        // true -- 晕！
    "" == [];       // true -- 晕！
    0 == [];        // true -- 晕！
```

其中4种情况涉及`== false`比较，之前我们说过应该避免这样的情况，这并不难掌握。

现在减为3种：

```
    "" == 0;        // true -- 晕！
    "" == [];       // true -- 晕！
    0 == [];        // true -- 晕！
```

正常情况下我们应该不会写出这样的代码吧。

不要在程序中使用`== []`这样的`boolean`判断，而应该使用`== ""`或者`== 0`，如：

```
    function doSomething(a) {
        if (a == "") {
            // .. 
        }
    }
```

如果不小心调用了`doSomething(0)`或者`doSomething([])`，会得到意外的结果。另如：

```
    function doSomething(a,b) {
        if (a == b) {
            // .. 
        }
    }
```

如果调用`doSomething("",0)`或者`doSomething([],"")`，也会得到意外的结果。

虽然这些特殊情况会带来各种问题，需要我们多加小心，但好在它们并不是十分常见。

#####安全地运用隐式强制类型转换

关键是要对`==`两边的值仔细斟酌。以下两条规则可以有效地避免出错：

- 如果两边的值有可能转换为`true`或者`false`时，不要使用`==`。
- 如果两边的值有可能转换为`[]`，`""`或者`0`时，请考虑尽量不要使用`==`。

这时用`===`更好一些，这样可以避免意外发生的强制类型转换。遵循这两条规则可以让我们避开强制类型转换可能带来的大部分问题。

上面情况中，强制类型转换越显式越好，这样可以避免很多问题。

所以在`==`和`===`之间做选择时，问题就变成：是否在相等比较中允许强制类型转换？

强制类型转换在很多情况下仍然十分有用，它能够让相等比较代码更简洁（比如对于`null`和`undefined`）。

总的来说，*隐式*强制类型转换在为数不多的情况下的确会导致问题。这时为了安全起见我们就要使用`===`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">强制类型转换在有一种情况下是绝对安全的，那就是<b>typeof</b>操作。<b>typeof</b>总是返回七个字符串中的一个（见<b>第一章</b>），其中没有空字符串。所以在类型检查过程中不会发生隐式强制类型转换。<b>typeof x == "function"</b>是100%安全的，和<b>typeof x === "function"</b>一样。事实上规范中两者完全相同。所以不要盲目听从代码工具的建议不加思索地到处使用<b>===</b>，或者听从某些书中的建议更本不加以理会，这样更要不得。我们要对自己的代码负责。</td>
    </tr>
</table>

*隐式*强制类型转换真的那么糟糕和危险吗？某些情况下是这样，但总的来说并非如此。

我们应该做一个成熟负责的开发人员，去掌握如何有效安全地运用强制类型转换（*显式*和*隐式*），并对周围的小伙伴言传身教。

GitHub用户Alex Dorey（GitHub用户名@dorey）制作了一个图表，列出了各种相等比较的情况，如`图4-1`。

![](figures/Figure4-1.png)

*图4-1. JavaScript中的相等比较*

####抽象关系比较

这方面的*隐式*强制类型转换虽然不太为我们所重视，但还是很有必要对`a < b`（类似于`a == b`）的工作原理有所了解。

ES5规范中的11.8.5节定义了“抽象关系比较（Abstract Relational Comparison）”，分两种情况：比较双方都是`string`（后半部分），其他情况（前半部分）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">该算法只针对<b>a &lt; b</b>的情况。<b>a > b</b>会被当作<b>b &lt; a</b>来处理。</td>
    </tr>
</table>

该算法首先对比较双方调用`ToPrimitive`，如果其中之一返回的不是`string`，则比较双方遵循`ToNumber`规则被强制类型转换为`number`，然后作为数字来进行比较。

例如：

```
    var a = [ 42 ];
    var b = [ "43" ];

    a < b;  // true
    b < a;  // false
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">前面介绍的<b>-0</b>和<b>NaN</b>的相关规则在这里也适用。</td>
    </tr>
</table>

然而如果比较双方都是`string`则按字母顺序（natural alphabetic）来比较：

```
    var a = [ "42" ];
    var b = [ "043" ];
    
    a < b; // false
```

`a`和`b`并没有被转换为`number`，因为`ToPrimitive`返回`string`。因此我们比较的是`"42"`和`"043"`这两个字符串，分别以`"4"`和`"0"`开头。因为`"0"`在字母顺序上小于`"4"`，所以最后的结果为`false`。

同样对于：

```
    var a = [ 4, 2 ];
    var b = [ 0, 4, 3 ];
    
    a < b; // false
```

这里`a`转换为`"4, 2"`，`b`转换为`"0, 4, 3"`，同样按字母顺序进行比较。

再比如：

```
    var a = { b: 42 };
    var b = { b: 43 };
    
    a < b; // ??
```

结果还是`false`，因为`a`是`[object Object]`，`b`也是`[object Object]`，所以按照字母顺序，`a`并不小于`b`。

下面的例子就有些奇怪了：

```
    var a = { b: 42 };
    var b = { b: 43 };

    a < b;  // false
    a == b; // false
    a > b;  // false
    
    a <= b; // true
    a >= b; // true
```

为什么`a == b`的结果不是`true`？它们有相同的字符串值（`"[object Object]"`），应该相等才对？实际上不是这样。可以回忆一下前面介绍过的`object`的相等比较。

但如果`a < b`和`a == b`的结果都是`false`，为什么`a <= b`和`a >= b`的结果是`true`呢？

因为根据规范，`a <= b`实际上是先执行`b < a`，然后将结果反转。因为`b < a`的结果是`false`，所以`a <= b`的结果为`true`。

我们想的可能与此大相径庭，即`<=`应该是“小于或者等于”。实际上JS中`<=`是指“不大于”（即`!(a > b)`，处理为`!(b < a)`）。同理`a >= b`处理为`b <= a`。

相等比较中有严格相等，而关系比较中没有“严格关系比较（strict relational comparison）”。也就是说如果要避免关系比较中的*隐式*强制类型转换，比如`a < b`，我们只能确保`a`和`b`的类型一致，除此之外别无他法。

和`==`及`===`的完整性检查同样的道理。我们应该在必要和安全的情况下使用强制类型转换，如：`42 < "43"`。另一方面，如果要确保关系比较的安全，就应该在比较之前使用*显式强制类型转换*：

```
    var a = [ 42 ];
    var b = "043";

    a < b;                      // false -- string comparison!
    Number( a ) < Number( b );  // true -- number comparison!
```

###回顾

本章中我们介绍了JavaScript的数据类型的相互转换，即`强制类型转换`，包括*显式*和*隐式*。

强制类型转换经常为人所诟病，但实际很多时候是非常有用的。作为一个有责任感的JS开发人员，深入了解强制类型转换是非常必要的，这样可以更好地取其精华、去其糟粕。

在代码中，*显式*强制类型转换明确告诉我们哪里需要进行类型转换。这有利于提高代码的可读性和可维护性，并且避免产生误解。

*隐式*强制类型转换则不那么明显，只是伴随其他操作的边缘效应发生。它看似*显式*强制类型转换的反面，让人感觉很糟糕，实际上*隐式*强制类型转换也有助于提高代码的可读性。

使用强制类型转换的时候需要十分小心，特别是*隐式*强制类型转换。我们要知其然，也知其所以然。并且尽可能地让代码清晰易读。

------

##第五章 语法

JavaScript的语法（grammar）是本书要讨论的最后一个重要主题。或许我们觉得自己已经会用JS编程了，但是其中仍然有许多繁枝褥节容易引起误解，我们将对它们做深入的介绍。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">比起“syntax”，“grammar”一词对于读者来说要陌生一些。它们很多时候指的是同一个意思，都是对语言<i>规则</i>的定义。虽然也存在一些细微差别，不过我们可以忽略不计。JavaScript的语法系统地定义了词法规则（syntax rules，如：运算符、关键词等等）如何组织在一起构成合法的程序代码。换句话说，只看词法不看语法会漏掉很多重要的细节。所以本章我们重点介绍语法（grammar），虽然与开发人员直接打交道的是词法（syntax）。</td>
    </tr>
</table>

###语句和表达式

“语句（statement）”和“表达式（expression）”普遍被认为是一回事。但是这里我们需要将它们区分开来，因为在JS中它们差别很大。

为了说明问题，我们借鉴了英语中的一些术语，它们对读者来说可能更熟悉。

“句子（sentence）”是一段完整的、表达某个意思的词语。它由一个或多个“短句（phrase）”组成，它们之间由标点符号和连接词（“and”和“or”等等）连接起来。短句可以包含更小的短句。有些短句是不完整的，本身不表达什么意思，有些短句则相对完整，并且能够独立表达某个意思。这些规则在在英语中统称为*语法（grammar）*。

JavaScript的语法也是如此。语句相当于句子，表达式相当于短句，运算符则相当于标点符号和连接词。

JS中的表达式可以返回一个结果值。例如：

```
    var a = 3 * 6;
    var b = a;
    b;
```

上例中，`3 * 6`是一个表达式（结果为`18`）。第二行的`a`也是一个表达式，第三行的`b`也是。表达式`a`和`b`的结果值都是`18`。

这三行代码都是包含表达式的语句。`var = 3 * 6`和`var b = a`叫做“声明语句（declaration statement）”，因为它们声明了变量（还可以为变量赋值）。`a = 3 * 6`和`b = a`（不带`var`）叫做赋值表达式。

第三行代码仅有一个表达式`b`，但它也是一个语句（虽然没有太大意义！）。这样的情况通常叫做“表达式语句（expression statement）”。

###语句的结果值

很多人不知道的是语句都有一个结果值（statement completion value，有可能是`undefined`）。

那么如何来获得语句的结果值呢？

最直观的方式是在浏览器开发者工具控制台中输入语句，默认情况下控制台会显示最后执行的语句的结果值。

那么`b = a`的结果值是多少呢？

赋值表达式`b = a`的结果值是其所赋的值（`18`），但是`var`的结果值是`undefined`，因为规范中就是这样定义的。如果在控制台中输入`var a = 42`，会看到结果值为`undefined`，而非`42`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从技术角度来解释更复杂一些。ES5规范12.2节“变量语句”中，<b>变量声明（VariableDeclaration）</b>算法实际上有一个返回值（是一个包含所声明变量名称的字符串，很奇特吧！？），但是该值被<b>变量语句（VariableStatement）</b>算法屏蔽掉了（除了<b>for..in</b>循环的情况），最后的结果值为空（即<b>undefined</b>）。</td>
    </tr>
</table>

实际上如果用控制台调试代码（或者JavaScript REPL-read／evaluate／print／loop工具），就经常能看到很多语句返回`undefined`，只是可能我们从来没有注意和理解。简单来说控制台中显示的就是语句的结果值。

但我们在代码中没有办法使用控制台显示的结果值，咋办呢？

这个问题比较复杂。在公布答案之前，我们先来说说为什么要获得语句的结果值。

我们来看一下其他类型的语句结果值。比如代码块`{ .. }`的结果值是其最后一个语句／表达式的结果值。

例如：

```
    var b;
    
    if (true) {
        b = 4 + 38;
    }
```

如果在控制台／REPL中输入以上代码，应该会显示`42`，即最后一个语句／表达式`b = 4 + 38`的结果值。

换句话说就是代码块的结果值如同一个*隐式地返回语句（implicit return）*，返回其最后一个语句的结果值。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">CoffeeScript也有类似的机制，即函数隐式地返回最后一个语句的结果值。</td>
    </tr>
</table>

那么问题来了，下面这样的代码是无法运行的：

```
    var a, b;
    
    a = if (true) {
        b = 4 + 38;
    };
```

语法不允许我们获得语句的结果值并将其赋值给另一个变量（至少目前还不行！）。

那应该怎么办呢？

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">下面的代码仅作为演示之用，不要在实际开发中使用。</td>
    </tr>
</table>

我们可以使用`eval(...)`（又读作“evil”）来获得结果值：

```
    var a, b;

    a = eval( "if (true) { b = 4 + 38; }" );

    a;  // 42
```

这是一个糟糕但是可行的方法，让我们获得并在程序中使用语句的结果值。

在ES7规范中有一项草案叫做“do表达式（do expression）”，类似下面这样：

```
    var a, b;
    
    a = do {
        if (true) {
            b = 4 + 38; 
        }
    };

    a; // 42
```

`do表达式`执行代码块（包含一个或多个语句），并且返回代码块中最后一个语句的结果值，然后赋值给变量`a`。

这样是把语句当作表达式来处理，语句中可以包含其他语句，不需要通过函数用`return`显式地返回值。

语句的结束值目前还不是太重要。但是随着JS语言的演进，它可能会扮演越来越重要的角色，希望`do { .. }`表达式的引入能够减少我们对`eval(..)`这类方法的使用。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">重要的话说两遍：尽量不要用eval(..)。详情见<b>《Scope &amp; Closures》</b>。</td>
    </tr>
</table>

###表达式的边缘效应

大部分表达式没有边缘效应。例如：

```
    var a = 2;
    var b = a + 3;
```

表达式`a + 3`本身没有边缘效应，如改变`a`的值等。它的结果值为`5`，其通过`b = a + 3`被赋给变量`b`。

最常见的（有可能）有边缘效应的表达式是函数调用：

```
    function foo() {
        a = a + 1;
    }
    
    var a = 1;
    foo();      // result: `undefined`, side effect: changed `a`
```

另外一些表达式也有边缘效应。比如：

```
    var a = 42;
    var b = a++;
```

表达式`a++`做两件事。首先返回变量`a`的当前值`42`（其随后被赋值给`b`）。然后改变`a`的值，将其加一：

```
    var a = 42;
    var b = a++;

    a;  // 43
    b;  // 42
```

很多人误以为变量`b`和`a`的值都是`43`。这是因为没有完全理解`++`运算符的边缘效应产生的时机。

递增运算符`++`和递减运算符`--`都是一元运算符（unary operator，见`第四章`），它们可以出现在操作数前后：

```
    var a = 42;
    
    a++;    // 42
    a;      // 43
    
    ++a;    // 44
    a;      // 44
```

`++`在操作数前面时，如：`++a`，它的边缘效应（递增`a`）发生在表达式返回结果值之前，而`a++`的边缘效应发生在之后。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">考考你，<b>++a++</b>这样的语法是否合法？你试一试就知道，它会产生<b>ReferenceError</b>错误。因为运算符需要将它产生的边缘效应赋值给一个变量。以<b>++a++</b>为例，首先执行<b>a++</b>（根据运算符优先级，见下），返回<b>a</b>递增之前的值<b>42</b>。然后执行<b>++42</b>，这时会产生<b>ReferenceError</b>错误，因为<b>++</b>无法直接在<b>42</b>这样的值上产生边缘效应。</td>
    </tr>
</table>

我们常会误以为可以用括号`( )`将`a++`的边缘效应封装起来，例如：

```
    var a = 42;
    var b = (a++);

    a;  // 43
    b;  // 42
```

可惜并非如此，`( )`本身并不是一个封装表达式，不会在表达式`a++`产生边缘效应之后执行。实际上即便如我们所想，`a++`首先返回`42`，除非有表达式在`++`之后再次对`a`进行运算，否则还是不会得到`43`，`b`也不会被赋值为`43`。

不过还有一个办法，即`,`语句系列逗号运算符。它能够让我们将多个独立的表达式语句串联成一个语句：

```
    var a = 42, b;
    b = ( a++, a );
    
    a;  // 43
    b;  // 43
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">因为运算符优先级的原因，我们需要将<b>a++, a</b>放入<b>( .. )</b>，我们将在本章后面介绍。</td>
    </tr>
</table>

表达式`a++, a`中的第二个表达式`a`在`a++`之后执行，结果为`43`，并被赋值给`b`。

另一个例子是`delete`。我们在`第二章`中介绍过，`delete`用来删除`object`中的属性和`array`中的单元。通常它是以独立语句的形式出现：

```
    var obj = {
        a: 42
    };
    
    obj.a;          // 42
    delete obj.a;   // true
    obj.a;          // undefined
```

如果操作成功，`delete`返回`true`，否则返回`false`。它的边缘效应则是属性从`object`中删除（或者单元从`array`中删除）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">操作成功是指什么呢？对于那些不存在的，和存在但可配置（configurable，见本系列的《this &amp; Object Prototypes》第三章）的属性，delete返回true。否则返回false，或者产生错误。</td>
    </tr>
</table>

最后一个有趣的例子是`=`赋值运算符。

例如：

```
    var a;
    
    a = 42;     // 42
    a;          // 42
```

`a = 42`中的`=`看似没有边缘效应。但是如果我们检查一下语句`a = 42`的结果值就会发现，它返回的是`42`，所以`=`的边缘效应就是给`a`赋值。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">边缘效应同样适用于+=和-=这样的组合赋值运算符。例如，<b>a = b += 2</b>首先执行<b>b += 2</b>（即<b>b = b + 2</b>），该操作的结果值被赋给<b>a</b>。</td>
    </tr>
</table>

赋值表达式（或者语句）的结果值在串联多个赋值语句（链式赋值，chained assignments）的时候很有用，比如：

```
    var a, b, c;

    a = b = c = 42;
```

这里`c = 42`的结果值为`42`（产生的边缘效应是`42`被赋值给`c`），然后`b = 42`的结果值为`42`（产生的边缘效应是`42`被赋值给`b`），最后是`a = 42`（产生的边缘效应是`42`被赋值给`a`）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">关于链式赋值的一个常见错误是<b>var a = b = 42</b>这样的用法。它看起来和前面的例子一样，实则不然。如果变量<b>b</b>没有在代码作用域中正式声明过<b>（var b）</b>，则<b>var a = b = 42</b>不会对变量<b>b</b>进行声明。在严格模式（strict mode）中这会产生一个错误或者是无意中创建一个全局变量（见本系列的<b>《Scope &amp; Closures》</b>一书）。</td>
    </tr>
</table>

另一种情况是：

```
    function vowels(str) {
        var matches;

        if (str) {
            // pull out all the vowels
            matches = str.match( /[aeiou]/g );

            if (matches) {
                return matches;
            } 
        }
    }
    
    vowels( "Hello World" ); // ["e","o","o"]
```

很多开发人员喜欢这样做，这完全没问题。但是我们可以利用赋值语句的边缘效应将两个`if`语句合二为一：

```
    function vowels(str) {
        var matches;

        // pull out all the vowels
        if (str && (matches = str.match( /[aeiou]/g ))) {
            return matches;
        }
    }

    vowels( "Hello World" ); // ["e","o","o"]
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">将<b>matches = str.match..</b>放入<b>( .. )</b>是必需的。原因我们在<b>第137页中的“运算符优先级”</b>会介绍。</td>
    </tr>
</table>

我喜欢简短一点的代码，因为它更能体现两个条件的关联性。不过和大部分编码风格一样，这只是个人偏好，无关好坏。

###上下文规则

JavaScript中有一些语法规则对同样的语法在不同的情况下有不同的解释。孤立地来理解这些规则会感到很困惑。

这里我们不做一一列举，仅介绍一些常见的情况。

####大括号

在两种情况下我们会使用大括号`{ .. }`（随着JS的演进会有更多这样的情况）。下面我们将逐一介绍。

#####对象常量

一是在定义`object`常量（object literals）时：

```
    // assume there's a `bar()` function defined

    var a = {
        foo: bar()
    };
```

为什么说它是一个`object`常量呢？因为`{ .. }`是一个被赋给`a`的值。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">我们将<b>a</b>称为“左值”（即l-value），因为它是被赋值对象。<b>{ .. }</b>是“右值”（即r-value），因为它就是一个值而已（即本例中被赋给变量<b>a</b>的那个值）。</td>
    </tr>
</table>

#####标签

如果将上例中的`var a =`去掉会发生什么情况呢？

```
    // assume there's a `bar()` function defined
    {
        foo: bar()
    }
```

许多人认为这里的`{ .. }`只是一个孤立的`object`常量，并没有被赋值。实际上完全不是这样。

此处`{ .. }`只是一个普通代码块。JavaScript中这并不多见（在其他语言中则常见得多！），但在语法上完全没问题。特别是和`let`（块作用域声明）一起使用时非常有用（见本系列的*《Scope & Closures》*一书）。

`{ .. }`的作用和`for`／`while`循环、`if`条件语句等中的代码块基本一样。

如果这没问题，`foo: bar()`这样奇怪的语法怎么能通过呢？

这里涉及JavaScript中一个不太为人知的特性（也不推荐使用），叫“标签语句（labeled statements）”。`foo`是`bar()`语句的标签（后面没有`;`，请参见本章`第146页`中的`“自动分号”`）。那么标签语句有什么用呢？

假设JavaScript有`goto`语句，理论上我们可以使用`goto foo`来跳转到该段代码执行。`goto`被公认为是一种很糟糕的编码方式，它会让代码变得晦涩难懂（也叫做“spaghetti code”），所以JavaScript没有`goto`是一件好事。

然而JS支持某种有限度的特别的`goto`：标签跳转（labeled jumps）。`continue`和`break`语句都可以带一个标签，这样程序执行流程就可以象`goto`那样进行跳转了。例如：

```
    // `foo` labeled-loop
    foo: for (var i=0; i<4; i++) {
        for (var j=0; j<4; j++) {
            // whenever the loops meet, continue outer loop
            if (j == i) {
                // jump to the next iteration of
                // the `foo` labeled-loop
                continue foo;
            }
            
            // skip odd multiples
            if ((j * i) % 2 == 1) {
                // normal (nonlabeled) `continue` of inner loop
                continue; 
            }
            
            console.log( i, j );
        }
    }
    // 1 0
    // 2 0
    // 2 1
    // 3 0
    // 3 2
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>contine foo</b>的意思不是“跳转到标签<i>foo</i>所在位置继续执行”，而是“继续执行标签为<i>foo</i>的循环代码的下一个循环”。所以这里的<b>foo</b>并非<b>goto</b>。</td>
    </tr>
</table>

这里我们跳过了双奇数循环`3 1`，带标签的循环跳转（labeled-loop jump）还跳过了`1 1`和`2 2`。

带标签的循环跳转和`break __`一起可以实现从内层循环跳转到外层循环，这个的用处或许更大。如果不用`break`和标签，就只能通过下面的代码来实现：

```
    // `foo` labeled-loop
    foo: for (var i=0; i<4; i++) {
        for (var j=0; j<4; j++) {
            if ((i * j) >= 3) {
                console.log( "stopping!", i, j );
                break foo; 
            }
            
            console.log( i, j );
        }
    }
    // 0 0
    // 0 1
    // 0 2
    // 0 3
    // 1 0
    // 1 1
    // 1 2
    // stopping! 1 3
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>break foo</b>的意思不是“跳转到标签<i>foo</i>所在位置继续执行”，而是“跳出标签<i>foo</i>所在的循环／代码块，继续执行其后的代码”。所以它并非传统意义上的<b>goto</b>。</td>
    </tr>
</table>

上例如果用不带标签的`break`来实现则可能要用到别的函数，以及共享作用域的变量等，这会令代码更难理解，所以这里用带标签的`break`或许更好一些。

标签也能用于非循环代码块，但只有`break`可以这样。我们可以对带标签的代码块使用`break ___`，但是不能对带标签的非循环代码块使用`continue ___`，也不能对不带标签的代码块使用`break`：

```
    // `bar` labeled-block
    function foo() {
        bar: {
                console.log( "Hello" );
                break bar;
                console.log( "never runs" );
        }
        console.log( "World" );
    }

    foo();
    // Hello
    // World
```

带标签的循环／代码块不太常见，也不推荐，能不用就不要用，比如循环跳转也可以通过函数调用来实现。不过在有些情况下它们也会派上用场，这时请务必通过注释写清楚要实现的功能！

JSON被普遍认为是JS的一个子集，因此`{"a":42}`这样的JSON字符串会被当作合法的JS代码（请注意JSON属性名必须使用双引号！）。实际并非如此！如果在控制台输入`{"a":42}`会报错。

这是因为标签不允许使用双引号，所以`"a"`并不是一个合法的标签，因此后面不能带`:`。

JSON的确是JS语法的一个子集，但是JSON本身并不是合法的JS语法。

这里存在一个很常见的误区，即如果我们使用`<script src=..>`标签加载一个JS文件，其中只包含JSON内容（比如某个API返回的结果），就可以在程序中将这些内容作为合法的JavaScript代码来使用。JSON-P（可以将JSON数据封装为方法调用，如`foo({"a":42})`）通过将JSON数据传递给函数来解决这个问题）。

`{"a":42}`作为JSON值没有任何问题，但是在作为代码执行时会产生JS错误，因为它被当作一个带有非法标签的语句块来执行。`foo({"a":42})`就没有问题，因为`{"a":42}`在这里是一个传递给`foo(..)`的`object`常量。因此，确切地说，*JSON-P能将JSON转换为合法的JS语法*。

#####代码块

下面是另一个常见的坑（涉及强制类型转换，见`第四章`）：

```
    [] + {}; // "[object Object]"
    {} + []; // 0
```

看起来象是`+`运算符根据第一个操作数（`[]`或`{}`）产生不同的结果。实际上和第一个操作数无关！

第一行中的`{}`被当作一个值（空`object`）来处理。我们在`第四章`介绍过，`[]`会被强制类型转换为`""`，`{}`会被强制类型转换为`"[object Object]"`。

但在第二行中，`{}`被当作一个独立的空代码块（不做任何事情）。代码块结尾不需要分号，所以这里没有问题。最后`+ []`将`[]`*显式强制类型转换*为`number`值`0`。

#####对象解构

从ES6开始，`{ .. }`也可用于“解构赋值（destructuring assignments）”（详情见本系列的*《ES6 & Beyond》一书*），特别是`object`的解构。例如：

```
    function getData() {
        // ..
        return {
            a: 42,
            b: "foo" 
        };
    }
    
    var { a, b } = getData();

    console.log( a, b ); // 42 "foo"
```

`{ a , b } = ..`即ES6中的解构赋值，相当于下面的代码：

```
    var res = getData();
    var a = res.a;
    var b = res.b;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>{ a, b }</b>实际上是<b>{ a: a, b: b }</b>的简化版本，两种写法可以，只是<b>{ a, b }</b>更简洁，更推荐使用。</td>
    </tr>
</table>

我们还可用`{ .. }`来对函数的命名参数（named function arguments）进行对象解构（object destructuring），这有助于隐式的对象属性赋值：

```
    function foo({ a, b, c }) {
        // no need for:
        // var a = obj.a, b = obj.b, c = obj.c
        console.log( a, b, c );
    }

    foo( {
        c: [1,2,3],
        a: 42,
        b: "foo"
    } );    // 42 "foo" [1, 2, 3]
```

所以`{ .. }`在不同的上下文中（context）作用不同，这也是词法（syntax）和语法（grammar）的区别。掌握这些细节对我们理解JS引擎如何解析代码十分重要。

#####else if和可选代码块

人们常误以为JavaScript中有`else if`，因为可以这样写代码：

```
    if (a) { 
        // ..
    }
    else if (b) {
        // .. 
    }
    else { 
        // ..
    }
```

这里涉及一个不太为人知的语法规则：JavaScript中没有`else if`。但如果`if`和`else`只包含单条语句，代码块的`{ }`可以被省略。你一定见过这样的代码：

```
    if (a) doSomething( a );
```

很多JS代码检查工具建议对单条语句也使用`{ }`，如：

```
    if (a) { doSomething( a ); }
```

`else`也一样，所以我们经常用到的`else if`*实际*上是这样的：

```
    if (a) { 
        // ..
    } 
    else {
        if (b) { 
            // ..
        } 
        else {
            // .. 
        }
    }
```

`if (b) { .. } else { .. }`实际上是`else`之后的一个单独的语句，所以带不带`{ }`均可。也就是说`else if`不符合常见的编码风格。

`else if`这样的用法十分常见，也能够省去一层代码缩进，所以我们很喜欢用。但这只是我们自己发明的用法，无论如何不要想当然地认为它是JS的语法。

###运算符优先级

我们在`第四章`中介绍过，JavaScript中的`&&`和`||`有选择地返回它的其中一个操作数的值，而非`true`或`false`。这对于一个运算符带两个操作数的情况很好理解：

```
    var a = 42;
    var b = "foo";

    a && b; // "foo"
    a || b; // 42
```

但如果是两个运算符带三个操作数呢？

```
    var a = 42;
    var b = "foo";
    var c = [1,2,3];

    a && b || c; // ???
    a || b && c; // ???
```

为了搞清楚上例的返回结果，我们需要了解表达式中含有超过一个运算符时它们执行的顺序规则。

这些规则称为“运算符优先级（operator precedence）”。

我敢说大部分读者都认为自己对运算符优先级已经足够了解。但是与对该系列中的其他知识点一样，现在就让我们来检验一下自己对这些知识掌握得有多牢靠，同时希望能够在此过程中学到新的知识。

回顾前面的例子：

```
    var a = 42, b;
    b = ( a++, a );
    
    a;  // 43
    b;  // 43
```

如果去掉`( )`会出现什么情况呢？

```
    var a = 42, b;
    b = a++, a;

    a;  // 43
    b;  // 42
```

为什么这里`b`的值不一样？

因为`,`运算符的优先级比`=`低。所以`b = a++, a`是作为`(b = a++), a`来执行。因为之前介绍过`a++`有*后续边缘效应（after side effects）*，所以赋给`b`的值是`++`对`a`做递增前的值`42`。

这只是运算符优先级的一个简单例子。用`,`来连接一系列语句的时候，务必记住它的优先级是最低的，其他操作数的优先级都高于它。

回顾一个前面的例子：

```
    if (str && (matches = str.match( /[aeiou]/g ))) {
        // ..
    }
```

这里的赋值语句用`( )`是必要的，原因是`&&`的优先级高于`=`，如果没有`( )`来结合（bind）其中的表达式，代码会这样来执行`(str && matches) = str.match..`。这样会出错，因为`(str && matches)`的结果并不是一个变量，而是一个`undefined`值，它不能够出现在`=`的左边！

现在你可能觉得自己已经掌握了运算符优先级。

让我们用一个更复杂的例子（我们会一直用到本章的下几节）来*实际*检验一下：

```
    var a = 42;
    var b = "foo";
    var c = false;

    var d = a && b || c ? c || b ? a : c && b : a;
    
    d;      // ??
```

很恐怖是吧，应该没有人会这样来写代码，这只是用来说明多个运算符串联时可能出现的一些常见问题。

结果是`42`。当然我们运行一下代码就可以知道结果，但是搞清楚其中的来龙去脉更有意思。

首先第一个问题是，`(a && b || c)`是处理为`(a && b) || c`还是`a && (b || c)`？它们之间有什么不同？

```
    (false && true) || true;    // true
    false && (true || true);    // false
```

事实证明它们之间有区别。那么`false && true || true`究竟是按什么顺序执行呢？答案是：

```
    false && true || true;      // true
    (false && true) || true;    // true
```

运算符`&&`首先被执行，接着是`||`。

所以顺序就一定是从左到右吗？我们将运算符颠倒一下看看：

```
    true || false && false;     // true

    (true || false) && false;   // false--不是这样
    true || (false && false);   // true--是这样
```

现在我们证明了`&&`先于`||`执行，而非之前的从左到右。

原因是*运算符优先级*。

每种语言都有自己的运算符优先级。遗憾的是JS开发人员对此有深入了解的不多。

如果我们对此有足够的了解，上面的例子就是小菜一碟。但我猜很多读者看到这几个例子都要琢磨一番。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">遗憾的是JS规范对运算符优先级并没有一个统一的介绍。你需要从语法规则中逐步了解。所以我们在这里尽量列出那些常见和有用的。完整的优先级列表参见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN</a>的“优先级列表”。</td>
    </tr>
</table>

####短路

我们在`第四章`的注解中提到过`&&`和`||`等运算符的“短路（short circuiting）”特性。这里对它做一个详细的介绍。

对于运算符`&&`和`||`来说，如果能够从左边的操作数得出结果，右边的操作数即可被略过。我们称之为“短路（short circuited）”（即执行最短路径）。

例如`a && b`，如果`a`是假值，这足以决定`&&`的结果，所以没有必要再判断`b`的值。同样对于`a || b`，如果`a`是真值，也足以决定`||`的结果，所以没有必要再判断`b`的值。

短路很有用，也很常用：

```
    function doSomething(opts) {
        if (opts && opts.cool) {
            // .. 
        }
    }
```

`opts && opts.cool`中的`opts`判断如同一个安全守卫，`opts`未赋值（或者不是一个`object`）时，表达式`opts.cool`会出错。此时`opts`为假值，由于`短路`特性，`opts.cool`不会被执行，从而不会产生错误！

我们也可以这样来使用`||`的短路特性：

```
    function doSomething(opts) {
        if (opts.cache || primeCache()) {
            // .. 
        }
    }
```

这里我们先判断`opts.cache`，如果它存在则无需调用`primeCache()`，这样可以避免不必要的工作量。

####更紧密的结合

让我们回顾下前面那个复杂的例子，即有很多运算符串联在一起。请特别注意`? :`三元运算符，它的优先级比`&&`和`||`高还是低，是这样？

```
    a && b || c ? c || b ? a : c && b : a
```

或是这样？

```
    a && b || (c ? c || (b ? a : c) && b : a)
```

还是这样？

```
    (a && b || c) ? (c || b) ? a : (c && b) : a
```

答案是第二种情况。

因为`&&`的优先级高于`||`，`||`的优先级又高于`? :`。

所以表达式`(a && b || c)`先于包含它的`? :`执行。另一种常见的说法，是`&&`和`||`比`? :`的结合性更强（bind more tightly）。如果反过来`c ? c...`的结合性更强，则它会首先执行（即` a && b || (c ? c..)`）。

#####关联性

运算符`&&`和`||`先执行，然后是`? :`。如果多个相同优先级的运算符同时出现呢？它们是否是按从左到右或者从右到左的顺序执行？

通常运算符不是从左到右关联（left-associative）就是从右到左关联（right-associative），取决于组合（grouping）是从左开始还是从右开始。

请注意关联性*不同*于从左到右和从右到左的执行顺序。

但是执行顺序和它又有什么关系呢？这是因为表达式会有边缘效应，比如函数调用：

```
    var a = foo() && bar();
```

这里`foo()`首先执行，然后根据它的返回结果，`bar()`有可能接着执行。所以如果`bar()`在`foo()`之前执行情况会完全不同。

这只是从左到右的情况（JavaScript的默认顺序！），与`&&`的关联性无关。因为上例中只有一个`&&`，所以不涉及组合，也不涉及关联性。

`a && b && c`这样的表达式就涉及到隐式组合，即`a && b`或者`b && c`会首先执行。

从技术角度来说，因为`&&`是左关联（`||`也是），所以`a && b && c`会被处理为`(a && b) && c`。然而右关联如`a && (b && c)`结果也一样。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">设想如果<b>&amp;&amp;</b>是右关联，它会被处理为<b>a &amp;&amp; (b &amp;&amp;c)</b>。但这并不代表<b>c</b>会在<b>b</b>之前执行。右关联的意思不是从右到左执行，而是从右到左进行<i>组合（grouping）</i>。任何时候执行顺序都是a，b，然后c，从左到右。</td>
    </tr>
</table>

所以`&&`和`||`是不是左关联这个问题本身并不重要，只要我们对它们有一个准确的定义。

但情况并非总是这样。有一些运算符左关联和右关联的表现截然不同。

比如运算符`? :`（即三元运算符或者条件运算符）：

```
    a ? b : c ? d : e;
```

`? :`是右关联的，它的组合顺序是下面哪一种呢？

```
• a ? b : (c ? d : e)

• (a ? b : c) ? d : e
```

答案是`a ? b : (c ? d : e)`。和`&&`和`||`的情况不同，右关联在这里会影响到返回结果，因为`(a ? b : c) ? d : e`对某些值（并非所有）的处理方式会有不同。

举个例子：

```
    true ? false : true ? true : true;      // false

    true ? false : (true ? true : true);    // false
    (true ? false : true) ? true : true;    // true
```

有些值的差别更加微妙，即使它们返回的结果相同。例如：

```
    true ? false : true ? true : false;     // false
    
    true ? false : (true ? true : false);   // false
    (true ? false : true) ? true : false;   // false
```

这里得到的结果相同，运算符组合看似没起什么作用。然而实际情况是这样的：

```
    var a = true, b = false, c = true, d = true, e = false;

    a ? b : (c ? d : e); // false, evaluates only `a` and `b`
    (a ? b : c) ? d : e; // false, evaluates `a`, `b` AND `e`
```

我们证实了`? :`的确是右关联，它串联的方式会影响返回结果。

右关联的另一个例子是`=`运算符。本章前面我们介绍过一个串联赋值的例子：

```
    var a, b, c;

    a = b = c = 42;
```

`a = b = c = 42`首先执行赋值表达式`c = 42`，然后是`b = ..`，最后是`a = ..`。其中原因就是右关联，实际上它是被处理为：`a = (b = (c = 42))`。

还记得本章前面那个复杂的赋值表达式吗？

```
    var a = 42;
    var b = "foo";
    var c = false;

    var d = a && b || c ? c || b ? a : c && b : a;
    
    d;      // 42
```

理解了运算符的优先级和关联性之后，现在我们可以根据组合规则将上面冗长的代码分解如下：

```
    ((a && b) || c) ? ((c || b) ? a : (c && b)) : a
```

或者通过缩进显式让其更容易理解：

```
    (
        (a && b)
            || 
        c
    )
        ?
    (
        (c || b)
            ? 
        a
            :
        (c && b)
    ) 
        :
    a
```

我们来逐个执行：

- (a && b) 结果为`"foo"`。
- `"foo" || c`结果为`"foo"`。
- 第一个`?`中，`"foo"`为真值。
- `(c || b)`结果为`"foo"`。
- 第二个`?`中，`"foo"`为真值。
- `a`的值为`42`。

最后结果是`42`。整个过程并不难，是吧？

#####释疑

现在你应该对运算符优先级（和关联性）有了一个深入的了解，也可以读懂多个运算符串联的代码了。

不过仍然有一个重要的问题：我们在编码时是否只需要遵守和理解运算符优先级和关联性的规则即可？是否该在必要时使用`( )`来自行控制运算符的结合和执行顺序？

换句话说，尽管这些规则可以通过学习来掌握，但其中也有很多坑，我们是否应避免单纯依赖这些优先级和关联性规则？如果答案是肯定的，我们是否应该使用`( )`来自行控制，而非依赖规则本身？

和`第四章`中的*隐式*强制类型转换一样，这是个很主观的话题。对于这两者大多数开发人员的看法都是：或者完全依赖于它们的规则来编码，或者彻底避免而使用显式和自行控制的方式。

和`第四章`不同，对这个问题我并没有一个确切的答案。我们已经介绍了它们各自的优缺点，希望能够帮助你加深理解，从而做出自己的判断。

我个人的观点是，依赖运算符优先级／关联性规则和使用`( )`自行控制运算符的结合两者都应兼顾，对`第四章`中的*隐式*强制类型转换也是如此，我们应该安全合理地运用它们，而非无节制地滥用。

不如我觉得`if (a && b && c) ..`没问题，就不需要用`if ((a && b) && c) ..`来明确关联性，因为这样过于繁琐。

然而如果需要串联两个`? :`运算符的话，我就会使用`( )`来自行控制运算符的组合，以便让代码更清晰易读。

这里我的建议和`第四章`一样：如果运算符优先级／关联性规则能够令代码更简洁，就用。如果自行加入`( )`有助于提高代码可读性，就用。

####自动分号

有时JavaScript会自动为代码行加上缺失的分号，即自动分号插入（ASI，Automatic Semicolon Insertion）。

因为如果代码缺失了必要的`;`将无法执行。这样一来语言的容错性就不是很高。ASI使得我们在某些情况下可以忽略那些（我们认为）不必要的`;`。

记住，ASI只在换行符（即line break）处起作用，不会在代码行的中间插入分号。

JS解析器在解析代码时，如果发现代码因为缺失分号可能导致错误，就会自动插入分号。并且只有代码行末尾与换行符之间除了空格和注释以外没有别的内容时，才会自动插入分号。

例如：

```
    var a = 42, b 
    c;
```

如何来解析`c`呢？假设`b`和`c`之间出现`a ,`的话（可以另起一行）,`c`会被作为`var`语句的一部分来处理。否则JS判断`b`之后应该出现`;`。因此`c;`被当作一个单独的表达式语句来处理。

又比如：

```
    var a = 42, b = "foo";
    
    a
    b // "foo"
```

这样的代码也没问题，不会产生错误，因为ASI也适用于表达式语句。

ASI在一些特定情况下很有用，比如：

```
    var a = 42;

    do {
            // ..
    } while (a) // <-- ; expected here!
    a;
```

语法规定`do..while`后必须带`;`，`while`和`for`则不需要。大部分人不记得这一点，此时ASI就会自动加上分号。

本章前面介绍过，语句代码块结尾不用带`;`，所以不需要ASI：

```
    var a = 42;
    
    while (a) {
        // ..
    } // <-- no ; expected here
    a;
```

其它涉及到ASI的地方是`break`，`continue`，`return`和`yield`（ES6）等关键字：

```
    function foo(a) {
        if (!a) return
        a *= 2;
        // .. 
    }
```

由于ASI会在`return`后自动加上`;`，所以这里的`return`语句并不包括第二行的`a *= 2`。当然`return`语句的跨度可以是很多行，但是其后必须有换行符以外的代码：

```
    function foo(a) {
        return (
            a * 2 + 3 / 12 
        );
    }
```

同样的规则对`break`，`continue`，和`yield`也适用。

####纠错

JS社区中最具争议的主题之一（除了tab和空格之争以外），是我们是该完全依赖ASI，还是尽量避免。

分号在大多数情况下（不是所有）并不是必须的，但是`for( .. ) ..`循环头部的两个分号是必须的。

正方认为ASI机制很有用，能够为我们省掉那些不必要的`;`（必要的情况不多），从而令代码更简洁。我们通常认为是ASI让很多`;`成为可选，所以只要代码没问题有没有`;`都一样。

反方则认为这里面有太多坑，特别是对于缺乏经验的初学者来说，自动插入`;`会无意中改变代码的逻辑。还有一些开发人员认为忽略分号本身就是错误的，他们倾向使用linter等工具来发现这些错误，而不是依赖于JS引擎。

我的理解是这样的，如果我们仔细阅读规范就会发现ASI实际上是一个“纠错（error correction）”机制。这里的错误是*解析器错误（parser error）*。换句话说就是让解析器容错性更高。

哪些情况下需要容错呢？在我看来解析器报错只有一个原因，就是代码有问题。ASI纠错过程中，只有一种情况下会遇到解析器报错，就是代码中缺少了那些必要的分号。

我的理解是，在代码中省略那些“不必要的分号”意味着“这些代码解析器无法解析，但是仍然可以运行”。

如果仅仅是为了省去一些键盘输入和追求“更美观的代码”，这样做显得有些得不偿失。

并且我也不觉得这和空格与tab之争是一回事，后者仅涉及代码的美观，前者则关系到是否应该遵循语法规则来编码，还是游离于规则之外。

换个角度来看，ASI实际上是将换行符视作有意义的“空格”。空格在其他语言如Python中是有意义的。但为JavaScript中的换行符赋予意义是否合适？

我的看法是应该在所有需要的地方加上分号，将对ASI的依赖降到最低限度。

我并不是一个人在战斗。早在2012年，JavaScript的创造者Brendan Eich这样说过：

*ASI是一个语法纠错机制。如果我们在编码中将换行符当作有意义的字符来对待，会遇到很多问题。我希望在1999年5月的那十天里（ECMAScript规范制定的时间），我能够让换行符承载更多的意义。切不要认为ASI真的会将换行符当作有意义的字符。*

####错误

JavaScript不仅有各种不同类型的运行时错误（`TypeError`，`ReferenceError`，`SyntaxError`等），它的语法规则也定义了一些编译时错误。

代码中某些特定的情况会被处理为“前期错误（early errors）”（编译时）。那些明显的语法错误就是前期错误的一种（如：`a = ,`），还有就是一些语法正确但规则不允许的情况。

代码执行之前，这些错误是无法用`try...catch;`来捕获的，因此它们会导致解析（parsing）／编译（compilation）错误。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">规范对于浏览器（和开发工具）怎样报错没有明确规定。因此下面的例子在不同的浏览器中的处理方式会有不同，包括错误类型和错误信息的显示。</td>
    </tr>
</table>

一个简单的例子是正则表达式常量中的语法。这里JS语法没有问题，但非法的正则表达式也会产生前期错误：

```
    var a = /+foo/;     // Error!
```

赋值对象必须是一个标识符（identifier，或者ES6中的解构表达式destructuring expression），因此下面的`42`是非法的，会报错：

```
    var a;
    42 = a;     // Error!
```

ES5规范的`严格（strict）`模式定义了更多的前期错误。比如在`严格`模式中，函数的参数不能重名：

```
    function foo(a,b,a) { }                 // just fine
    function bar(a,b,a) { "use strict"; }   // Error!
```

另一个`严格`模式前期错误是对象常量包含多个同名属性：

```
    (function(){
        "use strict";
        
        var a = { 
            b: 42,
            b: 43
        };          // Error!
    })();
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从语义角度来说，这些错误并非<i>词法错误（syntax errors）</i>，而是<i>语法错误（grammar errors）</i>－－因为它们在词法上是正确的。但是由于不存在<b>GrammarError</b>类型，一些浏览器也用<b>SyntaxError</b>来代替。</td>
    </tr>
</table>

####提早使用变量

ES6规范中有一个新概念叫做TDZ（Temporal Dead Zone，名字十分的不明觉厉）。

TDZ是指代码中的变量由于还没有初始化，所以在某些情况下不能使用。

最直观的例子是ES6规范中的`let`块作用域：

```
    {
        a = 2;      // ReferenceError!
        let a; 
    }
```

`a = 2`试图在`let a`初始化`a`之前使用该变量（作用域在`{ .. }`内），这是在`a`的TDZ内，会产生错误。

有意思的是对未声明（undeclared）的变量使用`typeof`却不会产生错误（参见`第一章`）：

```
{
    typeof a;   // undefined
    typeof b;   // ReferenceError! (TDZ)
    let b;
}
```

###函数参数

另一个违反TDZ规则的例子，是ES6中的参数缺省值（参见本系列的*ES6 & Beyond*）：

```
    var b = 3;

    function foo( a = 42, b = a + b + 5 ) {
        // ..
    }
```

`b = a + b + 5`试图在参数`b`的TDZ中访问`b`（并非函数外的那个`b`），因此会出错。然而访问`a`却没有问题，因为其刚好越过了参数`a`的TDZ。

在ES6中，如果某个参数被省略或者值为`undefined`，则使用它的缺省值：

```
    function foo( a = 42, b = a + 1 ) {
        console.log( a, b );
    }

    foo();              // 42 43
    foo( undefined );   // 42 43
    foo( 5 );           // 5 6
    foo( void 0, 7 );   // 42 7
    foo( null );        // null 1
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">在表达式<b>a + 1</b>中<b>null</b>被强制类型转换为<b>0</b>。详情请参见<b>第四章</b>。</td>
    </tr>
</table>

这里省略掉参数和传递`undefined`值效果是一样的。然而它们之间的区别还是可以通过某些形式体现出来：

```
    function foo( a = 42, b = a + 1 ) {
        console.log(
            arguments.length, a, b,
            arguments[0], arguments[1]
        );
    ￼}

    foo();                  // 0 42 43 undefined undefined
    foo( 10 );              // 1 10 11 10 undefined
    foo( 10, undefined );   // 2 10 11 10 undefined
    foo( 10, null );        // 2 10 null 10 null
```

虽然参数`a`和`b`都有缺省值，但是如果没有向函数传递参数则`arguments`为空。

相反如果向函数传递`undefined`值，则`arguments`数组中会对应出现一个单元，其值为`undefined`而非缺省值。

ES6的参数缺省值会导致`arguments`数组和命名参数变量之间出现偏差，同样的情况也会出现在ES5中：

```
    function foo(a) {
        a = 42;
        console.log( arguments[0] );
    }

    foo( 2 );   // 42 (linked)
    foo();      // undefined (not linked)
```

如果向函数传递参数，`arguments`数组中的对应单元会和命名参数建立关联（linkage）以获得相同的值。如果不传递参数就不会建立关联。

但是在`严格`模式中并没有建立关联这一说：

```
    function foo(a) {
        "use strict";
        a = 42;
        console.log( arguments[0] );
    }

    foo( 2 );   // 2 (not linked)
    foo();      // undefined (not linked)
```

所以依赖这种关联并不好，实际上它来自于JavaScript语言引擎的底层实现，语言本身并无此特性。

虽然并非一无是处，但`arguments`数组已经被废止（特别是ES6引入剩余参数`...`（rest parameters）之后，参见本系列的*《ES6 & Beyond》*）。

在ES6之前，获得传递给函数的所有参数的唯一途径就是`arguments`数组，它非常有用。我们还可以将命名参数和`arguments`数组混用，只要遵守一个原则就不会有问题，即*永远不要同时访问命名参数和其对应的`arguments`数组单元*。这样就能确保不会出现关联泄露（leaky linkage）：

```
   function foo(a) {
        console.log( a + arguments[1] ); // safe!
    }

    foo( 10, 32 );  // 42
```

####try..finally

我们对`try..catch`可能已经非常熟悉了。但你是否知道`try`可以与`catch`和`finally`其中之一配对使用，必要时两者也可以同时出现？

`finally`中的代码总是会在`try`（和`catch`，如果存在的话）之后执行。也可以将`finally`中的代码看作一个回调函数，无论出现什么情况最后一定会被调用。

`try`中如果包含`return`语句会出现什么情况呢？很显然`return`会产生一个返回值，那么调用该函数并获得这个返回值的代码是在`finally`之前执行还是之后呢？

```
    function foo() {
            try {
                return 42;
            } 
            finally {
                console.log( "Hello" );
            }

            console.log( "never runs" );
    }

    console.log( foo() );
    // Hello
    // 42
```

首先执行`return 42`，它将`foo()`函数的返回值设置为`42`。此时`try`执行完毕，`finally`接着执行。最后`foo()`函数执行完毕，它的返回值由`console.log(..)`显示。

`try`中的`throw`也是如此：

```
    function foo() {
        try {
            throw 42; 
        }
        finally {
            console.log( "Hello" );
        }

      console.log( "never runs" );
    }

    console.log( foo() );
    // Hello
    // Uncaught Exception: 42
```

如果`finally`中抛出一个异常（无论有意还是无意），函数就会在此处终结。如果`try`中已经有`return`设置了一个返回值，则该值会被丢弃：

```
    function foo() {
        try {
            return 42;
        } 
        finally {
            throw "Oops!";
        }

        console.log( "never runs" );
    }
    
    console.log( foo() );
    // Uncaught Exception: Oops!
```

`continue`和`break`也是如此：

```
    for (var i=0; i<10; i++) {
        try {
            continue; 
        }
        finally {
            console.log( i );
        }
    }
    // 0 1 2 3 4 5 6 7 8 9
```

`continue`使得`console.log(i)`在每次循环之后，`i++`之前执行，所以结果是`0..9`而非`1..10`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">ES6中新增了<b>yield</b>（参见本系列的<i>《Async &amp; Performance》</i>），可以将其视为<b>return</b>的中间版本。然而与<b>return</b>不同的是，yield在generator（ES6的另一个新特性）恢复时才告结束，这意味着<b>try { .. yield .. }</b>并未结束，因此对应的<b>finally</b>不会在<b>yield</b>之后立即执行，这一点和<b>return</b>不同。</td>
    </tr>
</table>

`finally`中的`return`将会覆盖`try`和`catch`中的`return`的返回值：

```
    function foo() {
        try {
            return 42;
        } 
        finally {
            // no `return ..` here, so no override
        } 
    }
    
    function bar() {
        try {
            return 42;
        }
        finally {
            // override previous `return 42`
            return; 
        }
    }

    function baz() {
        try {
            return 42;
        } 
        finally {
            // override previous `return 42`
            return "Hello";
        }
    }

    foo();  // 42
    bar();  // undefined
    baz();  // Hello
```

通常来说，在函数中省略`return`与`return;`和`return undefined;`结果是一样的，但是在`finally`中省略`return`则会返回前面的`return`值。

我们还可以将`finally`和带标签的`break`混合使用（参见`第131页的“标签”`）：

```
    function foo() {
        bar: {
            try {
                return 42;
            } 
            finally {
                // break out of `bar` labeled block
                break bar;
            }
        }
        
        console.log( "Crazy" );
        
        return "Hello";
    }

    console.log( foo() );
    // Crazy
    // Hello
```

千万不要这样做。用`finally`加`break`来跳过`return`会让代码变得非常难以理解。即便加上注释也很难解释清楚。

####switch

我们来简单介绍一下`switch`，可以把它看作`if..else if..else..`的简化语法：

```
    switch (a) {
        case 2:
            // do something
            break;
        case 42:
            // do another thing
            break;
        default:
            // fallback to here
    }
```

这里`a`与`case`表达式中的值逐一进行比较（本例中仅是简单的值表达式）。如果找到匹配的值就执行对应`case`中的代码，直到`break`或是`switch`代码块结束。

看起来没有什么特别，但`switch`也有几处不太为人知的坑。

首先`a`和`each`是通过`===`（见`第四章`）来进行相等比较。多数情况下`switch`中的`case`都是使用简单的值，所以这样并没有问题。

然而有时我们可能需要通过强制类型转换来进行相等比较（即`==`，见`第四章`），这时就要在`switch`中做一些特殊处理：

```
    var a = "42";

    switch (true) {
        case a == 10:
            console.log( "10 or '10'" );
            break;
        case a == 42;
            console.log( "42 or '42`" );
            break;
        default:
            // never gets here
    }
    // 42 or '42'
```

除了简单值之外，`case`中还可以出现各种表达式，它会将表达式的结果值和`true`进行比较。因为`a == 42`的结果为`true`，所以条件成立。

尽管可以使用`==`，但`switch`中`true`和`true`之间仍然是严格相等比较。即如果`case`表达式的结果为真值，但不是严格意义上的`true`（见`第四章`），则条件不成立。所以如果在这里使用`||`和`&&`“逻辑运算符”就很容易掉坑里：

```
    var a = "hello world";
    var b = 10;

    switch (true) {
        case (a || b == 10):
            // never gets here
            break;
        default:
            console.log( "Oops" );
    }
    // Oops
```

因为`(a || b == 10)`的结果是`"hello world"`而非`true`，所以严格相等比较不成立。这种情况下我们可以强制表达式返回`true`或`false`，如：`case !!(a || b == 10):`（见`第四章`）。

最后要说明`default`是可选的，并非必需（虽然惯例是如此）。有关`break`的规则对`default`仍然适用：

```
    var a = 10;

    switch (a) {
            case 1:
            case 2:
                    // never gets here
            default:
                    console.log( "default" );
            case 3:
                    console.log( "3" );
                    break;
            case 4:
                    console.log( "4" );
    }
    // default
    // 3
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">之前我们介绍过，case从句中的break也能够带标签。</td>
    </tr>
</table>

上例中的代码是这样执行的，首先遍历并找到所有匹配的`case`，如果没有匹配则执行`default`中的代码。因为其中没有`break`，所以继续执行已经遍历过的`case 3`代码块，直到`break`为止。

这种情况在JavaScript中是可能出现的，但是现实中一般不会发生。如果我们确实需要这样来编写代码，就应该仔细斟酌并做好注释。

###回顾

JavaScript语法规则中有许多细节需要我们花时间加以了解。长远来看这有助我们更加深入地掌握这门语言。

语句（statements）和表达式（expressions）在英语中有对应的称谓－语句就象句子（sentences），而表达式就象短句（phrases）。表达式可以是简单独立的，也可能产生边缘效应。

JavaScript语法规则中，单纯的语法规则之上是语义规则（也称作上下文）。例如，`{ }`在不同的情况下意义不尽相同，可以是语句块，`object`常量，解构赋值（ES6），或者命名函数参数（ES6）。

JavaScript详细定义了运算符的优先级（运算符执行的先后顺序）和关联性（表达式中的多个运算符如何组合）。一旦掌握了这些规则，我们就能够自己作出判断，是否通过它们来提高代码的易读性，或者因为它们过于晦涩而避之不及。

ASI（自动分号插入）是JS引擎中的一个代码解析纠错机制，在某些特定情况下它会在需要的地方自动插入分号来纠正解析错误。问题在于这是否意味着大多数的分号都不是必需的（因而可以被省略），或者由于省略分号而导致的错误都可以交给JS引擎来处理。

JavaScript中有很多错误类型，它们分为两大类：“早期错误”（编译时错误，无法被捕获）和“运行时错误”（可以通过`try..catch`捕获）。所有的语法错误都是早期错误，会导致程序无法运行。

函数参数和命名参数之间的关系非常微妙。尤其是`arguments`数组，由于它的抽象泄漏导致了一些坑的存在。尽量不要使用`arguments`，如果非要用的话也不要同时使用`arguments`及其对应的命名参数。

`try`（或者`try..catch`）结尾的`finally`的执行顺序的一些特点需要我们多加注意。其中有一些非常有用，但也会带来困扰，特别是和带标签的代码块配合使用时。总之使用`finally`的目的是让代码更简洁易读，而非适得其反。

`switch`相对`if..else if..`来说更简洁，但需要注意的是，我们对它的理解可能不是很透彻，如果不小心很容易掉到坑里。

------

###附录
<hr>
##混合环境JavaScript

除了我们之前介绍过的核心的语言机制，你的JS程序在实际运行中还会出现一些差异。如果JS程序仅是在引擎中运行的话，它是严格遵循规范并且可以预测的。但是JS程序几乎总是运行在宿主环境中，这使得它一定程度上变得不可预测。

例如当你的代码和其他第三方代码一起运行，或者当你的代码在不同的JS引擎上运行（并非仅仅是浏览器），在有些情况下会出现差异。

下面我们将就此做一些介绍。

###Annex B(ECMAScript)

JavaScript语言的官方名称是ECMAScript（指的是管理它的ECMA标准），这一点不太为人所知。那么“JavaScript”又是指什么呢？JavaScript是该语言的通用称谓，更确切地说，它是该规范在浏览器上的实现。

官方ECMAScript规范包括了“Annex B”，其中介绍了由于浏览器兼容性导致的与官方规范的差异。

可以这样来理解，这些差异只存在于浏览器中。如果你的代码只会在浏览器中运行，你不会发现任何差异。否则（如果代码也在node.js，Rhino等环境中运行），或者你也不确定的时候，就需要小心对待。

下面是一些主要的兼容性差异：

- 在非严格模式中允许八进制数值常量，如`0123`（十进制的`83`）。
- `window.escape(..)`和`window.unescape(..)`让你能够escape和unescape(JJ--??)带有%分隔符的十六进制字符串。例如：`window.escape("? foo=97%&bar=3%")`的结果为`"%3Ffoo%3D97%25%26bar%3D3%25"`。
- `String.prototype.substr`和`String.prototype.substring`十分相似，除了前者第二个参数是结束位置索引（非自包含），后者第二个参数是`长度`（需要包含的字符数）。

###Web ECMAScript

`Web ECMAScript规范`中介绍了官方ECMAScript规范和目前基于浏览器的JavaScript实现之间的差异。

换句话说，其中的内容对于浏览器来说是”必需的“（考虑到兼容性），但是没有包含在官方规范的”Annex B“部分（到本书写作时）：

- <!-- 和 -->是合法的单行注释符。
- `String.prototype`中返回HTML格式字符串的附加方法：`anchor(..)`，`big(..)`，`blink(..)`，`bold(..)`，`fixed(..)`，`fontcolor(..)`，`fontsize(..)`，`italics(..)`，`link(..)`，`small(..)`，`strike(..)`，和`sub(..)`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">以上的内容在实际开发中很少使用，也不推荐，我们相对更倾向使用其他的内建DOM API和自定义工具集。</td>
    </tr>
</table>

- `RegExp`扩展：`RegExp.$1 .. RegExp.$9`（匹配组）
和`RegExp.lastMatch/RegExp["$&"]`（最近匹配）。
- `Function.prototype`附加方法：`Function.prototype.arguments`（别名为`arguments`对象）和`Function.caller`（别名为`arguments.caller`）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warnning.png'></td>
        <td style="border: none;">arguments和arguments.caller均已经被废弃，所以尽可能不要使用它们。也不要使用它们的别名。</td>
    </tr>
</table>

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">一些不常见和很细微的差异我们这里就不做介绍了。如有需要，详情可参考文档“Annex B”和“Web ECMAScript”。</td>
    </tr>
</table>

通常来说出现这些差异的情况很少，所以并不需要特别担心。只是在使用它们的时候要特别注意。

###宿主对象

JS中有关变量的规则定义得很清楚，但有时候也会出现例外情况，比如自动定义的变量，以及由宿主环境（浏览器等）提供给JS引擎的变量－我们称之为“宿主对象”（包括内建对象和函数）。

例如：

```
    var a = document.createElement( "div" );
    
    typeof a;                            // "object"--as expected
    Object.prototype.toString.call( a ); // "[object HTMLDivElement]"
    
    a.tagName;                           // "DIV"
```

`a`不仅仅是一个`object`，还是一个特殊的宿主对象，因为它是一个DOM元素。其内部的`[[Class]]`值（为`"HTMLDivElement"`）来自预定义的属性（通常也是不可更改的）。

另外一个难点我们之前在`第四章`中的“假值对象”部分介绍过：一些对象在强制转换为`boolean`时会意外地成为`假值`而非`真值`，这很让人挠头。

另外一些需要我们注意的宿主对象的行为差异有：

- 无法访问正常的`object`内建方法，如`toString()`
- 无法写覆盖
- 包含一些预定义的只读属性
- 包含一些无法被其他对象this重载(JJ--??)的方法
- 其他......

在我们针对运行环境编码时，宿主对象扮演着一个十分关键的角色。但是我们对它们的特性要非常注意，因为它们常常有别于普通的JS`object`。

在我们经常打交道的宿主对象中，`console`应该是比较值得一提的，它包含了许多方法（`log(..)`，`error(..)`等）。`console`对象由宿主环境提供，以便让我们能够从代码中输出各种值。

`console`在浏览器中是输出到开发工具控制台，而在node.js和其他服务器端JS环境中则是指向JavaScript环境系统进程的标准输出（`stdout`）和标准错误输出（`stderr`）。

###全局DOM变量

你可能已经知道声明一个全局变量（使用var或者不使用）的结果并非仅仅是创建了一个全局变量，并且还会在`global`对象（在浏览器中为`window`）中创建一个同名属性。

但还有一个不太为人所知的事实是，由于浏览器演进的历史遗留的关系，在创建带有`id`属性的DOM元素的时候也会创建同名的全局变量。例如：

```
     <div id="foo"></div>
```

以及：

```
    if (typeof foo == "undefined") {
        foo = 42;        // will never run
    }

    console.log( foo );  // HTML element
```

你可能已经习惯使用`typeof`或`.. in window`来检测全局变量，认为只有JS代码才会创建它们，但是如上例所示，HTML页面中的内容也会产生全局变量，如果不注意的话很容易让你的全局变量检查变得错误百出。

这是为什么我们尽量不要使用全局变量的一个原因，如果确实要用，也要确保变量名的唯一性从而避免与其他地方的变量产生冲突，包括HTML和其他第三方代码。

###原生原型

一个广为人知的JavaScript的最佳实践之一是：不要扩展原生原型。

如果你向`Array.prototype`加入了新的方法和属性，如果它们确实有用，设计和命名都很得当，最后很有可能会被加入到JS规范当中，这样一来你所做的扩展就会与之冲突。

我自己就遇到过一个这样的例子。

当时我正在为一些网站开发一个嵌入式构件，基于jQuery（基本上所有的框架都会犯这样的错误）。基本上在所有的网站上都可以运行，但是在某个网站上彻底无法运行。

在差不多一个星期的分析调试之后，我发现这个网站有一段遗留代码，象下面这样：

```
    // Netscape 4 doesn't have Array.push
    Array.prototype.push = function(item) {
        this[this.length-1] = item;
    };
```

除了注释以外（谁还会关心Netscape 4呢？），它看起来没有什么问题，是吧？

问题在于`Array.prototype.push`在随后被加入到了规范中，并且和这段代码不兼容。标准的`push(..)`可以一次加入多个值。而这段代码中的`push`方法则只会处理第一个值。

最初加入这个方法的开发人员将其命名为`push`合情合理，但是没有意识到需要处理多个值。这相当于挖了一个坑，10年之后让我掉了进去。

从这里我们得到几个教训。

首先，不要扩展原生方法，除非你确信你的代码在运行环境中不会有冲突。如果你不是100%确定而进行扩展是非常危险的。这需要你自己仔细权衡利弊。

其次，在扩展原生方法时加入判断条件（因为你可能无意中覆盖了原来的方法）。对于前面的例子，下面的处理方式更好些：

```
    if (!Array.prototype.push) {
        // Netscape 4 doesn't have Array.push
        Array.prototype.push = function(item) {
            this[this.length-1] = item;
        };
    }
```

`if`语句确保如果JS运行环境中没有`push()`方法时才将扩展加入。这应该可以解决我的问题，但是即使这样也存在着一定的隐患：

1. 如果网站代码中的`push(..)`原本就不打算处理多个值的情况，则标准的`push(..)`出台后会导致代码运行出错。

2. 如果在`if`判断前引入了其他第三方的`push(..)`方法，并且该方法的功能不同，也会导致代码运行出错。

这里显现出一个不太为JS开发人员注意的问题：在各种第三方代码混合运行的环境中是否只应该使用现有的原生方法。

答案是否定的，但是实际上不太行得通。通常你无法重新定义所有会用到的原生方法，同时确保它们的安全。即使可以也是一种浪费。

那么我们是否应该既测试原生方法是否存在，又测试它是否执行我们想要的功能？如果测试没通过怎么办，是不是代码停止执行？

```
    // don't trust Array.prototype.push
    (function(){
        if (Array.prototype.push) {
            var a = [];
            a.push(1,2);
            if (a[0] === 1 && a[1] === 2) {
                // tests passed, safe to use!
                return; 
            }
        }

        throw Error(
            "Array#push() is missing/broken!"
        ); 
    })();
```

理论上说这个方法不错，但实际上我们不可能为每个原生函数都做这样的测试。

那怎么办呢？我们是否应该逐一做测试？还是假设一切没问题，等出现问题时再做处理？

这里没有标准答案。实际上如果我们不去自己扩展原生原型的话就不会遇到这类问题。

如果你和第三方代码都遵循上面的原则，恭喜你，你是安全的。否则你对你的程序需要多加一些谨慎和小心，以防任何可能出现的这类问题。

针对各种运行环境做单元和回归测试能够早一些发现这类问题，但是却不能够杜绝之。

###Shims／Polyfills(JJ--??)

通常来说在老版本的（不符合规范的）运行环境中扩展原生方法是唯一安全的，因为环境不太可能有变化－老版本的浏览器会被支持新规范的新版本浏览器完全替代，而非在老版本上做扩展。

如果你能够预见哪些方法将来会成为新的标准，如`Array.prototype.foobar`，你完全可以放心地使用当前的扩展版本，不是吗？

```
    if (!Array.prototype.foobar) {
        // silly, silly
        Array.prototype.foobar = function() {
            this.push( "foo", "bar" );
        }; 
    }
```

如果规范中已经定义了`Array.prototype.foobar`，并且功能和上面的代码类似，那就没有什么问题，这种情况我们称为“polyfill”（或者“shim”）。

它可以有效地为那些不符合最新规范的老浏览器填补上缺失的功能。Polyfills让你能够通过可靠的代码来支持所有你想要支持的运行环境。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">ES5-Shim是一个完整的shims／polyfills集合，能够为你的项目提供ES5基本规范支持，同样地，ES6-Shim提供了对ES6的支持。虽然我们可以通过shims／polyfills来填补新的API，但是无法填补新的语法。我们可以使用Traceur这样的工具来实现新旧语法之间的转换。</td>
    </tr>
</table>

对于那些将来可能成为标准的功能，按照大部份人赞同的方式来预先实现以便和将来的标准兼容的polyfill，我们称为“prollyfill”（probably fill）。

真正的问题在于有一些标准功能没办法被完整地polyfill／prollyfill。

JS社区存在这样的争论，是否可以对一个功能做不完整的polyfill（将无法polyfill的部分文档化），或者不做则已，要做就要达到100%符合规范。

很多人可以接受一些不完整的polyfill（如`Object.create(..)`），因为缺失的那部分也不会被用到。

一些人认为在polyfill／shim中的`if`判断里需要加入一些兼容性测试，只在被测试的功能不存在或者未通过测试时才将其替换。这也是我们区别“shim“（有兼容性测试）和”polyfill“（检查功能是否存在）的方式。

最终的答案是没有正确答案。即便使用了“安全”的做法，对原生功能进行扩展也无法做到100%安全。依赖第三方代码中的原生功能也是这样，因为这些功能有可能被扩展了。

我们在处理这些情况的时候都需要格外小心，编写健壮的代码，并且写好文档。

###<script>s

绝大部分网站／Web应用程序的代码都存放在多个文件中，通常我们在网页中使用`<scriopt src=..></script>`来加载这些文件，或者使用`<script> .. </script>`来包含内联代码（inline code）。

这些文件和内联代码是相互独立的JS程序还是一个整体呢？

答案是（也许会令人惊讶）它们的运行方式更象是相互独立的JS程序，但是也并非总是如此。

它们共享`global`对象（在浏览器中则是`window`），也就是说这些文件中的代码在这个共享的命名空间中运行，并相互交互。

如果某个`script`中定义了函数`foo()`，后面的`script`代码就可以访问并调用`foo()`，就象`foo()`在它内部被声明过一样。

但是全局变量作用域的提升机制（hoisting，参见本系列的《Scope & Closures》一书）在这些边界中不适用，因此无论是`<script> .. </script>`还是`<script src=..></script>`，下面的代码都无法运行（因为`foo()`还未被声明）：

```
    <script>foo();</script>

    <script>
      function foo() { .. }
    </script>
```

但是下面的两段代码则没问题：

```
    <script>
      foo();
      function foo() { .. }
    </script>
```

和：

```
    <script>
      function foo() { .. }
    </script>

    <script>foo();</script>
```

如果`script`中的代码（无论是内联代码还是外部代码）发生错误，它会象独立的JS程序那样停止，但是后续的`script`中的代码（仍然共享`global`）依然会接着运行，不会受影响。

你可以使用代码来动态创建`script`，将其加入到页面的DOM中，效果是一样的：

```
    var greeting = "Hello World";

    var el = document.createElement( "script" );
    
    el.text = "function foo(){ alert( greeting );\
     } setTimeout( foo, 1000 );";

    document.body.appendChild( el );
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">如果你将el.src的值设置为一个文件URL的话，就可以实现通过&lt;script src=..&gt;&lt;/script&gt;动态加载外部文件。</td>
    </tr>
</table>

内联代码和外部文件中的代码之间有一个区别，在内联代码中不可以出现`</script>`字符串，一旦出现即被视为代码块结束。因此对下面这样的代码需要非常小心：

```
    <script>
      var code = "<script>alert( 'Hello World' )</script>";
    </script>
```

看起来似乎没什么问题，但是字符串常量中的`</script>`将会被当作结束标签来处理，因此会导致错误。常用的变通方法是：

```
    "</sc" + "ript>";
```

另外需要注意的是，我们是根据代码文件的字符集属性（UTF-8，ISO-8859-8等）来解析外部文件中的代码（或者缺省字符集），而内联代码则使用其所在页面文件的字符集（或者缺省字符集）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">内联代码的script标签没有charset属性。</td>
    </tr>
</table>

`script`标签的一个已经废弃的使用方法是在内联代码中包含HTML和XHTML格式的注释，如：

```
    <script>
    <!--
    alert( "Hello" );
    //-->
    </script>
    
    <script>
    <!--//--><![CDATA[//><!--
    alert( "World" );
    //--><!]]>
    </script>
```

现在我们已经不需要这样做了，所以不要再用继续使用它们。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">&lt;--和--&gt;（HTML格式的注释）在JavaScript中被定义为合法的单行注释分隔符（var x = 2; &lt;-- 是一行合法注释 和 --&gt; 是另一行合法注释），这时由于老的技术导致（详见之前的“Web ECMAScript”），但是不要再使用它们。</td>
    </tr>
</table>

###保留字

ES5规范在7.6.1节中定义了一些“保留字”，我们不能把它们用作变量名。这些保留字有四类：“关键字”，“预留关键字”，`null`常量，和`true`／`false``boolean`常量。

象`function`和`switch`这些都是关键字。预留关键字包括`enum`等，它们中很多已经在ES6中被用到（如`class`，`extend`等）。另外还有一些在严格模式中使用的保留字，如`interface`。

一个名为“art4theSould”的StackOverflow用户将这些保留字编成了一首`有趣的小诗`：

```
    Let this long package float,
    Goto private class if short.
    While protected with debugger case, Continue volatile interface. Instanceof super synchronized throw, Extends final export throws.

    Try import double enum?
    + False, boolean, abstract function, Implements typeof transient break! Void static, default do,

    Switch int native new.
    Else, delete null public var
    In return for const, true, char ...Finally catch byte.
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这首诗中包含了ES3中的保留字（byte, long等），它们在ES5中已经不再是保留字。</td>
    </tr>
</table>

在ES5之前，保留字也不能用来作为对象常量中的属性名称或者键值，但是现在已经没有这个限制。

例如我们不允许下面的情况：

```
    var import = "42";
```

但是下面的情况是允许的：

```
    var obj = { import: "42" };
    console.log( obj.import );
```

需要注意的是，在一些版本较老的浏览器中（主要是IE）这些规则并不完全适用，有时候将保留字用作对象属性还是会出错。所以你需要在所有要支持的浏览器中仔细测试。

###实现中的限制

JavaScript规范对于函数中参数的个数，和字符串常量的长度等并没有限制，但是由于JavaScript引擎实现的各异，规范在某些地方有一些限制。

例如：

```
    function addAll() {
            var sum = 0;
            for (var i=0; i < arguments.length; i++) {
                    sum += arguments[i];
            }
            return sum;
    }
    
    var nums = [];

    for (var i=1; i < 100000; i++) {
            nums.push(i);
    }
    
    addAll( 2, 4, 6 );           // 12
    addAll.apply( null, nums );  // should be: 499950000
```

在一些JS引擎中你会得到正确答案`499950000`，而另外一些引擎（如Safari 6.x）会产生错误“RangeError: Maximum call stack size exceeded.”。

这里我们列出一些已知的限制：

- 字符串常量中允许的最大字符数（并非只是针对字符串值）
- 可以作为参数传递到函数中的数据大小（也称为stack size，以byte为单位）
- 函数声明中的参数个数
- 未经优化的调用栈的最大层数（例如递归）：即函数调用链的最大长度
- JS程序以阻赛方式在浏览器中运行的最长时间（秒）
- 变量名的最大长度

我们并不太常会碰到这些限制，但是还是必须对它们有所了解，特别是不同的JS引擎的限制各异。

###回顾

JS语言本身有一个统一的标准，在所有浏览器／引擎中的实现也是可靠的。这时好事！

但是JavaScript很少独立运行。我们的运行环境中通常还有第三方代码，代码甚至会运行在浏览器之外的引擎／环境中。

如果我们对这些问题多加注意，就能够提高代码的可靠性和健壮性。

###附录B
##致谢

我要感谢许多人，是他们的帮助让本书以及整个系列得以出版。

首先要感谢我的妻子Christen Simpson和我的两个孩子Ethan和Emily，能够容忍我整天工作在电脑前。即使不写作的时候，我的眼睛也总是盯着屏幕做一些JavaScript相关的工作。我牺牲了很多陪伴家庭的时间，因此这个系列的丛书才能够为你深入全面地介绍JavaScript。我亏欠我的家庭太多太多。

我要感谢O'Reilly的编辑Simon St.Laurent和Brian MacDonald，以及所有其他的编辑和市场工作人员。和他们在一起工作非常愉快，在本系列丛书的实验过程中接受了开源图书的写作，编辑，和制作（JJ--??）。

我要感谢所有为本系列提供建议和校正的人，包括Shelley Powers，Tim Ferro，Evan Borden，Forrest L Norvell，Jennifer Davis，Jesse Harlin等。十分感谢David Walsh为本书作序。

我要感谢JavaScript社区中的许多人，包括TC39委员会的成员们，将他们的知识与读者和我分享，以及耐心想尽地回答我无休止的提问。他们是John-David Dalton，Juriy “kangax” Zaytsev，Mathias Bynens，Rick Waldron，Axel Rauschmayer，Nicholas Zakas，Angus Croll，Jordan Harband，Reginald Braithwaite，Dave Herman，Brendan Eich，Allen Wirfs-Brock，Brad‐ ley Meck，Domenic Denicola，David Walsh，Tim Disney，Kris Kowal，Peter van der Zee，Andrea Giammarchi，Kit Cambridge等等，还有太多的人我无法一一感谢。

《你不知道的JS》系列丛书是从Kickstarter发起的，我要感谢我的近500名慷慨的支持者，没有他们的支持就没有这套系列丛书：

Jan Szpila，nokiko，Murali Krishnamoorthy，Ryan Joy，Craig Patch‐ ett，pdqtrader，Dale Fukami，ray hatfield，R0drigo Perez [Mx]，Dan Petitt，Jack Franklin，Andrew Berry，Brian Grinstead，Rob Suther‐ land，Sergi Meseguer，Phillip Gourley，Mark Watson，Jeff Carouth，Alfredo Sumaran，Martin Sachse，Marcio Barrios，Dan，Aimely‐ neM，Matt Sullivan，Delnatte Pierre-Antoine，Jake Smith，Eugen Tudorancea，Iris，David Trinh，simonstl，Ray Daly，Uros Gruber，Justin Myers，Shai Zonis，Mom & Dad，Devin Clark，Dennis Palmer，Brian Panahi Johnson，Josh Marshall，Marshall，Dennis Kerr，Matt Steele，Erik Slagter，Sacah，Justin Rainbow，Christian Nilsson，Delapouite，D.Pereira，Nicolas Hoizey，George V. Reilly，Dan Reeves，Bruno Laturner，Chad Jennings，Shane King，Jeremiah Lee Cohick，od3n，Stan Yamane，Marko Vucinic，Jim B，Stephen Collins，Ægir Þorsteinsson，Eric Pederson，Owain，Nathan Smith，Jeanetteurphy，Alexandre ELISÉ，Chris Peterson，Rik Watson，Luke Matthews，Justin Lowery，Morten Nielsen，Vernon Kesner，Chetan Shenoy，Paul Tregoing，Marc Grabanski，Dion Almaer，Andrew Sul‐ livan，Keith Elsass，Tom Burke，Brian Ashenfelter，David Stuart，Karl Swedberg，Graeme，Brandon Hays，John Christopher，Gior，manoj reddy，Chad Smith，Jared Harbour，Minoru TODA，Chris Wigley，Daniel Mee，Mike，Handyface，Alex Jahraus，Carl Furrow，Rob Foulkrod，Max Shishkin，Leigh Penny Jr.，Robert Ferguson，Mike van Hoenselaar，Hasse Schougaard，rajan venkataguru，Jeff Adams，Trae Robbins，Rolf Langenhuijzen，Jorge Antunes，Alex Koloskov，Hugh Greenish，Tim Jones，Jose Ochoa，Michael Brennan-White，Naga Harish Muvva，Barkóczi Dávid，Kitt Hods‐ den，Paul McGraw，Sascha Goldhofer，Andrew Metcalf，Markus Krogh，Michael Mathews，Matt Jared，Juanfran，Georgie Kirschner，Kenny Lee，Ted Zhang，Amit Pahwa，Inbal Sinai，Dan Raine，Schabse Laks，Michael Tervoort，Alexandre Abreu，Alan Joseph Williams，NicolasD，Cindy Wong，Reg Braithwaite，LocalPCGuy，Jon Friskics，Chris Merriman，John Pena，Jacob Katz，Sue Lock‐ wood，Magnus Johansson，Jeremy Crapsey，Grzegorz Pawłowski，nico nuzzaci，Christine Wilks，Hans Bergren，charles montgomery，Ariel בר-לבב Fogel，Ivan Kolev，Daniel Campos，Hugh Wood，Christian Bradford，Frédéric Harper，Ionuţ Dan Popa，Jeff Trimble，Rupert Wood，Trey Carrico，Pancho Lopez，Joël kuijten，Tom A Marra，Jeff Jewiss，Jacob Rios，Paolo Di Stefano，Soledad Penades，Chris Gerber，Andrey Dolganov，Wil Moore III，Thomas Marti‐ neau，Kareem，Ben Thouret，Udi Nir，Morgan Laupies，jory carson- burson，Nathan L Smith，Eric Damon Walters，Derry Lozano- Hoyland，Geoffrey Wiseman，mkeehner，KatieK，Scott MacFarlane，Brian LaShomb，Adrien Mas，christopher ross，Ian Littman，Dan Atkinson，Elliot Jobe，Nick Dozier，Peter Wooley，John Hoover，dan，Martin A. Jackson，Héctor Fernando Hurtado，andy ennamorato，Paul Seltmann，Melissa Gore，Dave Pollard，Jack Smith，Philip Da Silva，Guy Israeli，@megalithic，Damian Crawford，Felix Gliesche，April Carter Grant，Heidi，jim tierney，Andrea Giammarchi，Nico Vignola，Don Jones，Chris Hartjes，Alex Howes，john gibbon，David J. Groom，BBox，Yu Dilys Sun，Nate Steiner，Brandon Satrom，Brian Wyant，Wesley Hales，Ian Pouncey，Timothy Kevin Oxley，George Terezakis，sanjay raj，Jordan Harband，Marko McLion，Wolfgang Kaufmann，Pascal Peuckert，Dave Nugent，Markus Liebelt，Welling Guzman，Nick Cooley，Daniel Mesquita，Robert Syvarth，Chris Coyier，Rémy Bach，Adam Dougal，Alistair Duggin，David Loidolt，Ed Richer，Brian Chenault，GoldFire Studios，Carles Andrés，Carlos Cabo，Yuya Saito，roberto ricardo，Barnett Klane，Mike Moore，Kevin Marx，Justin Love，Joe Taylor，Paul Dijou，Michael Kohler，Rob Cassie，Mike Tierney，Cody Leroy Lindley，tofuji，Shimon Schwartz，Raymond，Luc De Brouwer，David Hayes，Rhys Brett- Bowen，Dmitry，Aziz Khoury，Dean，Scott Tolinski - Level Up，Clement Boirie，Djordje Lukic，Anton Kotenko，Rafael Corral，Phi‐ lip Hurwitz，Jonathan Pidgeon，Jason Campbell，Joseph C.，Swif‐ tOne，Jan Hohner，Derick Bailey，getify，Daniel Cousineau，Chris Charlton，Eric Turner，David Turner，Joël Galeran，Dharma Vaga‐ bond，adam，Dirk van Bergen，dave ♥♫★ furf，Vedran Zakanj，Ryan McAllen，Natalie Patrice Tucker，Eric J. Bivona，Adam Spoo‐ ner，Aaron Cavano，Kelly Packer，Eric J，Martin Drenovac，Emilis，Michael Pelikan，Scott F. Walter，Josh Freeman，Brandon Hudgeons，vijay chennupati，Bill Glennon，Robin R.，Troy Forster，otaku_coder，Brad，Scott，Frederick Ostrander，Adam Brill，Seb Flippence，Michael Anderson，Jacob，Adam Randlett，Standard，Joshua Clanton，Sebastian Kouba，Chris Deck，SwordFire，Hannes Papenberg，Richard Woeber，hnzz，Rob Crowther，Jedidiah Broad‐ bent，Sergey Chernyshev，Jay-Ar Jamon，Ben Combee，luciano bonachela，Mark Tomlinson，Kit Cambridge，Michael Melgares，Jacob Adams，Adrian Bruinhout，Bev Wieber，Scott Puleo，Thomas Herzog，April Leone，Daniel Mizieliński，Kees van Ginkel，Jon Abrams，Erwin Heiser，Avi Laviad，David newell，Jean-Francois Turcot，Niko Roberts，Erik Dana，Charles Neill，Aaron Holmes，Grzegorz Ziółkowski，Nathan Youngman，Timothy，Jacob Mather，Michael Allan，Mohit Seth，Ryan Ewing，Benjamin Van Treese，Marcelo Santos，Denis Wolf，Phil Keys，Chris Yung，Timo Tijhof，Martin Lekvall，Agendine，Greg Whitworth，Helen Humphrey，Dougal Campbell，Johannes Harth，Bruno Girin，Brian Hough，Darren Newton，Craig McPheat，Olivier Tille，Dennis Roethig，Mathias Bynens，Brendan Stromberger，sundeep，John Meyer，Ron Male，John F Croston III，gigante，Carl Bergenhem，B.J. May，Rebe‐ kah Tyler，Ted Foxberry，Jordan Reese，Terry Suitor，afeliz，Tom Kiefer，Darragh Duffy，Kevin Vanderbeken，Andy Pearson，Simon Mac Donald，Abid Din，Chris Joel，Tomas Theunissen，David Dick，Paul Grock，Brandon Wood，John Weis，dgrebb，Nick Jenkins，Chuck Lane，Johnny Megahan，marzsman，Tatu Tamminen，Geof‐ frey Knauth，Alexander Tarmolov，Jeremy Tymes，Chad Auld，Sean Parmelee，Rob Staenke，Dan Bender，Yannick derwa，Joshua Jones，Geert Plaisier，Tom LeZotte，Christen Simpson，Stefan Bruvik，Jus‐ tin Falcone，Carlos Santana，Michael Weiss，Pablo Villoslada，Peter deHaan，Dimitris Iliopoulos，seyDoggy，Adam Jordens，Noah Kant‐ rowitz，Amol M，Matthew Winnard，Dirk Ginader，Phinam Bui，David Rapson，Andrew Baxter，Florian Bougel，Michael George，Alban Escalier，Daniel Sellers，Sasha Rudan，John Green，Robert Kowalski，David I. Teixeira (@ditma，Charles Carpenter，Justin Yost，Sam S，Denis Ciccale，Kevin Sheurs，Yannick Croissant，Pau Fracés，Stephen McGowan，Shawn Searcy，Chris Ruppel，Kevin Lamping，Jessica Campbell，Christopher Schmitt，Sablons，Jonathan Reisdorf，Bunni Gek，Teddy Huff，Michael Mullany，Michael Fürstenberg，Carl Henderson，Rick Yoesting，Scott Nichols，Hernán Ciudad，Andrew Maier，Mike Stapp，Jesse Shawl，Sérgio Lopes，jsulak，Shawn Price，Joel Clermont，Chris Ridmann，Sean Timm，Jason Finch，Aiden Montgomery，Elijah Manor，Derek Gathright，Jesse Harlin，Dillon Curry，Courtney Myers，Diego Cadenas，Arne de Bree，João Paulo Dubas，James Taylor，Philipp Kraeutli，Mihai Păun，Sam Gharegozlou，joshjs，Matt Murchison，Eric Windham，Timo Behrmann，Andrew Hall，joshua price，Théophile Villard。

这套系列丛书的编辑和制作都是以开源的方式进行。我们要感谢GitHub让这一切成为可能！

再次对我没能提及的支持者们表示感谢。这套系列丛书是属于我们每一个人的，希望它们能够帮助更多的人更好地了解JavaScript。

###关于作者

**Kyle Simpson**是Open Web的倡导者，居住在得克萨斯的奥斯汀。他热爱JavaScript，HTML5，实时／点对点通讯，和Web性能优化。所以对这些并不感到枯燥乏味。Kyle也是一个作者，培训师，技术讲演者，和活跃的OSS社区成员。

###尾声

《类型和语法》的封面字体是Interstate，正文字体是Adobe Minion Pro，标题字体是Adobe Myriad Condensed，示例代码字体是Dalton Maag's Ubuntu Mono。