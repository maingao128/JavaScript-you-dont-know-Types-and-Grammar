#你不知道的JavaScript － 类型和语法

##序

曾有人说：“JavaScript是唯一一门程序员先用后学的语言。”

每次听到这句话我都会付诸一笑，因为它对于我就是如此，不知道对其他程序员是否也一样。JavaScript，也许还有CSS和HTML，在互联网早期的大学计算机课程中并非主流的教学语言。新手程序员大多通过搜索和“查看源代码”的方式来自学这些Web的基础语言。

我仍然记得我高中时代的第一个网站项目。当时的任务是搭建一个网上商店，无论什么样的都行，因为我是詹姆斯∙邦德的粉丝，所以我决定搭建一个“黄金眼”商店。它包罗万象：背景音乐是“黄金眼”主题曲，有一个用JavaScript开发的瞄准器跟随鼠标移动，每次点击鼠标的时候会发出一声枪响。Q(JJ-??)实在应该为这个网站杰作感到骄傲。

我之所以讲到这个故事，是因为我当时使用的开发方式直到现在仍然有许多程序员在使用。我在项目中“拷贝－粘贴”了很多JavaScript代码，但根本没有理解它们是干什么的。现在流行的jQuery这样的JavaScript工具集，也在以它们各自的方式潜移默化地进一步鼓励了不深入学习JavaScript的方式。

我并不反对使用JavaScript工具集，事实上我还是MooTools JavaScript团队的成员之一。这些工具集功能如此强大的原因，恰恰是它们的开发者们从根本上了解它们，并且将其运用到了极致。了解这门语言的基本知识对我们来说仍然是非常重要的，这与掌握那些工具集一样会对我们非常有帮助。象Kyle Simpson的《你不知道的JS》系列这样的书，我们实在没有理由不学习。

《类型和语法》是该系列的第三本，它介绍了JavaScript核心基础知识，这些知识你永远不可能从“拷贝－粘贴”和JavaScript工具集中学到。前置（coercion）及其隐患、原生构造方法(JJ-??)、以及JavaScript的全部基础知识都在本书中做了详细的介绍，并配合以示例代码。同本系列的其他作品一样，Kyle的行文直中要点，没有多余的套话和修辞(JJ-??)，是我喜欢的技术书风格。

希望你们喜欢《类型和语法》这本书，并能够常读常新。

-David Walsh ([http://davidwalsh.name](http://davidwalsh.name)),
Senior Web Developer at Mozilla

------

##前言

我想你已经注意到了本书中的“JS”一词，但是它并非是用来咒骂JavaScript的简语，虽然咒骂一门语言是我们作为程序员的标志。

从互联网最早期开始，JavaScript就一直是实现内容交互体验的基本技术。虽然刚开始是用来实现鼠标移动轨迹闪烁效果，还有令人讨厌的弹出消息框。大约20年之后，JavaScript技术和功能得到了数量级的提高，没有人再怀疑它在互联网，这个世界上使用最广泛的软件系统，中的重要性和核心地位。

但是作为一门语言，它一直为人诟病，包括其历史沿革，更多是它的设计理念。它的命名，相对于其更成熟的哥哥Java，也被Brendan Eich称为“傻弟弟”。其实它的命名仅仅是政治和市场考量下的一个偶然。两个语言之间千差万别，“JavaScript”和“Java”之间如同“Carnival”（嘉年华）和“Car”之间一样毫无关联。

JavaScript在概念上和语法习惯上借鉴了许多语言，包括壮观的C风格的程序根，和相对隐晦的Scheme/Lisp风格的函数根，它能为更多的开发人员接受，包括没有编程经验的人。用JavaScript编写“Hello World”非常简单，让人很容易上手。

JavaScript或许是最容易上手和使用的语言之一，但是它的一些古怪的行为使得它不像其他语言那样容易完全掌握。使用C或者C++开发一个完整的程序需要对该语言有一个相当深入的了解。然而对于JavaScript来说，就算你使用它开发了一个完整的系统，也不见得对这门语言有什么深入理解。

这门语言中那些隐藏得很深的复杂概念，往往以一种看似简单的方式呈现，例如：将函数作为回调参数传递，使得JavaScript程序员乐于使用现成的语言机制，而不愿意去了解其中的原因。

JavaScript是一门简单易用的语言，应用广泛，同时又有着复杂和声名狼藉的语言机制，如果不用心掌握，即使经验丰富的JavaScript程序员也会对其出现理解上的偏差。

JavaScript的悖论就在于此，它的阿基里斯之踵正是我们要在本书解决的问题。因为你不需要理解就能够使用它，所以常常最终也不会去理解它。

###使命

在使用JavaScript时，每当遇到令人讶异或者抓狂的情况，你的反应如果是置之不理（这是人之常情），你很快会发现自己无法发挥这门语言的任何优势(JJ-??)。

这部分经常被称为“好的部分（The Good Parts）”，但我恳请读者朋友们不如把它视作“容易的部分”，“安全的部分”，甚至于“不完整的部分”。

《你不知道的JS》系列涉及的是另一个部分，即深入掌握JavaScript的所有知识，特别是那些重点难点。

我们让本书的内容对于JS程序员来说易于理解，而不强迫他们深入到原理。此外，在碰到疑难问题的时候我们不会避而不谈。

我不会满足于只是让代码运行而不明就里，，你也不应该仅仅满足于此。我会逐步用一些难点来挑战你，最终让你全面掌握JavaScript的威力。一旦掌握了这些知识，你将无法想象不需要技巧，框架，术语会是多么美妙的事情(JJ-??)。

本系列中的每本书全面深入地探讨了JavaScript中那些被误解，或者被低估的关键知识点。读完之后，从理论和实践上，对那些必须掌握的知识你都会有一个充分和自信的理解。

目前你对JavaScript的认识可能都来自于那些对JavaScript一知半解的人。JavaScript是一门语言，同时也是这门语言的一道影子。如果你还不真正了解它的话，读完本系列你会了解。让我们尽情地开始阅读吧。

###回顾

JavaScript是一门优秀的语言。它的各个部分学习起来都不难，但是要完全整体掌握则很难。当程序员遇到困惑时往往归咎于语言本身，而不是他们自身对语言的缺乏理解。本系列丛书旨在解决这个问题，让你能够发自内心地喜欢上这门语言。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">本书中的许多示例需要ES6这样的新一代的JavaScript引擎。一些代码可能无法在老的引擎（ES6之前）上运行。</td>
    </tr>
</table>


###书写约定

本书使用以下书写约定：

*斜体字*
表示新术语，URL，电子邮件，文件名，和文件扩展名。

等宽字
用于显示程序代码，和在段落中显示程序代码中的内容，如：变量名和函数名，数据库，数据类型，环境变量，声明语句，和关键词。

####粗体等宽字
需要用户输入的命令和其他文本。

*斜体等宽字*
需要用户提供替换值的文本，或者根据上下文计算的值。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">提示和建议</td>
    </tr>
</table>

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">注解</td>
    </tr>
</table>

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">警告和提醒</td>
    </tr>
</table>

###示例代码

本书的附带资料（如：示例代码，练习等）在[http://bit.ly/ydkjs-types-code](http://bit.ly/ydkjs-types-code)可以下载。

本书旨在帮助你解决实际问题。你可以在你的程序和文档中使用本书提供的示例代码。除非你使用了相当数量的示例代码，否则你不需要经过我们的许可。例如，你不必征得我们的同意既可在你的程序中使用几段本书的示例代码。如果你将O'Reilly出版的图书中的示例代码制作为光盘出售，则需要经过我们的许可。如果你在回答别人的问题时需要引用本书的内容和示例代码，你不需要征得我们许可。如果你的产品文档中引用了大量本书的示例代码，则需要征得我们许可。

如果你能够在使用到本书的地方注明出处，我们会非常感谢，不过这并不是强制的。注明出处通常包括书名，作者，出版方，和ISBN。例如：《你不知道的JS》，Kyle Simpson著，O'Reilly出版。Copyright 2015 Getify Solutions, Inc.,978-1-491-90419-0。

如果你觉得你的情况不属于上述两种情况，请通过[permissions@oreilly.com](permis‐ sions@oreilly.com)和我们联系。

###Safari Books Online

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/safari.png'></td>
        <td style="border: none;"><a href='http://safaribooksonline.com'>Safari Books Online</a>是及时点播式数字图书馆，为您提供来自世界顶尖科技和商业作者的专业书籍和视频<a href='https://www.safaribooksonline.com/explore'>内容</a>。</td>
    </tr>
</table>

科技工作者、软件开发人员、Web设计师和商业创新从业者都将Safari Books Online作为他们研究、攻关、学习和认证培训的一个主要资源。

Safari Books Onine为[企业](https://www.safaribooksonline.com/enterprise/)、[政府](https://www.safaribooksonline.com/government/)、[教育](https://www.safaribooksonline.com/academic-public-library/)和个人提供不同的[计划和收费](https://www.safaribooksonline.com/pricing/)。

Safari Books Online会员能够访问上千本图书，教学视频，和来自[上百家出版方](https://www.safaribooksonline.com/our-library)，如：O'Reilly Media，Prentice Hall Professional, Addison- Wesley Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders, McGraw-Hill, Jones & Bartlett, Course Tech‐ nology，并且可以在数据库中检索的正式出版前的稿件。有关Safari Books Online更多的信息请访问我们的网站。

------

###联系我们

关本书的想法和问题，您可以通过以下方式和我们联系：

O’Reilly Media, Inc.
1005 Gravenstein Highway North
Sebastopol, CA 95472
800-998-9938 (in the United States or Canada) 707-829-0515 (international or local) 707-829-0104 (fax)

我们为本书建设了一个网页，上面有勘误，示例，和其他信息。可以通过[http://bit.ly/ydkjs_types-and-grammar](http://bit.ly/ydkjs_types-and-grammar.)这个链接访问。

有关本书的评论和技术问题，可以发送邮件到[bookquestions@oreilly.com](bookquestions@oreilly.com)。

有关其他图书的信息，课程，论坛，和新闻，请访问我们的网站[http://www.oreilly.com](http://www.oreilly.com)。

我们的Facebook页面：[http://facebook.com/oreilly](http://facebook.com/oreilly)

关注我们的Twitter：[http://twitter.com/oreillymedia](http://twitter.com/oreillymedia)

我们的Youtube频道：[http://www.youtube.com/oreillymedia](http://www.youtube.com/oreillymedia)

------

##第一章 类型

很多开发人员认为动态语言（如：JavaScript）是没有类型的。让我们看看ES5.1规范（[http:// www.ecma-international.org/ecma-262/5.1/](http:// www.ecma-international.org/ecma-262/5.1/)）对此怎样解释：

```
本规范中的算法所操纵的值均有一个相对应的类型。本条款中定义了所有可能的值类型。类型是对ECMAScript语言类型和规范类型的进一步细分。
ECMAScript语言类型对应ECMAScript程序员使用该语言直接操纵的值。ECMAScript语言中的类型有：Undefined，Null，Boolean，String，Number，和Object。
```

如果你喜欢强类型（又称为静态类型）语言，你也许不同意使用“类型”一词。在强类型语言中，“类型”一词的含义比在JavaScript中广得多。

有人认为JavaScript中的“类型”应该叫“标签”或者“子类型”更合适。

我们在本书中对类型做如下粗略定义（和规范中一样）：*类型*是值的内部属性集合，它定义了该值的行为特征，使其能够区别于其他值。对于语言解析引擎和开发人员来说都是如此。

换句话说，如果语言解析引擎和开发人员对数字42和字符串"42"区别对待，则说明它们具有不同的类型，一个是数字，一个是字符串。我们通常会对数字42做数学运算。而对字符串"42"做一些其他操作，如将其显示到网页等等。所以它们的类型是不同的。

这样的定义并非十全十美，不过对于本书而言已经足够，而且它也与JavaScript语言对自身的描述一致。

###类型的另一面

抛开学术定义上的分歧不谈，JavaScript中有无类型为什么这么重要？

要合理准确地对值进行类型转换（见`第四章`），我们必须正确理解各个类型及其内部行为特征。几乎所有的JavaScript程序都涉及到各种形式的类型强制，因此你需要在处理这些情况时有充分的把握和信心。

如果你要将数字42当作字符串来处理，比如获得其第二个字符"2"，你就需要先将其从数字转换（强制）为字符串。

道理很明显。

但是强制类型转换的方式可以有很多种。有一些是显式的，比较容易，也比较可靠。但是如果你不小心，强制类型转换可能会产生意想不到的结果。

强制类型转换带来的困扰是JavaScript程序员最头疼的事情之一。它经常被诟病太危险，以至于被认为是语言设计上的缺陷，需要尽量回避。

在全面理解JavaScript中的类型的前提下，我们旨在阐述为什么强制类型转换的坏名声被过分夸大了，甚至一定程度上是错误的，这也许能够彻底转变你对它的看法，让你认识到它的强大和实用之处。不过首先我们需要对值和类型有一个更好的理解。

###内置类型

JavaScript中有7种内置类型：

- null
- undefined
- boolean
- number
- string
- object
- symbol（ES6中新增）

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">除object之外，其他统称为基本类型。</td>
    </tr>
</table>

typeof操作符检测值的类型，返回类型的字符串值。令人惊讶的是，以上7种类型和类型的字符串值并不一一对应：

```
    typeof undefined    === "undefined";    // true
    typeof true         === "boolean";      // true
    typeof 42           === "number";       // true
    typeof "42"         === "string";       // true
    typeof { life: 42 } === "object";       // true
    // added in ES6!
    typeof Symbol()     === "symbol";       // true
```

以上6个类型均有与其对应的字符串值，与类型名称相同。`Symbol`是ES6中新增的类型，我们将在`第三章`中介绍。

你可能注意到，null类型不在此列。它有些特殊，typeof运算符针对它的返回结果有bug：

```
    typeof null === "object"; // true
```

正确的返回结果应该是"null"，但是这是一个JavaScrtip固有的bug，已经存在近20年了，也可能永远不会被修复，因为太多的Web系统在“使用”这一bug，修复它将会产生更多的bug，导致大量的Web系统无法工作。

如果你想检测一个null值的类型，需要使用复合条件：

```
    var a = null;
    (!a && typeof a === "object"); // true
```

null是唯一一个“falsy”的基本类型（也称作false-like，见`第四章`），typeof对其仍然返回"object"。

那么typeof的第7个返回字符串值是什么呢？

```
    typeof function a(){ /* .. */ } === "function"; // true
```

上面的typeof的返回值容易让我们得出一个结论，就是`函数（function）`也是JavaScript的一个内置类型。然而如果你查阅规范就会知道，它实际上是`object`的一个子类型（subtype）。具体来说，函数被称为可调用对象（callable object），即该对象内部有一个\[\[Call\]\]属性，使其能够被执行。

函数是对象对我们很有用，更为重要的是，函数还可以拥有属性。例如：

```
    function a(b,c) {
        /* .. */
    }
```

函数对象的`length`属性设置为它的正式参数的数目：

```
    a.length; // 2
```

因为你为该函数定义了两个正式命名参数（b和c），所以函数的长度为2。

那么数组呢？JavaScript本身支持数组，那它是不是也是一个特殊类型？

```
    typeof [1,2,3] === "object"; // true
```

答案是no，数组也是object。确切地说，是object的一个子类型（见`第三章`），它另外一个特征是按照数字顺序进行索引（而非普通对象那样是字符串键值），并且它的`.length`属性会自动更新。

###值作为类型

JavaScript中变量没有类型，值才有。变量在任何时候都可以持有任何类型的值。

理解JavaScript类型的另一种方式是，JavaScript没有“强制类型检测”，就是语言解析引擎不要求一个变量总是持有与其初始值同样类型的值。变量可以一会持有字符串类型的值，一会持有数字类型的值，诸如此类。

值42的内部类型为number，它的类型无法更改。另一个值，如"42"，类型为字符串，能够通过强制类型转换的方式从数字42转换而来(coercion，见`第四章``)。

我们对变量使用typeof时，得到的并非是该变量的类型，因为JavaScript变量没有类型。我们得到的是变量持有的值的类型。

```
    var a = 42;
    typeof a; // "number"

    a = true;
    typeof a; // "boolean"
```

typeof操作符总是返回一个字符串：

```
    typeof typeof 42; // "string"
```

typeof 42首先返回"number"，然后typeof "number"返回"string"。

###undefined和undeclared

变量在没有持有任何值时其值为undefined。此时typeof返回"undefined"：

```
    var a;

    typeof a; // "undefined"

    var b = 42;
    var c;

    // later 
    b = c;

    typeof b; // "undefined"
    typeof c; // "undefined"
```

很多开发人员容易将“undefined”当作“undeclared”的同义词。然而在JavaScript中，它们之间有很大区别。

值为“undefined”的变量是那些已经在访问空间中声明过，但是当前并没有持有任何值的变量。相反，值为“undeclared”的变量是那些还没有在访问空间中声明过的变量。

例如：

```
    var a;

    a; // undefined
    b; // ReferenceError: b is not defined
```

浏览器在处理这类情况的时候显示的错误信息很容易误导人。如你所见，“b is not defined”这样的信息比较容易让人理解为“b is undefined”。再次说明，“undefined”和“is not defined”非常不同。如果浏览器显示诸如“b is not found”或者“b is not declared”这样的错误信息，就能避免不必要的误解。

typeof在处理undeclared变量时有一个特殊的行为更加深了我们的困惑。例如：

```
    var a;

    typeof a; // "undefined"

    typeof b; // "undefined"
```

typeof对于“undeclared”（或者“not defined”）的变量也返回"undefined"。请注意在执行typeof b时没有产生任何错误，即使b是一个undeclared变量。这是typeof中的一个特殊的安全防范。

同上所述，如果typeof对undeclared变量返回“undeclared”而非合用“undefined”，情况会好很多。

###typeof Undeclared

不管怎么说，这样的安全防范对于在浏览器中运行的JavaScript来说是很有帮助的，因为多个script文件可以将变量加载到共享的全局命名空间中。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px; "><img src='images/note.png'></td>
        <td style="border: none;">很多开发人员觉得全局命名空间中不应该有任何变量，所有的东西应该被封装到模块和私有命名空间中。理论上说这样不错，虽然在实际操作中基本不可能实现，但仍不失为一个值得努力的目标。幸运的是在ES6中加入了对模块的优先支持，最终将会让其更具可操作性。
        </td>
    </tr>
</table>

我们举个简单的例子，在你的程序中通过一个全局变量DEBUG来作为“调试模式”的开关。在执行诸如将信息写入控制台这样的调试任务前，你会检查DEBUG变量是否已经被声明过。这时最顶层的全局变量声明var DEBUG = true只包含在“debug.js”文件中，该文件只有在开发和测试时才在浏览器中加载，在生产环境中则不加载。

然而，你需要在程序的其他地方特别注意检查DEBUG变量的方式，以免出现ReferenceError错误。这时安全防范就很有用：

```
    // oops, this would throw an error!
    if (DEBUG) {
        console.log( "Debugging is starting" );
    }
    // this is a safe existence check
    if (typeof DEBUG !== "undefined") {
        console.log( "Debugging is starting" );
    }

```

即使对非用户定义的变量来说，这样的检查也是很有用的。如果你在为一个内置的API做特性检查，这也可以帮助你避免出现错误：

```
    if (typeof atob === "undefined") {
        atob = function() { /*..*/ };
    }
```


<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">如果你在为某个之前没有的特性定义一个“polyfill”，你可能会避免使用var来声明atob。如果你在if语句中使用var atob声明变量，该声明会被提升（参见本系列的Scope &amp; Closures一书）到范围中的最顶层，即使if条件未通过（因为atob全局变量已经存在）。在一些浏览器中和对于一些特殊的内置全局变量（通常被称为host objects），这样的重复声明会产生错误。而去掉var可以防止声明被提升。
        </td>
    </tr>
</table>

另一种对全局变量做检查但是不使用typeof安全防范的方法，是检查所有全局变量是否也是全局对象的属性，在浏览器中全局变量是window。所以上述检查可以写成这样：

```
    if (window.DEBUG) {
        // ..
    }
    
    if (!window.atob) {
        // ..
    }
```

和访问undeclared变量不同，当试图访问的对象属性不存在时，并不会产生ReferenceError错误。

另一方面，许多程序员避免通过window来访问全局变量，特别是当你的代码在多个JS环境下运行（不仅仅在浏览器，还在服务器端node.js，诸如此类），此时全局变量并不一定是window。

从技术角度而言，即便不是全局变量，使用typeof来做安全防范仍然是有用的，虽然这种情况不太常见，所以一些开发人员不太倾向使用这种方式。设想如果你想让别人拷贝粘贴一个工具函数到他们的程序中，你需要在函数中检查一些变量是否已经在它拷贝到的程序中被使用：

```
    function doSomethingCool() {
        var helper =
            (typeof FeatureXYZ !== "undefined") ?
            FeatureXYZ :
            function() { /*.. default feature ..*/ };
        var val = helper();
        // .. 
    }
```

doSomethingCool()检查变量FeatureXYZ，如果已存在就使用它，否则使用自己定义的版本。如果有人将这段代码引入到他们自己的模块和程序中，它会安全地检查FeatureXYZ是否已经被定义过：

```
    // an IIFE (see the "Immediately Invoked Function Expressions"
    // discussion in the Scope & Closures title in this series)
    (function(){
        function FeatureXYZ() { /*.. my XYZ feature ..*/ }

        // include `doSomethingCool(..)`
        function doSomethingCool() {
            var helper =
                (typeof FeatureXYZ !== "undefined") ?
                FeatureXYZ :
                function() { /*.. default feature ..*/ };
            var val = helper();
    // .. }
        doSomethingCool();
    })();
```

在这里FeatureXYZ不是一个全局变量，但是我们还是使用typeof安全防范。重要的是我们没有使用对象（如前面提到的windows.___）来做检查，因而typeof非常有用。

有些程序员可能倾向使用“依赖注入”（dependency injection）的方式，不是使用doSomethingCool()来检查FeatureXYZ是否已经在别处定义过，而是需要将依赖关系通过参数显式地传递进来，如：

```
    function doSomethingCool(FeatureXYZ) {
        var helper = FeatureXYZ ||
            function() { /*.. default feature ..*/ };
        var val = helper();
        // ..
    }
```

实现类似功能的方式有很多。它们之间没有“错”与“对”之分，每种方法都各有利弊。总而言之，使用typeof来检查undeclared变量为我们提供了更多的选择。

###回顾

JavaScript有7种内置类型：null，undefined，boolean，number，string，object，和symbol。可以使用typeof操作符来查看。

变量没有类型，但是它们持有的值有类型。类型定义了值的内在行为特征。

很多开发人员认为“undefined“和“undeclared”基本上是一样的，但是在JavaScript中，它们区别很大。`undefined`是变量可以持有的值的一种。“Undeclared”表示变量还没有被声明过。

不幸的是JavaScript将二者合并起来使用，不仅在相关的错误信息中如此（“ReferenceError:a is not defined”），typeof的返回值"undefined"也涵盖了这两种情况。

然而，使用typeof做安全防范对于检查undeclared的变量来说是非常有用的。

------

##第二章 值

数组，字符串，和数值是计算机程序最基本的组成部分，然而JavaScript中这些类型的一些独特的特性即能让人高兴，又能让人困惑。

###数组

相比其他的强制类型语言，JavaScript中的数组可以容纳任何类型的值，可以是字符串，数值，对象，甚至其他数组（多维数组就是以此方式来实现）：

```
    var a = [ 1, "2", [3] ];
    a.length;       // 3
    a[0] === 1;     // true
    a[2][0] === 3;  // true
```

你不需要预先设定数组的大小（参考`第44页的Array(...)`），你只需要对其进行声明，然后既可向其中加入值：

```
    var a = [ ];
    a.length;   // 0
    a[0] = 1;
    a[1] = "2";
    a[2] = [ 3 ];
    a.length;   // 3
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">对数组中的值执行delete操作能够将其从数组中移除，需要注意的是，即使值被移除后，数组的length属性并不会相应更改。我们将在第五章中详细介绍delete操作。
        </td>
    </tr>
</table>

创建“稀疏的”数组候需要特别注意（数组中有一些空白或者遗失的单元）：

```
    var a = [ ];
    a[0] = 1;
    // no `a[1]` slot set here
    a[2] = [ 3 ];
    a[1];       // undefined
    a.length;   // 3
```

虽然上面的代码没有问题，但是其中的“空白单元”会产生令人困惑的结果。即使单元[1]的值为`undefined`，但是它和我们明确设定该单元（a[1]=undefined）产生的结果还是有区别。详情参见`第44页的“Array(...)”`。

在你意料之中，数组使用数字索引，有趣的是数组也可以是字符串键值和属性组成的对象（它们并不计算在`length`内）：

```
    var a = [ ];
    a[0] = 1;
    a["foobar"] = 2;
    a.length;       // 1
    a["foobar"];    // 2
    a.foobar;       // 2
```

然而，我们需要注意的一个不容易察觉的地方是，如果你使用一个可以被强制转换为10进制数字的字符串作为键值，则默认为你是想使用其作为数字索引而非字符串键值！

```
    var a = [ ];
    a["13"] = 42;
    a.length; // 14
```

通常在数组中加入字符串键值/属性的方式并不是很好。推荐使用对象来存放键值/属性形式的值，使用数组来存放数字索引的值。

###类数组

有时候你需要将类似数组的值（一组使用数字索引的值）转换为真正的数组，通常你可以对其调用数组工具函数来实现（如：indexOf(..)，concat(..)，forEach(..)，等等）。

例如，一些DOM查询操作返回DOM元素列表，它们不是真正的数组，但是却很类似数组。另一个例子是一些函数使用自变量（类数组）对象将参数作为列表来访问（到ES6已经不支持了）。

使用slice(..)函数是实现此种转换的一个很普遍的方式：

```
    function foo() {
        var arr = Array.prototype.slice.call( arguments );
        arr.push( "bam" );
        console.log( arr );
    }

    foo( "bar", "baz" ); // ["bar","baz","bam"]
```

如上例所示，如果slice()不带其他参数，其参数的默认值为数组（本例中则是类数组）的值的复本(JJ-??)。

到ES6为止，其中有一个内置工具函数Array.from(..)也有相同的功能：

```
    ...
    var arr = Array.from( arguments );
    ...
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">Array.from(..)有几个强大的功能，我们将在本系列的《ES6及更多》一书中详细介绍。
</td>
    </tr>
</table>

###字符串

字符串通常被认为是由字符组成的数组。然而其内部实现也可能没有使用数组，重要的是认识到JavaScript中的字符串和字符数组不同。相同之处仅仅是皮毛而已。

例如下面两个值：

```
    var a = "foo";
    var b = ["f","o","o"];
```

如上所示，字符串确实和数组有相似之处，是类数组。比如，它们都有`length`属性，`indexOf(..)`方法（该方法对于数组只支持到ES5），和`concat(..)`方法：

```
    [source,js]

    a.length;                           // 3
    b.length;                           // 3

    a.indexOf( "o" );                   // 1
    b.indexOf( "o" );                   // 1

    var c = a.concat( "bar" );          // "foobar"
    var d = b.concat( ["b","a","r"] );  // ["f","o","o","b","a","r"]

    a === c;                            // false
    b === d;                            // false

    a;                                  // "foo" 
    b;                                  // ["f","o","o"]
```

那么是否可以说它们就是由字符组成的数组？答案是否定的：

```
    a[1] = "O";
    b[1] = "O";

    a; // "foo"
    b; // ["f","O","o"]
```

JavaScript中的`字符串`是不可变的，而`数组`是可变的。并且，a[1]这样的数据访问方式在JavaScript中并非总是合法的。旧版本的IE不允许这样做（现在允许了）。实际上*正确*的访问方式应该是`a.charAt(1)`。

`字符串`不可变意味着其中涉及到变更其内容的方法，都不会变更原始的内容，而是创建并返回一个新的`字符串`。相反，数组方法都是在其原始值上进行操作。

```
    c = a.toUpperCase();
    a === c;    // false
    a;          // "foo"
    c;          // "FOO"

    b.push( "!" );
    b;          // ["f","O","o","!"]
```

此外，很多`数组`中很有用的方法在`字符串`中并不支持，但是我们为`字符串`“借用”`数组`中那些非变更方法：

```
    a.join;         // undefined
    a.map;          // undefined

    var c = Array.prototype.join.call( a, "-" );
    var d = Array.prototype.map.call( a, function(v){
        return v.toUpperCase() + ".";
    } ).join( "" );
    
    c;              // "f-o-o"
    d;              // "F.O.O."
```

我们再来看看另外一个例子，反转`字符串`（一个经常在JavaScript面试中遇到的问题！）。`数组`中有一个叫做`reverse()`的变更方法，而`字符串`没有：

```
    a.reverse;      // undefined

    b.reverse();    // ["!","o","O","f"]
    b;              // ["f","O","o","!"]
```

遗憾的是，这种“借用”对于`数组`的变更方法而言无效，因为`字符串`是不可变的，其内容无法更改：

```
    Array.prototype.reverse.call( a );
    // still returns a String object wrapper (see Chapter 3)
    // for "foo" :(
```

一个变通（破解）的方法是将`字符串`转换为`数组`，执行需要的操作，然后在转换回`字符串`：

```
    var c = a
        // split `a` into an array of characters
        .split( "" )
        // reverse the array of characters
        .reverse()
        // join the array of characters back to a string
        .join( "" );
    
    c; // "oof"
```

该方法感觉太繁琐，实际也的确如此。至少它对于简单`字符串`还是可行的，往往这样简单粗暴的方法能够很快奏效。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">需要注意！上面的方法对于包含复杂字符（unicode）的字符串（星号，多子节字符等等）来说并不适用。对于这种情况你需要功能更加完备、能够处理unicode的工具库。可以参考Mathias Bynen开发的<a href='https://github.com/mathiasbynens/esrever'>Esrever</a>。</td>
    </tr>
</table>

另外一种思路是，如果你经常需要以`字符数组`的方式来处理字符串，那么不如直接用`数组`，而不是`字符串`。这样就不用花很多时间在`字符串`和`数组`之间进行转换了。你可以在需要时对`字符数组`执行`join("")`将其转换为`字符串`。

###数值

JavaScript只有一种数字类型，即：`数值`类型。它包括“整数”和带小数的十进制数。“整数“加引号的原因是，和其他语言不同，JavaScript中没有真正意义上的整数，这也是其一直被诟病的一个地方。这种情况在将来也许会有所改观，不过目前所有数字均为`数值`类型。

JavaScript中的整数只是没有小数的十进制数。所以42.0即等同于“整数”42。

和大多数现代编程语言一样，包括所有的脚本语言，JavaScript的`数值`类型的实现是基于“IEEE 754”标准，通常称为“浮点”。JavaScript具体使用的是“双精度”（又称“64位二进制”）标准。

网络上有很多优秀的文章详细介绍了二进制浮点数在内存中的存储方式，以及各种实现之间的不同。掌握JS中数值类型的正确使用方法，并不一定要求我们理解内存中的数位如何存储，所以本书不多做介绍，有兴趣的读者可以参考IEEE 754的细节。

###数值语法

JavaScript中的数值常量一般为十进制。例如：

```
    var a = 42;
    var b = 42.3;
```

数值前半部分为0的话可以省略：

```
    var a = 0.42;
    var b = .42;
```

同样地，数值后半部分（小数）为0的话也可以省略：

```
    var a = 42.0;
    var b = 42.;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">虽然42.这样的形式不太常见，但的确是允许的，考虑到代码可读性，通常不建议使用。</td>
    </tr>
</table>

缺省情况下，所有的`数值`都显示为十进制，小数部分最后面的0省略。如：

```
    var a = 42.300;
    var b = 42.0;

    a; // 42.3
    b; // 42
```

特别大和特别小的`数值`会默认用指数格式显示，效果和toExponential()函数一样，如：

```
    var a = 5E10;
    a;                  // 50000000000
    a.toExponential();  // "5e+10"

    var b = a * a;
    b;                  // 2.5e+21
    
    var c = 1 / a;
    c;                  // 2e-11
```

由于`数值`类型的值可以使用`Number`对象来封装（见`第三章`），因此`数值`类型的值可以使用`Number.prototype`中的方法（见`第三章`）。例如，`toFixed(..)`方法让你能够指定小数部分显示的位数：

```
    var a = 42.59;

    a.toFixed( 0 ); // "43"
    a.toFixed( 1 ); // "42.6"
    a.toFixed( 2 ); // "42.59"
    a.toFixed( 3 ); // "42.590"
    a.toFixed( 4 ); // "42.5900"
```

请注意输出结果实际上是该`数值`的`字符串`，如果小数部分显示位数多于实际值的位数，则使用0补齐。

类似地，`toPrecision(..)`方法指定`有效数字`显示的位数：

```
    var a = 42.59;

    a.toPrecision( 1 ); // "4e+1"
    a.toPrecision( 2 ); // "43"
    a.toPrecision( 3 ); // "42.6"
    a.toPrecision( 4 ); // "42.59"
    a.toPrecision( 5 ); // "42.590"
    a.toPrecision( 6 ); // "42.5900"
```

这些方法并不需要你使用变量来访问，`数值`常量也可以直接调用它们。不过在使用`.`操作符时需要注意。因为`.`是一个合法的数字字符，只要有可能，它首先会被识别为`数值`常量的一部分，而非对象属性访问操作符。

```
    // invalid syntax:
    42.toFixed( 3 );    // SyntaxError

    // these are all valid:
    (42).toFixed( 3 );  // "42.000"
    0.42.toFixed( 3 );  // "0.420"
    42..toFixed( 3 );   // "42.000"
```

`42.toFixed(3)`是非法语法，因为`.`被视为常量`42.`的一部分（如上所述），因此本例中并不存在`.`属性访问操作符来调用`.toFixed`。

`42..toFixed(3)`没有问题，因为第一个`.`被视为`数值`的一部分，第二个`.`才是属性访问操作符。不过这看起来有点奇怪，在实际的JavaScript代码中也很少见。事实上通过基本类型调用方法并不常见，不过不常见并不代表`不好`和`不对`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">有一些代码库扩展了Number.prototype的内置方法（见第三章），提供了更多操纵数值的功能，比如使用10..makeItRain()实现下十分钟金钱雨的动画，等等。</td>
    </tr>
</table>

以下语法也是合法的（注意空格）：

```
    42 .toFixed(3); // "42.000"
```

然而，对于`数值`常量而言，这样的语法很容易造成误导，不建议使用。

`数值`还可以使用指数格式，常用于较大的数字，如：

```
    var onethousand = 1E3;                      // means 1 * 10^3
    var onemilliononehundredthousand = 1.1E6;   // means 1.1 * 10^6
```

`数值`常量还可以用其他方式来表示，如：二进制，八进制，和十六进制。

当前版本的JavaScript都支持这些格式：

```
    0xf3; // hexadecimal for: 243
    0Xf3; // ditto

    0363; // octal for: 243
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从ES6的严格模式开始，不再支持0363八进制格式（新格式见下）。0363格式在非严格模式中仍然支持，但是考虑到将来的兼容性最好不要再使用（目前你使用的应该是严格模式）。</td>
    </tr>
</table>

ES6支持以下新格式：

```
    0o363;      // octal for: 243
    0O363;      // ditto

    0b11110011; // binary for: 243
    0B11110011; // ditto
```

考虑到代码的易读性，不推荐使用0O363格式。0和大写O在一起会导致误读。建议尽量使用小写字母0x，0b，和0o。

###小数值

使用二进制浮点数最大的副作用（不仅仅是JavaScript，对于所有使用IEEE 754规范的语言都是如此），是这样的情况：

```
    0.1 + 0.2 === 0.3; // false
```

从数学角度，我们觉得上面的表达式应该为`true`，但是为什么是`false`呢？

简单来说，二进制浮点数中的`0.1`和`0.2`并不是完全精确，它们相加的结果并非精确等于`0.3`，而是非常接近的一个数字，`0.30000000000000004`，所以在判断相等时结果为`false`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">JavaScript是否应该使用能够精确反映数字的数值实现方式？有些人这样认为。长期以来也出现了很多替代方案，只是它们都没有被认可，将来也许也不会。虽然这件事看起来象你举手示意“Bug解决了！”一样简单，事实却并非如此，否则问题早就已经解决了。</td>
    </tr>
</table>

现在的问题是，如果一些`数值`无法做到完全精确，那我们是不是就无法使用`数值`了呢？答案当然是否定的。

有一些应用程序在处理数字，特别是有小数的数字时需要特别精确。还有很大一部分（也许是大多数）应用程序仅仅需要处理整数，最大不超过百万或者万亿。JavaScript的数字操作对于这些应用程序来说一直是绝对有保障的。

如果我们确实需要比较两个`数值`，比如：`0.1 + 0.2`和`0.3`，并且我们已经知道相等测试结果为'false'，这时应该怎么办？

通常采用的方法是设置一个误差范围值。通常称为“机器小量（machine epsilon）”，对于JavaScript中的`数值`来说一般是`2^-52 (2.220446049250313e-16)`。

截至到ES6，这个误差范围值定义在`Number.EPSILON`中，你可以直接使用，或者也可以使用polyfill（JavaScript中的一种“衬垫”技术）来为ES6之前的版本定义改值：

```
    if (!Number.EPSILON) {
        Number.EPSILON = Math.pow(2,-52);
    }
```

现在我们可以使用`Number.EPSILON`来比较两个数字是否相等了（在指定的误差范围内）：

```
    function numbersCloseEnoughToEqual(n1,n2) {
        return Math.abs( n1 - n2 ) < Number.EPSILON;
    }

    var a = 0.1 + 0.2;
    var b = 0.3;

    numbersCloseEnoughToEqual( a, b );                  // true
    numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );  // false
```

能够被呈现的最大浮点值为`1.798e+308`（相当大的数字），定义在`Number.MAX_VALUE`中。此外，最小浮点值定义在`Number.MIN_VALUE`中，大约是`5e-324`，它不是负数，无限接近于`0`！

###整数的安全范围

由于`数值`的呈现方式，“整数”有一个远远小于`Number.MAX_VALUE`的安全值范围。

能被“安全”呈现的最大整数值（即该值能够保证被清晰地呈现）为`2^53 - 1`，即`9007199254740991`，在ES6中定义为`Num ber.MIN_SAFE_INTEGER`。

JS程序处理大数值的一个常见场景是处理来自数据库中的64位ID等等。`数值`类型无法精确处理64位数，所以它们在JavaScript中必须被保存（转换）为`字符串`。

幸运的是，对于这类大数值的操作（除了比较操作`字符串`能够处理）并不常见。不过如果你确实需要对这类大数值进行数学运算，目前你还是需要使用大数值相关工具。在将来的JavaScript版本中也许会加入对大数值的支持。

###整数检测

如果要检测一个值是否是整数，你可以使用ES6特定的`Number.isInteger(..)`方法：

```
    Number.isInteger( 42 );     // true
    Number.isInteger( 42.000 ); // true
    Number.isInteger( 42.3 );   // false
```

我们可以为ES6之前的版本polyfill`Number.isInteger(..)`方法：

```
    if (!Number.isInteger) {
        Number.isInteger = function(num) {
            return typeof num == "number" && num % 1 == 0;
        };
    }
```

要检测一个数值是否是`安全的整数`，可以使用ES6特定的`Number.isSafeInteger(..)`方法：

```
    Number.isSafeInteger( Number.MAX_SAFE_INTEGER );    // true
    Number.isSafeInteger( Math.pow( 2, 53 ) );          // false
    Number.isSafeInteger( Math.pow( 2, 53 ) - 1 );      // true
```

我们可以为ES6之前的版本polyfill`Number.isSafeInteger(..)`方法：

```
    if (!Number.isSafeInteger) {
        Number.isSafeInteger = function(num) {
            return Number.isInteger( num ) &&
                Math.abs( num ) <= Number.MAX_SAFE_INTEGER;
        }; 
    }
```

###32位有符号整数

虽然整数最大能够达到53位，一些数字操作（如：数位操作）只适用于32位的数字，因此这些操作中的数值的安全范围就要小得多。

这种情况下的安全范围是从`Math.pow(-2,31)`（-2147483648，约-21亿）到`Math.pow(2,31)`（2147483647，约21亿）。

要将变量`a`中的数值转换为32位有符号整数，可以使用`a | 0`。这个方法很有效，因为`|`数位操作符只针对32位整数（即它只关心32位以内的值，忽略其他的数位）。因此与0的`或`操作即为一个空的数位操作。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">有一些特殊的值（我们将在下节介绍），如：NaN和Infinity，并不是32位安全的。32位安全是指传递给数位操作符的值会执行一个虚拟操作ToInt32（见第四章），以便成为数位操作符要求的+0值。（JJ-??）</td>
    </tr>
</table>

###特数值

JavaScript的各种类型中有几个特数的值，它们提请JS程序员特别注意，并且小心使用。

####不是值的值

类型`undefined`只有一个值，即：`undefined`。类型`null`也只有一个值，即：`null`。对于这两个类型来说，它们的名称既是类型也是值。

`undefined`和`null`经常被用来表示“empty”值或“non”值。有人也倾向于区分出它们之间的细微差别。例如：

- `null`指空值。
- `undefined`指没有值。

或者：

- `undefined`指从未赋过值。
- `null`指曾被赋过值，但是目前没有值。

无论你如何定义和使用这两个值，`null`是一个特殊关键字，而非标识符，因此你不能将其当作变量来赋值。然而不幸的是，`undefined`却是一个标识符。

####Undefined

在非严格模式下，可以（虽然强烈不推荐）为全局标识符`undefined`赋值：

```
    function foo() {
        undefined = 2; // really bad idea!
    }
    
    foo();
    
    function foo() {
        "use strict";
        undefined = 2; // TypeError!
    }

    foo();
```

在非严格和严格模式下，你可以声明一个名为`undefined`的局部变量。不过再次强调，这样做很不好。

```
   function foo() {
        "use strict";
        var undefined = 2;
        console.log( undefined ); // 2
    }

    foo();
```

不要重载undefined，永远不要。

####void操作符

虽然`undefined`是一个内置的标识符（除非被修改，见前面的介绍），其值为`undefined`，另外还有一个方法可以得到该值，即void操作符。

`void ___`表达式不返回任何值，因此其返回结果永远是`undefined`。它并不更改现有的值，只是确保表达式不返回任何值：

```
    var a = 42;
    console.log( void a, a ); // undefined 42
```

按照惯例（大部分源自C语言），你可以使用`void 0`（`void true`或者其他`void`表达式也都返回相同的结果）。`void 0`，`void 1`，和`undefined`之间并没有区别。

但是`void`操作符在某些情况下非常有用，比如你想确保一个表达式不返回任何结果（即使它有副作用）。

例如：

```
    function doSomething() {
        // note: `APP.ready` is provided by our application
        if (!APP.ready) {
            // try again later
            return void setTimeout( doSomething,100 );
        }
    
        var result;
        
        // do some other stuff
        return result;
    }

    // were we able to do it right away?
    if (doSomething()) {
        // handle next tasks right away
    }
```

上例中，`setTimeout(..)`函数返回一个数值（时间间隔的唯一标识，如果你想要取消的话），但是为了让该函数的`if`声明不误报（false positive），我们就要`void`掉它。

有些程序员喜欢将它们分开实现，不使用`void`但是效果是一样的：

```
    if (!APP.ready) {
        // try again later
        setTimeout( doSomething,100 );
        return;
    }
```

通常，如果代码中某处需要一个值（来自某个表达式），你会觉得使用`undefined`比`void`更好些。这种情况可能并不十分常见，不过在需要的时候还是很好用。

####特殊数值

`数值`类型包括几个特殊的值，这里将详细介绍。

#####不是数值的数值

如果数学运算中的操作符不是`数值`（或者可以被解析为常规的10进制或16进制`数值`）的话，运算结果将无法返回有效的`数值`，这时返回值为`NaN`。

`NaN`意指“不是数值（not a number）”，虽然这个名字不太好，容易误导人，后面我们会讲到。把其视作“无效数值”，“失效数值”，甚至“坏数值”可能更贴切一些。

例如：

```
    var a = 2 / "foo";      // NaN

    typeof a === "number";  // true
```

换句话说，不是数值的数值的类型是`数值`。名字和意思一样绕。

`NaN`是一个“标记符号”(是一个具有特殊意思得非正常值)，用来表示数值中的某种错误情况。这个错误情况就是“我试图执行一个数学运算但是没有成功，这是相应的失败结果”。

如果你要测试变量中的数值是否是`NaN`，你也许会认为可以直接比较值和`NaN`，和其他值，如：`null`和`undefined`，一样。答案是否定的。

```
    var a = 2 / "foo";
   
    a == NaN;   // false
    a === NaN;  // false
```

`NaN`这个值很特殊，它永远不会和其他NaN值相等（即永远不等于它自己）。它是唯一一个非自反（reflexive，即无`x === x`特征）的值。因而`NaN != NaN`，有点奇怪不是吗？

如果我们无法比较`NaN`（其永远返回false），那么我们怎么测试它呢？

```
    var a = 2 / "foo";
   
    isNaN( a ); // true
```

很简单是不是？我们使用内建的全局工具函数`isNaN(..)`来告诉我们一个值是否是`NaN`。搞定！

没有这么简单。

`isNaN(..)`有一个严重的缺陷。它对`NaN`（“Not a Number”）按照字面来解读，即“测试传递进来的参数，如果它不是`NaN`既是`数值`”。但是这样并不十分精确：

```
    var a = 2 / "foo";
    var b = "foo";
    
    a; // NaN
    b; "foo"
    
    window.isNaN( a ); // true
    window.isNaN( b ); // true--ouch!
```

很明显"foo"不是一个`数值`，但是它也不是`NaN`。这个bug自JS问世以来一直存在（超过19年）。

从ES6开始，有一个替代工具函数`Number.isNaN(..)`。它是一个简单的polyfill，你可以在ES6之前的浏览器中安全地测试NaN值。

```
    if (!Number.isNaN) {
        Number.isNaN = function(n) {
            return (
                typeof n === "number" &&
                window.isNaN( n )
            ); 
        };
    }
    
    var a = 2 / "foo";
    var b = "foo";
    
    Number.isNaN( a ); // true
    Number.isNaN( b ); // false--phew!
```

实际上我们可以用更简单的方式实现`Number.isNaN(..)`polyfill，利用NaN不等于自己这个奇怪的特性。NaN是JavaScript中`唯一`一个不等于自己的值，其他的值都等于自己。

因此：

```
    if (!Number.isNaN) {
        Number.isNaN = function(n) {
            return n !== n;
        };
    }
```

虽然很奇怪，但是很有效。

`NaN`反映了很多JS程序的一个现实，无论是有意或是巧合。就是尽量使用可靠的测试方法，无论是系统自带或者polyfill，如：`Number.isNaN(..)`。

如果你的代码中正在使用`isNaN(..)`，你的代码不幸地包含bug，即使其还未显露。

#####无穷数

熟悉编译后运行语言的程序员可能遇到过诸如“除以0”这样的编译错误或者运行时错误，例如以下代码：

```
    var a = 1 / 0;
```

然而在JS中，以上代码的运行结果为`Infinity`（即Number.POSITIVE_INFINITY）。例如以下代码：

```
    var a = 1 / 0;  // Infinity
    var b = -1 / 0; // -Infinity
```

如果除法运算中的某个数为负数，则结果为`-Infinity`（即Number.NEGATIVE_INFINITY）。

JS使用有限数值规范（之前讨论过的IEEE 754 浮点数），所以和数学相反，它的数学运算有溢出的可能，此时运算结果为`Infinity`或者`-Infinity`。

例如：

```
    var a = Number.MAX_VALUE;   // 1.7976931348623157e+308
    a + a;                      // Infinity
    a + Math.pow( 2, 970 );     // Infinity
    a + Math.pow( 2, 969 );     // 1.7976931348623157e+308
```

根据规范，如果加法运算的结果超出了处理范围，IEEE 754规范的“就近取整”模式定义了应该返回的计算结果。例如：相对于`Infinity`来说，`Number.MAX_VALUE + Math.pow(2, 969)`与`Number.MA_VALUE`更为接近，因此它被“向下取整”，然而`Number.MAX_VALUE + Math.pow(2, 970）`与`Infinity`更为接近，所以它被“向上取整”。

关于这个问题想多了容易头疼，所以我们就此打住。

一旦你的计算结果溢出到两个无穷数中的一个，你将无法返回。说得有诗意一点，就是你可以从有穷走向无穷，但是无法从无穷回到有穷。

如果你有哲学思想，可能会问“那么如果无穷除以无穷会是什么结果呢？”。我们简单的大脑可能会回答“1“或者”无穷“。这两个答案都不正确。因为对于数学和JavaScript语言来说，`Infinity / Infinity`不是一个定义操作。JS中它的运算结果是`NaN`。

那么有穷数正数除以`Infinity`呢？很简单，结果是0。有穷负数除以`Infinity`呢？后面介绍。

#####零

这部分内容可能会对有数学头脑的读者带来困惑，JavaScript中有一个正常的0（也叫做`+0`）和一个负0（`-0`）。在解释为什么会有`-0`之前，我们来看看JS对其是如何处理的，因为这个概念容易让人困惑。

除了使用常量`-0`，一些数学运算也返回负零。例如：

```
    var a = 0 / -3; // -0
    var b = 0 * -3; // -0
```

加法和减法运算不会得到负零的结果。

在开发工具的调试控制台中，负零通常被显示为`-0`，不过这之前一些老的浏览器将其显示为`0`。

如果你将负零转换为字符串，根据规范中的定义，结果会是“`0`”：

```
    var a = 0 / -3;
    
    // (some browser) consoles at least get it right
    a;                          // -0
    
    // but the spec insists on lying to you!
    a.toString();               // "0"
    a + "";                     // "0"
    String( a );                // "0"

    // strangely, even JSON gets in on the deception
    JSON.stringify( a );   // "0"
```

有趣的是，如果你反过来将其从字符串转换为数值，会发现结果是正确的：

```
    +"-0";              // -0
    Number( "-0" );     // -0
    JSON.parse( "-0" ); // -0
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">JSON.stringify(-0)的返回结果为“0”，JSON.parse("-0")返回-0，和我们预想的不一致。</td>
    </tr>
</table>

负零转换为字符串的结果让人迷惑，其比较操作符也是这样：

```
    var a = 0;
    var b = 0 / -3;

    a == b;     // true
    -0 == 0;    // true

    a === b;    // true
    -0 === 0;   // true
    
    0 > -0;     // false 
    a > b;      // false
```

如果你想在代码中区分`-0`和`0`，而非依赖于开发调试窗口的输出结果，就需要处理得更聪明一些：

```
    function isNegZero(n) {
        n = Number( n );
        return (n === 0) && (1 / n === -Infinity);
    }

    isNegZero( -0 );        // true
    isNegZero( 0 / -3 );    // true
    isNegZero( 0 );         // false
```

除了学术方面的原因之外，为什么我们需要负零？

在一些应用程序中有一些信息需要使用值的级数来表示（如动画帧的移动速度），另外一些信息需要使用`数值`的符号来表示（如移动的方向）。

在这种情况下，如果一个包含0值的变量丢失了它的符号，其代表的方向信息也就会丢失。所以保留0值的符号可以防止此类信息的丢失。

#####特殊等式

如上所述，`NaN`和`-0`在进行相等比较时的表现得很特别。`NaN`和自身不相等，因此你必须使用ES6种的`Number.isNaN(..)`（或者polyfill）。同样令人费解地，`-0`和`0`相等（==甚至===都如此，见`第四章`），因此你必须使用某些工具函数来处理相等比较。

从ES6开始提供了一个新的工具方法来判断两个值是否严格相等，其考虑了所有的特殊情况。这个方法是`Object.is(..)`：

```
    var a = 2 / "foo";
    var b = -3 * 0;

    Object.is( a, NaN );    // true
    Object.is( b, -0 );     // true

    Object.is( b, 0 );      // false
```

对于ES6之前的版本，`Object.is(..)`有一个简单的polyfill：

```
    if (!Object.is) {
        Object.is = function(v1, v2) {
            // test for `-0`
            if (v1 === 0 && v2 === 0) {
                return 1 / v1 === 1 / v2;
            }
            // test for `NaN`
            if (v1 !== v1) {
                return v2 !== v2;
            }
            // everything else
            return v1 === v2;
        };
    }
```

在可以安全（见`第四章`）使用`==`和`===`的情况下，可能不该使用`Object.is(..)`，因为这两个操作符效率更高，也更地道和通用。`Object.is(..)`主要是针对特殊情况。

###值和引用

在很多其他语言中，赋值和传递参数值可以通过值拷贝来完成，也可以通过拷贝引用来完成，取决于你使用哪种语法。

例如，在C++中，如果你需要向一个函数传递一个`数值`变量，在函数中变量值要被更改，你可以将参数声明为`int& myNum`这样的形式，当你向其传递变量`x`时，`myNum`即为指向`x`的一个引用。引用是指针的一种特别形式，其中你得到一个指向变量的指针（类似`别名`）。如果你不将参数声明为引用，参数值将总是通过值拷贝的方式传递，即使值是复杂的对象也如此。

在JavaScript中没有指针，引用的工作原理也不太一样。JS中你不可能将一个引用从一个变量指向另一个变量，那不可能。

JS中的引用指向的是值（共享值），如果你有10个不同的引用，它们就是10个指向同一个共享值的不同的引用，它们之间没有任何引用／指向关系。

而且JavaScript的语法不区分通过值和引用复制／传递。而是仅由值的类型决定该值是否该通过值或引用传递。

让我们看一个例子：

```
    var a = 2;
    var b = a; // `b` is always a copy of the value in `a`
    b++;
    a; // 2
    b; // 3

    var c = [1,2,3];
    var d = c; // `d` is a reference to the shared `[1,2,3]` value
    d.push( 4 );
    c; // [1,2,3,4]
    d; // [1,2,3,4]
```

简单值（即标量基本值，scalar primitives）(JJ-??)总是通过值拷贝的方式赋值／传递，包括：`null`，`undefined`，`string`，`number`，`boolean`，和ES6的`symbol`。

复合值－`object（对象）`（包括数组，和所有的封装对象，见`第三章`）和`function（方法）`，总是通过引用拷贝来赋值／传递。

在前面的示例代码中，由于`2`是一个标量基本值，变量`a`包含该值的一个拷贝，`b`被赋值为该值的另一个拷贝。`b`中的值更改时，`a`中的值不变。

但是`c`和`d`却是两个不同的引用，指向同一个复合值`[1,2,3]`。值得一提的是，`c`和`d`都不拥有值`[1,2,3]`，仅仅同时指向该值。所以使用它们之间的任何一个来更改值（如`.push(4)`），两个引用都将指向更改后的值`[1,2,3,4]`。

由于引用指向的是值本身，而非变量，一个引用无法更改另一个引用指向的值。

```
    var a = [1,2,3];
    var b = a;
    a; // [1,2,3]
    b; // [1,2,3]
    
    // later
    b = [4,5,6];
    a; // [1,2,3]
    b; // [4,5,6]
```

当赋值时`b=[4,5,6]`，不影响`a`已经指向的值`[1,2,3]`。除非`b`不是指向该数组的引用，而是指向'a'的指针。但是这种情况在JS中不存在！

这些困扰经常体现在函数参数上：

```
    function foo(x) {
        x.push( 4 );
        x; // [1,2,3,4]
    
        // later
        x = [4,5,6];
        x.push( 7 );
        x; // [4,5,6,7]
    }

    var a = [1,2,3];
    
    foo( a );

     a; // [1,2,3,4]  not  [4,5,6,7]
```

当传递`a`到函数时，是将`a`引用的一个复本赋值给`x`，`a`仍然是一个单独的引用，指向值`[1,2,3]`。现在在函数内部，我们可以使用该引用来更改值（`push(4)`）。但是当我们为`x`赋值`x = [4,5,6]`时并不影响原来的值，`a`仍然指向原来的值，即更改后的`[1,2,3,4]`。

我们不可能使用引用`x`来更改`a`的指向，只能更改`a`和`x`共同指向的值的内容。

如果要将`a`指向的值更改为`[4,5,6,7]`，你必须更改`x`指向的数组的值，而非为`x`创建并赋值一个新数组。

```
    function foo(x) {
        x.push( 4 );
        x; // [1,2,3,4]

        // later
        x.length = 0; // empty existing array in-place
        x.push( 4, 5, 6, 7 );
        x; // [4,5,6,7]
    }
    
    var a = [1,2,3];

    foo( a );
    
    a; // [4,5,6,7] not [1,2,3,4]
```

如你所见，`x.length = 0`和`x.push(4,5,6,7)`没有创建一个新数组，而是对现有的数组进行更改。所以`a`指向的值变成了`[4,5,6,7]`。

请记住：你无法直接控制和重载值拷贝和引用，它们的语义由它们指向的值的类型来决定。

如果要有效率地通过值拷贝方式传递复合值（如数组），你需要为其创建一个拷贝，从而传递的引用不再指向原始值。例如：

```
    foo( a.slice() );
```

不带参数的`slice(..)`默认返回整个`数组`的一个浅（shallow）拷贝。由于传递到函数内的引用指向的是该数组的一个拷贝，因此函数`foo(..)`不会对`a`指向的值造成影响。

相反地，如果要将标量基本值传递到函数内且能够更改值，象引用那样，你需要将该值封装到另一个复合值（`对象`，`数组`等）中，通过引用拷贝传递。

```
    function foo(wrapper) {
        wrapper.a = 42;
    }

    var obj = { 
        a: 2
    };

    foo( obj );

    obj.a; // 42
```

这里`obj`是一个封装对象，其中包含了标量基本值`a`。引用`obj`的一个拷贝被赋值给参数`wrapper`并传递到`foo(..)`中。这样我们可以通过`wrapper`来访问共享对象并更改其属性。函数返回后，`obj.a`将得到一个新值`42`。

有时候你可能需要传递指向标量基本值（如`2`）的一个引用，你可以将该值封装到`Number`对象中（见`第三章`）。

虽然这里传递的是指向该`Number`对象的一个引用的拷贝，但并非象你设想的那样，指向共享对象的引用并不能让你更改其中的基本值：

```
    function foo(x) {
        x = x + 1;
        x; // 3 
    }
    
    var a = 2;
    var b = new Number( a ); // or equivalently `Object(a)`
    
    foo( b );
    console.log( b ); // 2, not 3
```

其中的原因是标量基本值是不可更改的（`String`和`Boolean`也是如此）。如果一个`Number`对象的值为`2`，你就不可能将其更改为其他值，除非创建一个不同值的新的`Number`对象。

当执行`x = x + 1;`时，`x`中的标量基本值`2`被从`Number`对象中提取出来，因此`x`悄悄地从引用变成了`Number`对象，它的值为`2 + 1`的结果`3`。然而，函数外部的`b`仍指向原来的值为`2`的`Number`对象。

你可以在`Number`对象上添加其他属性（这样可以不用更改其内部的基本值），通过这些属性来直接传递和交换信息。

不过这个方法不是很常见，程序员也不认为这是一个好的实践。

相比使用`Number`封装对象，在之前的示例代码中使用`obj`作为封装对象的方法可能更好些。这并不是说`Number`这样的封装对象没有什么用，只是对于大部分情况而言标量基本值应该是首选。

引用的功能很强大，但是有时候你不需要它时它却来了，你需要它时它却不在。对于引用和值拷贝，值的类型决定了它们的行为，所以赋值／参数传递的行为取决于你选择哪种值类型。

###回顾

在JavaScript中的`数组`是通过数字索引的一组任意类型的值，`字符串`有点象`数组`，但是它们的行为特征不同，你将`字符串`作为`数组`处理时需要特别小心。JavaScript中的`数值`包括“整型”和“浮点型”。

基本类型中定义了几个特殊值。

`null`类型只有一个值`null`，同样`undefined`类型只有一个值`undefined`。任何变量在赋值之前的默认值基本都是`undefined`。`void`操作符可以从任何值创建`undefined`值。

`数值`中有几个特殊值，`NaN`（意指“Not a Number”，更确切地说是“invalid number”），`+Infinity`，`-Infinity`，`-0`。

简单标量基本值（`字符串`，`数值`等）通过值拷贝来赋值／传递，但是复合值（`对象`等）通过引用拷贝来赋值／传递。这里的引用和其他语言中的引用／指针不同，它们不能指向另一个引用／指针，只能指向值。

------

##第三章 原生特性

在第一和第二章里，我们提到过各种JavaScript的内建特性，如：`字符串`和`数组`，通常我们称为“原生特性”。本章我们将对它们做详细介绍。

以下是常用的原生特性：

- String() 
- Number() 
- Boolean()
- Array()
- Object()
- Function()
- RegExp()
- Date()
- Error()
- Symbol()－新在ES6中加入!

如你所见，它们实际上是内建函数。

如果你熟悉其他语言，如：Java，JavaScript中的`String()`看起来象Java中创建字符串的`String(..)`构造函数。于是你知道你可以这样使用它：

```
    var s = new String( "Hello World!" );

    console.log( s.toString() ); // "Hello World!"
```

这些内建函数是可以作为构造函数来使用。但是它们所构造的对象可能和你想的不同：

```
    var a = new String( "abc" );
    
    typeof a;                            // "object" ... not "String"
    
    a instanceof String;                 // true
    
    Object.prototype.toString.call( a ); // "[object String]"
```

`new String("abc")`构造出来的是一个封装基本值`"abc"`的对象。

重点是`typeof`显示这些对象的类型不是它们自己的类型，而是`对象`类型的子类型。

我们可以使用下面的代码来进一步查看这个封装对象：

```
    console.log( a );
```

上面代码的输出结果在不同的浏览器中有区别，取决于浏览器序列化对象的方式。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">在本书写作的时候，Chrome的最新版本这样显示：String {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}。但是较老版本显示：String {0: "a", 1: "b", 2: "c"}。最新版本的Firefox显示：String ["a","b","c"]，但是之前版本显示："abc"，可以点击打开查看对象的内容。当然它们随着浏览器的迅速演进而变化，你看到的结果可能不同。</td>
    </tr>
</table>

`new String("abc")`创建了一个字符串`"abc"`的封装对象，而非基本类型值`"abc"`。

###内部类

类型（`typeof`）为`"object"`的值（如数组）包含一个附加的内部属性`[[Class]]`（可以把它看作一个内部的分类，而非传统意义上的类）。我们无法直接访问这个属性，但是通常可以通过`Object.prototype.toString(..)`来间接访问。例如：

```
    Object.prototype.toString.call( [1,2,3] );
    // "[object Array]"

    Object.prototype.toString.call( /regex-literal/i );
    // "[object RegExp]"
```

对于上例中的数组来说，内部`[[Class]]`为`"Array"`，对于正则表达式来说为`"RegExp"`。通常内部`[[Class]]`对应的是与值相关联的内建原生构建函数（见下），但情况并非总是如此。

那基本类型值呢？我们先来看看`null`和`undefined`：

```
    Object.prototype.toString.call( null );
    // "[object Null]"
    
    Object.prototype.toString.call( undefined );
    // "[object Undefined]"
```

你会注意到，虽然没有`Null()`和`Undefined()`这样的原生构建函数，内部`[[Class]]`仍然为`"Null"`和`"Undefined"`。

对于其他基本类型值来说，如：`string`，`number`和`boolean`，情况又不同，我们通常称之为“打包（boxing）”（参见`第42页的“打包封装”`）：

```
    Object.prototype.toString.call( "abc" );
    // "[object String]"
    
    Object.prototype.toString.call( 42 );
    // "[object Number]"
    
    Object.prototype.toString.call( true );
    // "[object Boolean]"
```

上面的示例代码中，基本类型值自动被打包为对应的封装对象，所以内部`[[Class]]`分别为`"String"`，`"Number"`和`"Boolean"`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">toString()和[[Class]]的行为在ES5和ES6中发生了一些变化，我们将会在本系列的《ES6 &amp; Beyond》一书中详细介绍。</td>
    </tr>
</table>

###打包封装

封装对象的用途很重要。基本类型值没有属性和方法，我们需要通过封装对象来访问`.length`和`.toString()`。好消息是，JS会在这个时候自动为基本类型值封装上对象：

```
    var a = "abc";
    
    a.length; // 3
    a.toUpperCase(); // "ABC"
```

如果你需要经常访问你的字符串中的属性和方法，比如在`for`循环中使用`i < a.length`，可能会觉得从一开始就创建一个该值的封装对象会比较好，这样JS引擎就不需要每次隐式地为你创建了。

但实际上这样做并不好。因为浏览器早就为`.length`这样的常见情况做了性能优化，如果你试图通过直接使用对象的方式（其并不在优化路径内）来“预先优化”你的代码，可能会让执行速度更慢。

通常我们不需要直接使用对象。最好是让JS引擎自己决定什么时候使用打包封装。换句话说就是应该优先考虑使用`"abc"`和`42`这样的基本类型，而不是`new String("abc")`，`new Number(42)`。

###封装对象释疑

使用封装对象时，有一些地方需要引起你的注意。

例如`Boolean`封装值：

```
    var a = new Boolean( false );
    
    if (!a) {
        console.log( "Oops" ); // never returns
    }
```

这里的问题是，你为`false`值创建了一个封装对象，但是对象本身总是返回`true`（“truthy”，见`第四章`），所以使用封装对象和使用`false`值返回的结果相反，这和我们预期的结果出入很大。

如果你想要自己对基本类型值进行封装，可以使用`Object(..)`函数（不带`new`）：

```
    var a = "abc";
    var b = new String( a );
    var c = Object( a );

    typeof a; // "string"
    typeof b; // "object"
    typeof c; // "object"
    
    b instanceof String; // true
    c instanceof String; // true

    Object.prototype.toString.call( b ); // "[object String]"
    Object.prototype.toString.call( c ); // "[object String]"
```

再次强调，我们不推荐自己使用封装对象，不过在一些特殊情况你可能需要这样做。

###拆封

如果你想要得到封装对象内的基本类型值，可以使用`valueOf()`函数：

```
    var a = new String( "abc" );
    var b = new Number( 42 );
    var c = new Boolean( true );

    a.valueOf(); // "abc"
    b.valueOf(); // 42
    c.valueOf(); // true
```

当封装对象遇到需要使用基本类型值的时候也会自动隐式地进行拆封。这个过程我们称为`强制（coercion）`，将在`第四章`详细介绍。

```
    var a = new String( "abc" );
    var b = a + ""; // `b` has the unboxed primitive value "abc"
    
    typeof a;       // "object"
    typeof b;       // "string"
```

###使用原生方法作为构造函数

对于`数组`，`对象`，`方法`和`正则表达式`这些值来说，我们总是倾向使用常量形式来产生值，其实常量形式和构造函数创建的对象是一样的（即都经过了封装）。

前面介绍过，应该尽量避免使用这些构造函数形式，除非你确实需要，因为它们通常会导致一些你不想碰到的疑难问题。

####Array(..)

```
    var a = new Array( 1, 2, 3 );
    a; // [1, 2, 3]

    var b = [1, 2, 3];
    b; // [1, 2, 3]
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">构造函数Array(..)前不需要带new关键字。你不指定的时候它也会当作你已经指定了。因此Array(1,2,3)和new Array(1,2,3)的结果是一样的。</td>
    </tr>
</table>

在只有一个参数时，`数组`构造函数有些特殊，这个参数会被当作数组预设的大小，而非数组中的内容。

这样处理实在不是一个好办法。首先你可能会不小心用错。

更重要的是，`数组`并没有预设大小这个概念。你创建的是一个空数组，只不过`length`属性被设置为指定的数值。

数组中的单元没有值，但是其`length`属性告诉我们那些单元是存在的，JS中这样的数据结构非常奇怪和让人困惑。这来自旧的，已经废弃的功能（象`arguments`这样的“类数组”）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">有至少一个空单元的数组我们称为“稀疏数组”。</td>
    </tr>
</table>

浏览器中的开发调试控制台对此也有不同的显示，给我们带来更多的困惑。

例如：

```
    var a = new Array( 3 );
    
    a.length; // 3
    a;
```

在Chrome中（到本书写成为止）`a`被序列化为`[ undefined x 3 ]`。很不幸，这表示数组中有三个值为`undefined`的单元，实际上并没有任何单元（“空单元（empty slots）也不是一个好的叫法”）。

我们来看看下面的代码，以便更好地理解不同情况的区别：

```
    var a = new Array( 3 );
    var b = [ undefined, undefined, undefined ];
    var c = [];
    c.length = 3;
    
    a; 
    b; 
    c;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">如你所见，本例中的c中，创建数组能够产生空单元。将length改为超过实际定义的单元数将隐式地导致空单元的产生。实际上在本例中，你甚至可以调用delete b[1]在数组b的中产生一个空单元。(JJ-?? slot如何翻译更适当)</td>
    </tr>
</table>

`b`会被序列化为`[ undefined, undefined, undefined ]`（在Chrome的当前版本中），而非`a`和`c`的`[ undefined x 3 ]`。头晕了吗？大家都一样。

更不幸的是，到本书写成为止，`a`和`c`在Firefox中显示为`[ , , , ]`。你看到让人困惑的地方了吧？仔细看下。三个逗号代表了4个空单元，而非我们设想的3个。

为什么呢！？Firefox在序列化末尾额外加了一个`,`，因为在ES5中列表（数组、属性列表等）末尾允许加逗号（会被忽略和去掉）。所以如果你在代码或者调试控制台中输入`[ , , , ]`，实际得到的值是`[ , , ]`（有三个空单元的数组）。这样做虽然比较让人困惑，目的是让拷贝粘贴更为精确。

读到这里你可能会摇头转眼珠，大家都一样！只能无奈地耸耸肩。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">Firefox即将输出改为[ <3 empty slots> ]这样的格式，相对于[ , , , ]来说是一个不小的改进。</td>
    </tr>
</table>

不幸的是还有更糟糕的事情。除了调试控制台显示上的困扰之外，示例代码中的`a`和`b`在有些情况下行为一致，有些情况下却不尽然：

```
    a.join( "-" ); // "--"
    b.join( "-" ); // "--"

    a.map(function(v,i){ return i; }); // [ undefined x 3 ]
    b.map(function(v,i){ return i; }); // [ 0, 1, 2 ]
```

额...。

调用`a.map(..)`方法会失败，因为数组中并没有单元，所以`map(..)`没有内容可以遍历。`join(..)`又不一样。我们可以将其想象为下面的实现代码：

```
    function fakeJoin(arr,connector) {
        var str = "";
        for (var i = 0; i < arr.length; i++) {
            if (i > 0) {
                str += connector;
            }
            if (arr[i] !== undefined) {
                str += arr[i];
            } 
        }
        return str; 
    }
    
    var a = new Array( 3 );
    fakeJoin( a, "-" ); // "--"
```

如你所见，`join(..)`假设数组中有单元，通过`length`值来循环。而`map(..)`内部的实现并不做这样的假设，所以其对“空单元”`数组`产生的结果无法预测，也容易导致各种问题。

所以如果想要创建一个数组，其中包含值为`undefined`的单元（而非“空单元”），我们该怎么做呢（除了手工编吗外）？

```
    var a = Array.apply( null, { length: 3 } );
    a; // [ undefined, undefined, undefined ]
```

有点难懂是吧？让我们看一看它是怎么回事。

`apply(..)`是一个工具函数，任何函数都可以调用，它用一种特别的方法来调用传递给它的函数。

第一个参数是对象本身的绑定（在本系列的《this & Object Prototypes》一书中有介绍），我们这里不用管，将它设置为`null`。第二个参数应该是一个`数组`（或者类似数组的值，即“类数组”对象）。该“数组”中的值作为调用函数的参数传递。

因此`Array.apply(..)`调用`Array(..)`方法，将`{ length: 3}`中的值作为参数。

在`apply(..)`中，我们设想那里有另外一个`for`循环（类似前面的`join(..)`），从`0`开始直到但不包括`length`（这里是`3`）。

它获取每个索引的值。如果在`apply(..)`中，数组对象参数为`arr`的话，就象这样来访问：`arr[0]`，`arr[1]`和`arr[2]`。当然在`{ length: 3 }`中没有这些值，所以返回的值为`undefined`。

换句话说，我们调用的是象这样的函数：`Array(undefined, undefined, undefined)`，这就是为什么我们最后得到的是一个单元值为`undefined`的数组，而非空单元。

虽然使用`Array.apply( null ,{ length: 3 } )`来创建单元值为`undefined`的数组显得比较奇怪和繁琐，但是远比使用`Array(3)`更好更可靠。

有一条底线必须要坚持：无论在什么情况下，永远、永远不要创建和使用空单元数组。不要这样做，空单元数组太糟糕了。

###Object(..), Function(..), and RegExp(..)

`Object(..)/Function(..)/RegExp(..)`构造函数通常也不是必须的（因此除非确实需要，否则我们应该尽量避免使用）：

```
    var c = new Object();
    c.foo = "bar";
    c; // { foo: "bar" }

    var d = { foo: "bar" };
    d; // { foo: "bar" }
    
    var e = new Function( "a", "return a * 2;" );
    var f = function(a) { return a * 2; }
    function g(a) { return a * 2; }
    
    var h = new RegExp( "^a*b+", "g" );
    var i = /^a*b+/g;
```

从实用性角度来说我们没有必要使用构造函数`new Object()`，并且它要求我们逐一定义属性，而不能使用常量形式一次性方便地定义。

构造函数`Function`在极少数情况下比较有用，比如你需要动态定义函数的参数和函数内容。不要将`Function(..)`当作`eval(..)`的替代品。你基本上不需要这样来定义函数。

我们强烈推荐使用常量形式（如：`/^a*b+/g`）来定义正则表达式，这样不仅语法简单，性能也更佳，因为JS引擎在执行代码之前会将其预编译并缓存。和前面介绍的构造函数不同，`RegExp(..)`在一些情况下比较有用，如动态定义正则表达式规则：

```
    var name = "Kyle";
    var namePattern = new RegExp( "\\b(?:" + name + ")+\\b", "ig" );

    var matches = someText.match( namePattern );
```

在JS中这样的情况不时出现，是合法的，因此你需要使用`new RegExp("pattern","flags")`。

###Date(..)和Error(..)

`Date(..)`和`Error(..)`这两个原生构造函数相比之下有用得多，因为没有常量形式来替代它们。

你必须使用`new Date()`来创建日期对象。`Date(..)`构造函数带参数时可以指定时间和日期，不带参数的话则使用当前日期。

使用该构造函数最主要是为了获得当前Unix系统时间（从1970年1月1日到现在的时间，以秒为单位）。你可以通过日期对象中的`getTime()`来获得该值。

从ES5开始，另一个更简单的方法是调用静态函数`Date.now()`。对ES5之前的版本我们可以如下polyfill：

```
    if (!Date.now) {
        Date.now = function(){
            return (new Date()).getTime();
        };
    }
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">如果在调用Date()时不带new，你将得到当前日期的字符串。在语言规范中没有指定具体的格式，但是浏览器倾向于使用类似这样的格式“Fri Jul 18 2014 00:31:02 GMT-0500 (CDT)”。</td>
    </tr>
</table>

构造函数`Error(..)`（和前面的`Array()`很类似）有没有`new`关键字效果是一样的。

创建错误对象的主要用途是获得当前运行堆栈的上下文信息（在大部分JS引擎中通过只读属性`.stack`来访问）。堆栈上下文信息包括函数调用堆栈和错误产生的代码行号，以方便我们调试。

一般我们将错误对象和`throw`操作符结合使用：

```
    function foo(x) {
        if (!x) {
            throw new Error( "x wasn't provided" );
        }
    // .. }
```

错误对象通常至少有一个`message`属性，有时候还有其他属性（当作只读属性处理），如：`type`。然而除了上述的`stack`属性，一般最好是直接调用方法`toString()`来获得格式化过的方便查看的错误信息（通过隐式或者显式强制，见`第四章`）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">从技术角度说，除了Error(..)之外，还有其他一些针对特定错误类型的原生方法：EvalError(..)，RangeError(..)，ReferenceError(..)，SyntaxError(..)，TypeError(..)，和URIError(..)。但是我们很少直接使用它们。如果程序产生异常时会自动调用这些方法（如：引用undeclared变量时产生ReferenceError错误）。</td>
    </tr>
</table>

###Symbol(..)

从ES6开始加入了一个新的基本数据类型“标识（Symbol）”。标识是一种特殊的唯一的（不绝对保证）值，可以用于对象属性而不用太担心产生冲突。引入该类型主要是为了ES6中的特殊构造，但是你也可以定义自己的标识。

标识可以被用作属性名，但是你无法在你的代码中看到和访问标识的实际值，在调试控制台中也不行。如果你试图在调试控制台中计算标识得值，你将看到诸如`Symbol(Symbol.create)`这样的内容。

在ES6中有几个与定义的标识，通过`Symbol`方法对象静态属性的方式访问，如：`Symbol.create`，`Symbol.iterator`等。它们的使用方法如下：

```
    obj[Symbol.iterator] = function(){ /*..*/ };
```

你可以使用`Symbol(..)`原生构造函数来定义自己的标识。它很独特，对其不能使用`new`，否则会产生错误：

```
    var mysym = Symbol( "my own symbol" );
    mysym;              // Symbol(my own symbol)
    mysym.toString();   // "Symbol(my own symbol)"
    typeof mysym;       // "symbol"
    
    var a = { };
    a[mysym] = "foobar";
    Object.getOwnPropertySymbols( a );
    // [ Symbol(my own symbol) ]
```

虽然标识实际上是非私有的（用`Object.getOwnPropertySymbols(..)`可以公开获得对象中的所有标识），但是我们主要还是将其用于私有和特殊属性的情况。大多数程序员将其用来替换属性名称中的下划线前缀，下划线前缀命名规范用来声明私有和特殊属性。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">标识并非对象，它们是简单标量基本值。</td>
    </tr>
</table>

###原生Prototypes

原生构造函数都有自己的`.prototype`对象，诸如：`Array.prototype`，`String.prototype`等等。

这些对象包含各自字类型特有的行为特征。

例如，所有的字符串对象，通过封装的字符串基本类型值，都能够访问`String.prototype`对象中定义的方法。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">根据文档规范，我们将String.prototype.XYZ简写为String#XYZ，对于其他.prototypes也如此。</td>
    </tr>
</table>

`String#indexOf(..)`
    在字符串中找到子字符串的位置

`String#charAt(..)`
    获得字符串中指定位置的字符

`String#substr(..)`，`String#substring(..)`，和` String#slice(..)`
    将字符串中的一部分提取出来形成新的字符串

`String#toUpperCase()`和`String#toLowerCase()`
    将字符串转换为大写和小写形式的新字符串

`String#trim()`
    去掉字符串前面和后面的空格，返回新的字符串

这些方法不更改字符串本身，是在字符串的基础上更改并创建一个新值。

由于prototype的代理的特点（参考本系列的《this & Object Prototypes》一书），任何字符串值都可以访问这些方法：

```
    var a = " abc ";
    
    a.indexOf( "c" ); // 3
    a.toUpperCase();  // " ABC "
    a.trim();         // "abc"
```

其他构造函数prototype包含它们各自类型的行为特征，比如：`Number#toFixed(..)`（将数值转换为包含制定整数位的字符串），和`Array#concat(..)`（合并数组）。所有的函数都可以访问由`Function.prototype`定义的`apply(..)`，`call(..)`，和`bind(..)`。

但是有些原生prototype并非单纯的对象：

```
    typeof Function.prototype;          // "function"
    Function.prototype();               // it's an empty function!
    
    RegExp.prototype.toString();        // "/(?:)/" -- empty regex
    "abc".match( RegExp.prototype );    // [""]
```

糟糕的是，你甚至可以更改这些原生prototypes（不仅仅是可能已经为你所熟悉的添加属性）：

```
    Array.isArray( Array.prototype );   // true
    Array.prototype.push( 1, 2, 3 );    // 3
    Array.prototype;                    // [1,2,3]

    // don't leave it that way, though, or expect weirdness!
    // reset the `Array.prototype` to empty
    Array.prototype.length = 0;
```

如你所见，`Function.prototype`是一个函数，`RegExp.prototype`是一个正则表达式，而`Array.prototype`是一个数组。很有意思吧？

###Prototypes作为默认值

`Function.prototype`是一个空函数，`RegExp.prototype`是一个“空”正则表达式（例如：找不到匹配），而`Array.prototype`是一个空数组，它们可以被用作很好的缺省值，来为那些还没有值的相应类型的变量赋值。

例如：

```
    function isThisCool(vals,fn,rx) {
        vals = vals || Array.prototype;
        fn = fn || Function.prototype;
        rx = rx || RegExp.prototype;
        return rx.test(
            vals.map( fn ).join( "" )
        ); 
    }

    isThisCool();       // true
    
    isThisCool(
        ["a","b","c"],
        function(v){ return v.toUpperCase(); },
        /D/
    );                  // false
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">到ES6为止，我们不再需要使用 vals = vals || .. 这样的缺省值语法（见第四章），因为我们可以通过函数声明中的原生语法来设置缺省值（见第五章）。</td>
    </tr>
</table>

该方法有一个小的好处就是`.prototypes`已经被创建好，并且只被创建一次。相比之下，使用`[]`，`function(){}`，和`/(?:)/`作为缺省值时（根据JS引擎的具体实现），每调用一次`isThisCool(..)`这些值都会被重复创建（稍后可能被垃圾回收）。这会造成内存和CPU资源的浪费。

还有需要注意的是，不要使用`Array.prototype`作为将来会被更改的缺省值。上例中，`vals`是作为只读变量来使用，但是如果你要更改vals的值，你实际上会更改`Array.prototype`本身，这会导致前面提到过的一些问题！

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">虽然我们介绍了这些原生prototypeshe它们的用途，在使用它们的时候还是需要特别小心，特别是要更改它们的时候。第167页中Appendix A的“Native Prototypes”部分有更详细的介绍。</td>
    </tr>
</table>

###回顾

JavaScript为基本数据类型值提供了封装对象，我们称为原生（`String`，`Number`，`Boolean`等）。这些封装对象为基本数据类型值提供了针对各自类型的方法和属性（`String#trim()`和`Array#concat(..)`）。

如果你有一个简单标基本值`"abc"`，你需要访问它的`length`属性或者`String.prototype`方法，JS引擎会自动封装该值（将其封装到相应类型的对象中）来实现对这些属性和方法的访问。

##第四章 强制类型转换

到目前为止我们对JavaScript的类型和值有了更全面的理解，现在让我们来讨论一个非常有争议的主题：强制（coercion）。

我们在`第一章`提到，有关强制是一个有用的特性还是一个设计缺陷的争论从JS诞生的第一天就开始了。在其他有关JS的流行书籍中你能看到有关强制的内容，大都是说它行为古怪，有害，令人困惑，完完全全是一个坏主意。

我们秉承本系列丛书的精神，不对强制特性退避三舍，虽然很多人这样做，并且不时还会碰到一些相关的怪异现象。对于不了解的事情，我认为你应该迎难而上，力争多了解一些。

这里我们旨在全面介绍强制特性的优点和缺点（确实有优点！），让你能够对何时使用到它做出恰当的决定。

###值转换

将值从一种类型转换为另一种通常称为“类型转换（type casting）”，这是指显式的情况，隐式的情况下，我们称作“强制类型转换（coercion）”（由值的使用方式相关规则来决定）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">虽然可能不是很明显，但是JavaScript中的强制总是返回标量基本值（见第二章），如：字符串，数字，和布尔值。强制不返回对象和函数。在第三章中我们介绍了“封装”，它在标量基本值外包装上一个相应类型的对象，但这并非严格意义上的强制。</td>
    </tr>
</table>

另一个区分这几个术语的方式是：“类型转换”在静态类型语言中是在编译时发生，而“强制类型转换”是发生于动态类型语言的运行时。

然而在JavaScript中，大多数人都将这一类的转换称为`强制类型转换`，我个人则倾向于使用“隐式类型转换”和“显式类型转换”来区分。

它们之间的区别显而易见：当你阅读代码时能够清楚地看出哪些地方发生了“显式类型转换”，而“隐式类型转换”则不那么明显，通常以一些操作的副作用的形式产生。

例如下面两个强制类型转换的例子：

```
    var a = 42;
    
    var b = a + "";         // implicit coercion
    
    var c = String( a );    // explicit coercion
```

对于变量`b`而言，强制类型转换隐式地发生，因为`+`操作符的其中一个操作数是字符串，因此这是一个字符串拼接操作，所以作为（隐式）副作用，值`42`被强制转换为其相应的字符串值：`"42"`。

不同的是，函数`String(..)`显式地将`a`强制转换为字符串。

两者均将数值`42`转换为字符串`"42"`。但是它们具体的实现方式则带来了很多对JavaScript强制转换的争论。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从技术角度来说，除了形式上的差别外，这里还有一些细微的行为上的差别。我们将在下一章第87页的“Implicitly: Strings &lt;--&gt; Numbers”详细介绍。</td>
    </tr>
</table>

这里使用的术语“显式”和“隐式”，“明显”和“隐式副作用”都是相对的。

如果你理解`a + ""`，并且有意使用它来实现字符串转换，你可能觉得这样的操作是“显式”的。反之，如果你从来没见过`String(..)`被用于`字符串`强制转换，你可能会觉得它是“隐式”的。

但是这里我们讨论的“显式”和“隐式”是一个普遍公认的标准，而非JS专家和程序员的标准。如果这与你的定义不符合，你可能需要根据我们的定义来调整。

请记住：我们写的代码大都会被其他人读到。即使你已经是一个JS的专家，你可需要考虑其他水平的同事能否读懂你的代码。他们对于“显式”和“隐式”的定义是否和你一样？

###抽象值操作

在介绍“显式”和“隐式”类型转换之前，我们需要掌握将值转换为`字符串`，`数字`，和`布尔型`的基本规则。ES5规范里第9节中定义了几个“抽象操作”（是针对“仅内部操作”的规范用语）及其转换规则。我们这里着重介绍`ToString`，`ToNumber`，和`ToBoolean`，附带介绍`ToPrimitive`。

####ToString

规范9.8节中定义的抽象操作`ToString`负责完成从非字符串值到`字符串`值的强制转换。

内建基本类型值有一些自然的字符串化规则：`null`转换为`"null"`，`undefined`转换为`"undefined"`，`true`转换为`"true"`。`数字`的字符串化规则一般如你所料，但是我们在`第二章`介绍过，那些非常小和非常大的`数字`是使用指数形式表示：

```
    // multiplying `1.07` by `1000`, seven times over
    var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;

    // seven times three digits => 21 digits
    a.toString(); // "1.07e21"
```

对于常规对象，除非你另有指定，否则缺省的`toString()`（在`Object.prototype.toString()`中）返回值为内部的`[[Class]]`（见第三章），例如：`"[object Object]"`。

但是之前介绍过，如果对象有自己的`toString()`方法，在将其转换为字符串时会调用该方法，得到的是该方法返回的`字符串`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">对象强制类型转换为字符串这一过程是通过ToPrimitive抽象操作来完成的（ES5规范，9.1节），我们稍后将在本章的ToNumber一节中详细介绍，我们在此略过。</td>
    </tr>
</table>

`数组`有一个被重载的缺省`toString()`方法，将所有单元值的字符串值通过`","`连接起来：

```
    var a = [1,2,3];

    a.toString(); // "1,2,3"
```

再次强调，`toString()`可以被显式调用，在`字符串`处理过程中遇到非字符串时也会被调用。

####JSON字符串化

另一个和`ToString`相关的可怕的情况是使用`JSON.stringify(..)`工具将JSON对象序列化为`字符串`。

值得注意的是这里的字符串转换并非严格意义上的强制类型转换。不过由于其和前面提到的`ToString`规则相关，我们在这里稍微岔开话题讨论下JSON字符串化。

对于大多数简单值来说，JSON字符串化基本上和`toString()`一样，除了序列化结果永远是一个字符串：

```
    JSON.stringify( 42 );   // "42"
    JSON.stringify( "42" ); // ""42"" (a string with a
                            // quoted string value in it)
    JSON.stringify( null ); // "null"
    JSON.stringify( true ); // "true"

```

JSON安全值能够使用`JSON.stringify(..)`来字符串化。但是什么叫做JSON安全值呢？就是能够使用JSON格式来呈现的值都叫做JSON安全值。

为了说明问题，我们来看看什么是非JSON安全值。诸如：`undefined`，`functions`，（ES6+）`symbols`和包含环型引用（即对象之间永无止尽地相互引用）的`objects`。这些值对于标准JSON结构来说都是非法值，主要是因为其他支持JSON值的语言来说无法处理这些值。

`JSON.stringify(..)`工具在遇到`undefined`，`function`和`symbol`这样的值时会自动忽略。如果数组中这样的值会被`null`替代（从而单元位置信息保持不变）。如果属性是对象则会被排除。

例如：

```
    JSON.stringify( undefined );        // undefined
    JSON.stringify( function(){} );     // undefined
 
    JSON.stringify(
       [1,undefined,function(){},4]
    );                                  // "[1,null,null,4]"
    JSON.stringify(
       { a:2, b:function(){} }
    );                                  // "{"a":2}"
```

当试图对包含环形引用的对象运行`JSON.stringify(..)`时会产生错误。

当某个对象包含`toJSON()`方法时，JSON的字符串化会有一些特殊，该方法会先被调用以获得用于序列化的返回值。

如果你试图JSON字符串化含有非法JSON值的对象，或者对象中的某些值无法被序列化的时候，你就需要为其定义`toJSON()`方法，使之返回一个JSON安全的值。

例如：

```
    var o = { };

    var a = { 
        b: 42,
        c: o,
        d: function(){}
    };

    // create a circular reference inside `a`
    o.e = a;
    
    // would throw an error on the circular reference
    // JSON.stringify( a );
    
    // define a custom JSON value serialization
    a.toJSON = function() {
        // only include the `b` property for serialization
        return { b: this.b };
    };
    
    JSON.stringify( a ); // "{"b":42}"
```

我们通常会误认为`toJSON()`必须返回一个JSON字符串化的结果。这样并不准确，除非你确实想让`字符串`的`.toJSON()`返回一个恰当的值（通常不会这样！），然后`JSON.stringify(..)`负责处理字符串化。

换句话说，`toJSON()`应该被理解为“转换为JSON安全的值使其更便于被字符串化”，而非很多程序员误解的“转换为JSON字符串”。

例如：

```
    var a = {
        val: [1,2,3],

        // probably correct!
        toJSON: function(){
            return this.val.slice( 1 );
        }
    };
    
    var b = {
        val: [1,2,3],
        // probably incorrect!
        toJSON: function(){
            return "[" +
                this.val.slice( 1 ).join() +
            "]"; 
        }
    };
    
    JSON.stringify( a ); // "[2,3]"
    
    JSON.stringify( b ); // ""[2,3]""
```

第二个函数调用字符串化的是返回的`字符串`而非`数组`本身，这可能并不是我们预期的结果。

借讨论`JSON.stringify(..)`的机会，我们在这里介绍几个不太为人所知但是仍然非常有用的功能。

我们可以向`JSON.stringify(..)`传递可选参数`replacer`作为其第二个参数。它可以是一个`数组`或者`函数`，通过一种过滤机制来指定应该包含和排除哪些属性，从而实现对象递归序列化的定制，类似于`toJSON()`。

如果`replacer`是一个`数组`，它必须是一个`字符串``数组`，其中每个元素是序列化需要包含的属性名称。`数组`之外的属性会被忽略。

如果`replacer`是一个`函数`，它会在`对象`本身被调用一次，然后对`对象`的每个属性被调用一次，每次调用传递两个参数，`key`和`value`。如果要在序列化中忽略某个`key`，则返回`undefined`。否则返回指定的`值`。

```
    var a = { b: 42,
        c: "42",
        d: [1,2,3] 
    };
    
    JSON.stringify( a, ["b","c"] ); // "{"b":42,"c":"42"}"
    
    JSON.stringify( a, function(k,v){
        if (k !== "c") return v;
    } );
    // "{"b":42,"d":[1,2,3]}"
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">在函数replacer这个例子中，key参数k在第一次调用时为undefined（就是传递对象本身的时候）。if语句将属性名"c"排除掉。字符串化是递归的，因此数组[1,2,3]中的每个元素都通过参数v传递给replacer，参数k则为索引值（0，1和2）。</td>
    </tr>
</table>

`JSON.string`还接受第三个可选参数，叫做*space*，它用来指定用户友好输出格式的缩进。*space*值为正数时指定每一级缩进的字符数。*space*值还可以是字符串，此时最前面的10个字符会被用来作为每一级缩进：

```
    var a = { 
        b: 42,
        c: "42",
        d: [1,2,3] 
    };
    
    JSON.stringify( a, null, 3 );
    // "{
￼   //      "b": 42,
    //      "c": "42",
    //      "d": [
    //          1, 
    //          2,
    //          3
    //      ]
    // }"

    JSON.stringify( a, null, "-----" );
    // "{
    // -----"b": 42,
    // -----"c": "42",
    // -----"d": [
    // ----------1,
    // ----------2,
    // ----------3
    // -----]
    // }"
```

请记住，`JSON.stringify(..)`并非强制类型转换的一种形式。我们在这里讨论它是因为它和`ToString`强制类型转换之间的关联，两个原因：

1. `string`，`nuber`，`boolean`和`null`等值为JSON进行的字符串化和它们通过抽象操作`ToString`被强制类型转换为`stirng`是一样的。

2. 如果你将一个`object`传递给`JSON.stringify(..)`，并且该`object`
中有`toJSON()`方法，`toJSON()`在字符串化之前会被自动调用，将值“强制类型转换”为JSON安全值。

####ToNumber

在有些情况下，非数字值需要被当作`数字`使用，如数学运算，ES5规范9.3节中定义了抽象操作`ToNumber`。

例如，`true`转换为`1`，`false`转换为`0`。`undefined`转换为`NaN`，而`null`则是`0`。

对于`string`值，`ToNumber`基本遵照数字常量相关规则／语法（见第三章）。失败时则返回`NaN`值（而非数字常量情况下的语法错误）。一个不同之处是以'0'作为前缀的十六进制数并不按十六进制处理（而是按十进制处理），即使十六进制是合法的`数字`常量（见第二章）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">数字常量与字符串通过ToNumber转换之间的区别是很微小的，因此这里不做进一步介绍。详细介绍请参考ES5规范的第9.3.1节。</td>
    </tr>
</table>

对象（还有数组）会首先被转换为它们对应的基本类型值，然后返回值（是基本类型但还不是`数字`）根据前面提到的规则被强制转换为数字。

转换为基本类型值时，抽象操作`ToPrimitive`（见ES5规范第9.1节）会先检查待转换的值是否有`valueOf()`方法（使用内部`DefaultValue`操作，见ES5规范第8.12.8节）。如果有`valueOf()`并且返回基本类型值，则使用该值进行强制类型转换。如果没有`valueOf()`方法，则使用`toString()`的返回值（如果有的话）来进行强制类型转换。如果
前两者均不返回基本类型值，则产生`TypeError`错误。

从ES5开始，你可以创建不能进行强制类型转换的对象，即没有`valueOf()`和`toString()`方法，如果对象通过`Object.create(null)`创建，`[[Prototype]]`为`null`。详细介绍请参考本系列中*《this & Object Prototypes》*一书`[[Prototype]]`相关部分。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">我们稍后将详细介绍数字的强制类型转换，在下个代码示例中我们暂时假设函数Number(..)已经实现了数字的强制类型转换。</td>
    </tr>
</table>

例如：

```
    var a = {
        valueOf: function(){
            return "42";
        }
    };
    
    var b = {
        toString: function(){
            return "42";
        }
    };
    
    var c = [4,2];
    c.toString = function(){
        return this.join( "" ); // "42"
    };

    Number( a );            // 42
    Number( b );            // 42
    Number( c );            // 42
    Number( "" );           // 0
    Number( [] );           // 0
    Number( [ "abc" ] );    // NaN
```

####ToBoolean

下一步我们来介绍一下JS中的`boolean`类型。有关这个主题存在很多困惑和误解，所以请格外注意。

首先一点是，JS有两个关键词`true`和`false`，它们是`boolean`的两个仅有的合法值。一个常见的误区是数值`1`和`0`等同于`true`和`false`。在有些语言中可能如此，而在JS中`boolean`和`number`是不同的。你可以将`1`强制类型转换为`true`（反之亦然），将`0`强制类型转换为`false`（反之亦然）。但它们终究是不同的。

#####假值（Falsy values）

但是事情远没有这么简单。我们需要了解上面两个值之外的其他值是如何被强制转换为`boolean`值的。

JavaScript中所有的值可以被分为两类：

1. 在强制类型转换为`boolean`值时为`false`
2. 其他（在强制类型转换为`boolean`值时为`true`）

我可不是自己在这里分门别类。JS规范中定义了一组具体的为数不多的值，在强制类型转换为`boolean`值时为`false`。

那么是哪些值呢？ES5规范第9.2节定义了抽象操作`ToBoolean`，它明确定义了强制类型转换为`boolean`值时的所有可能的结果。

其中的这些值我们称为假值（“falsy” values）：

- `undefined`
- `null`
- `false`
- `+0`，`-0`和`NaN`
- `""`

上面的值在强制类型转换为`boolean`值时为`false`。

我们会顺理成章地认为，不在该列表中的值将会被转换为`true`，称之为真值（“truthy” values）。但是JS对此并没有明确定义。规范只给出了一些例子，诸如所有对象都是真值，其仅暗示了所有不在假值列表中的都是真值。

#####假对象（Falsy objects）

等一等，本节的标题似乎和前面的内容有点矛盾。我们不是说过规范中定义了所有对象都是真值吗？怎么还会有假对象这种情况。

这究竟是什么意思？

你可能会认为这是包装假值的封装对象（见`第三章`，如：`""`，`0`和`false`）。但是别被它的字面欺骗了。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">有的人可能会领会到这是规范一个隐晦的小玩笑。</td>
    </tr>
</table>

例如：

```
    var a = new Boolean( false );
    var b = new Number( 0 );
    var c = new String( "" );
```

它们都是封装了假值的对象（见`第三章`）。在强制类型转换中它们是`true`还是`false`呢？这很容易回答：

```
    var d = Boolean( a && b && c );
    
    d; // true
```

它们都返回`true`，因而`d`的值是`true`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">请注意Boolean(..)封装a &amp;&amp; b &amp;&amp; c的方式，你可能会问为什么需要它。暂且记下，本章稍后会作说明。你可以不使用Boolean(..)，然后测试一下d = a &amp;&amp; b &amp;&amp; c的结果。</td>
    </tr>
</table>

如果`假对象`不单纯是封装假值的对象，那它究竟是什么？

奇怪的是它有可能在你的JS代码中出现，实际上却并不属于JavaScript语言。

什么！？

在一些情况下浏览器会在JS语法之外自己创建一些`外来`值，即“假对象”。

“假对象”看起来和普通对象一样（有属性等），但是当你将其强制类型转换为`boolean`值时，会得到`false`结果。

为什么？

最常见的例子是`document.all`，一个类似数组的对象，它包含了页面上的所有元素，由DOM提供给你的JS代码使用（而非JS引擎本身）。从前它是一个真正意义上的对象，而现在则是“假对象”。

`document.all`不是一个标准用法，因而很早就不再使用了。

“那浏览器能否将它彻底去掉？”，抱歉，想法是好的。希望如此。但是目前很多JS程序在使用它。

那为什么让它为假（`falsy`）呢？因为将`document.all`强制类型转换为`boolean`（如在if语句中）基本上是用来检测浏览器是否是老版本的非IE浏览器。IE很早以前就遵循了浏览器标准，相比其他浏览器在很多方面更好地推进了Web的发展。

但是那些`if(document.all) { /* it's IE */ }`代码仍然还在，并且可能一直会存在。这些代码仍然假设自己运行在老版本的IE中，对IE用户而言不是很好的体验。

虽然我们不能彻底去掉`document.all`，但是IE却不想继续支持`if (document.all) { .. }`，使用新版本的、复合标准的IE的用户也不想。

“我们应该怎么办？”

“我知道了！我们可以更改JS类型机制，不让`document.all`成为假值！“。

额。这不是一个好办法。大部分JS程序员对这个难点都不太理解。但是替代的办法（对此不作任何处理）更加糟糕。

这就是我们现在的境遇：令人抓狂的，非标准的”假值“被浏览器加入到JavaScript中。耶！

#####真值

让我们回到真值列表。真值究竟又是什么东西？记得吗：没有在假值列表中的都是真值。

例如：

```
    var a = "false";
    var b = "0";
    var c = "''";

    var d = Boolean( a && b && c );
    
    d;
```

你觉得`d`的值应该是什么？是`true`还是`false`。

答案是`true`。为什么呢？虽然这些`字符串`值看似`假值`，其实`字符串`值都是`真值`，因为`""`是唯一一个在`假值`列表中的`字符串`。

再如：

```
    var a = [];             // empty array--truthy or falsy?
    var b = {};             // empty object--truthy or falsy?
    var c = function(){};   // empty function--truthy or falsy?

    var d = Boolean( a && b && c );
    
    d;
```

你可能猜到了，`d`的值仍然是`true`。为什么呢？还是同样的原因。`[]`，`{}`，和`function(){}`都不在`假值`列表中，因此它们都是`真值`。

换句话说，`真值`列表可以无限长，从而无法对其做一个定义，所以我们只能定义`假值`列表并且以它为参照。

你可以花个五分钟的时间，将`假值`列表写出来贴在你的显示器上，或者用脑袋记住。这样你遇到真假值的时候可以轻易地做出判断。

真假值的重点在于理解值在被强制类型转换为`boolean`值时（显式和隐式）的行为。现在你对真假值有了一个理解，我们可以看看强制类型转换的示例。

####显式强制类型转换（Explicit Coercion）

显式类型转换是显式和明确的类型转换，很多类型转换都属于此类。

这里我们旨在让我们的代码能够清晰明确地呈现此类转换，以免留坑让其他人不小心掉进去。此类转换表达得越清晰，我们的代码就越易读。

显式强制类型转换的好处毋庸置疑，它与我们熟悉的静态类型语言中的类型转换基本一致。因此我们应该可以认为没人对显式强制类型转换有任何争议和不满。不过，我们稍后会回到这个话题。

#####字符串和数字之间的显式类型转换

我们从最常见的`字符串`和`数字`之间的转换开始。

我们使用内建的`String(..)`和`Number(..)`函数（我们称为“原生构造函数，见`第三章`”）在`字符串`和`数字`之间进行转换，值得注意的是，它们前面不带`new`关键字。因此并没有创建任何封装对象。

我们这里是显式地在两个类型之间做转换：

```
    var a = 42;
    var b = String( a );
    
    var c = "3.14";
    var d = Number( c );
    
    b; // "42"
    d; // 3.14
```

`String(..)`遵循前面提到的`ToString`操作规则，将值转换为`字符串`。`Number(..)`遵循前面提到的`ToNumber`操作规则，将值转换为`数字`。

将它们称为显式强制类型转换是因为，对大多数程序员来说这样的转换形式是很明显的，转换结果是指定的类型的值。

实际上，这样的用法和许多静态类型语言很相似。

例如，在C/C++中，你可以用`(int)x`或者`int(x)`将值`x`转换为整数。两种方式都可以，但是大多数人喜欢后者，因为它看起来象一个方法调用。在JavaScript中使用`Number(x)`与之及其类似。至于它在JS中是否真的是一个方法调用则没有太大关系。

除了`String(..)`和`Number(..)`，还有其他方法可以实现`字符串`和`数字`之间的转换：

```
    var a = 42;
    var b = a.toString();
    
    var c = "3.14";
    var d = +c;

    b; // "42"
    d; // 3.14
```

调用`a.toString()`表面上看起来非常显式（很明显“toString”表示“to a string”），不过它有一些隐蔽的隐式转换行为。`toString()`不能在象`42`这样的基本类型值上被调用。所以JS引擎会自动为`42`封装一个对象（见`第三章`），以便在该对象上调用`toString()`。即显式转换中的隐式转换。

上例中的`+c`是`+`操作符的`一元操作服符`形式（只有一个操作数和操作符）。`+`操作符显式地将操作数`c`转换为`数字`值，而不是进行数学加法（也不是字符串拼接，见下）。

那么`+c`是不是显式强制类型转换呢？这要看你自己的经验和理解。如果你知道一元运算符`+`代表显式强制类型转换`数字`值，那么它就是显式的。然而如果你不知道的话，它就会显得很让人困惑了，是隐式的强制类型转换，并有不为人知的副作用等。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">根据JS开源社区中的普遍观点，一元运算+是显式强制类型转换。</td>
    </tr>
</table>

即使你很喜欢`+c`这样的形式，它在一些情况下会非常令人费解。例如：

```
    var c = "3.14";
    var d = 5+ +c;

    d; // 8.14
```

一元运算符`-`和`+`在强制类型转换时的行为一样，不过它同时也反转数字的符号。然而你不能使用两个`-`（--）来取消反转，因为`--`会被当作递减操作符来处理。所以你需要用`- -"3.14"`这样的形式，在其间加一个空格，结果既为`3.14`。

你可能能够想到所有这些可能的组合，下面是另一个抓狂的例子：

```
    1 + - + + + - + 1;  // 2
```

在和其他运算符相邻的时候，我们应该极力避免使用一元运算符`+`（和`-`）来做强制类型转换。虽然上面的例子没有问题，但是普遍认为并不是一个好的做法。甚至`d = +c`（和`d =+ c`）都很容易与`d += c`混淆起来，它们之间的区别大了去了。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">另一个非常容易让人混淆的情况是一元运算符和++及--相邻。例如a +++b, a + ++b, and a + + +b。有关++请参见第125页“表达式的副作用”</td>
    </tr>
</table>

请记住，本书旨在解释清楚令人费解的地方，而非火上浇油。

#####日期转换为数字

一元运算符`+`的另一个常见用法是将`日期`对象强制类型转换为`数字`，因为结果值是Unix的时间戳格式（从1970年1月1日00:00:00 UTC起到现在的时间，以微秒为单位）：

```
    var d = new Date( "Mon, 18 Aug 2014 08:53:06 CDT" );

    +d; // 1408369986000
```

通常我们用这种方式来获得当前时间`now`的时间戳格式，例如：

```
    var timestamp = +new Date();
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">一些人注意到了JavaScript中的一个奇特的语法，即不带参数的时候，在构造函数上使用()（即使用new来调用构造函数）不是必须的。所以你可能会碰到 var timestamp = +new Date; 这样的写法。然而并非人人都觉得不带()会让代码更易读，因为只有 new fn() 这样的情况才适用，一般的 fn() 情况不适用。</td>
    </tr>
</table>

从`日期`对象得到时间戳并非只能使用强制类型转换。其他方法可能更好一些，因为更显式：

```
    var timestamp = new Date().getTime();
    // var timestamp = (new Date()).getTime();
    // var timestamp = (new Date).getTime();
```

不过最好的方式是使用`Date.now()`静态方法，从ES5中开始加入：

```
    var timestamp = Date.now();
```

如果你想要为老版本的恶浏览器polyfill`Date.now()`也很简单，如下：

```
    if (!Date.now) {
        Date.now = function() {
            return +new Date();
        };
    }
```

我建议对日期不要使用强制类型转换。使用`Date.now()`来获得当前时间戳，`new Date(..).getTime()`来获得指定时间的时间戳。

#####令人好奇的~

~这个操作符（也叫做“非”字位操作）常常被人们忽视，同时又非常令人费解，它也可以实现强制类型转换。甚至程序员即便了解它也会尽量避免使用它。但秉承本书的一贯宗旨，让我们来看看能否从中发现有用的内容。

在第23页“32位（带符号）整数”中，我们介绍过字位操作符只适用于32位操作数，这意味着它们将会强制操作数遵循32位值的表示方式。这是通过`ToInt32`抽象操作来实现的（ES5规范第9.5节）。

`ToInt32`首先进行`ToNumber`强制类型转换，如值`"123"`将会首先被转换为`123`，然后再执行`ToInt32`规则。

当字位操作符（如`|`和`~`）和某些特殊`数字`值一起使用时会导致强制类型转换从而产生不同的`数字`结果值。

让我们先来看看`|`（字位“或”）操作符在no-op(JJ-??)`0 | x`情况下（在`第二章`介绍过）仅仅执行`ToInt32`转换：

```
    0 | -0;         // 0
    0 | NaN;        // 0
    0 | Infinity;   // 0
    0 | -Infinity;  // 0
```

上面这些特殊数字不能够以32位方式呈现（因为它们来自于64位IEEE 754标准，见`第二章`），因此`ToInt32`对它们返回结果值`0`。

至于`0 | __`是`显式`还是`隐式`的`ToInt32`转换则存在争议。从规范的角度来说毫无疑问是`显式`的，但是如果你对字位操作符没有足够的理解，它对你可能就是`隐式`的魔术。不过为了和本书其他地方保持一致，我们将其视为`显式`。

让我们回到`~`。它首先将值“强制类型转换”为`32位数字`，然后执行字位反转（反转每一个字位值parity(JJ-??)）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这和!很相像，它不仅将值强制转换为boolean值，还反转值的parity(JJ-??)（见第83页“显式强制类型转换：*-->Boolean”）</td>
    </tr>
</table>

但是话说回来，为什么我们要关注字位反转？这些事情即专业又微妙。JS程序员很少需要考虑每个字位。

`~`的另一个定义来自于早先的计算机科学和离散数学：`~`得到2的余数。这样解释事情就清楚多了！

我们再来看看：`~x`大致和`-(x+1)`一样。这很奇怪，但是也很容易理解。于是：

```
    ~42;    // -(42+1) ==> -43
```

你可以仍然在疑惑`~`这个东西究竟是什么，为什么我们会将它和强制类型转换一起讨论。让我们直入主题。

以`-(x+1)`为例。唯一能得到结果`0`（或者严格来说是`-0`）的`x`是哪个值？是`-1`。换句话说，如果熟入为`-1`，`~`和一组`数字`一起能够得到一个假值`0`（能够被很简便地强制类型转换为`false`），否则则得到其他的真值`数字`。

这和我们的讨论有什么关系？

`-1`通常被称为“哨位值”，意指一个值在其同类型值（`数字`）中被赋予了任意的语法含义。在C语言中我们使用`-1`来作为函数执行失败的返回值，使用`>= 0`的值来作为函数执行成功的返回值。

JavaScript在定义`字符串`操作`indexOf(..)`时遵循了这个惯例，该操作在指定字符串中搜索一个子字符串，如果找到则返回它在字符串中的位置（从0开始计算的位置），否则返回`-1`。

通常我们不只用`indexOf(..)`来获得子字符串的位置，也用它来检查`字符串`是否包含子字符串，相当于判断一个`布尔`类型值。见下例：

```
    var a = "Hello World";
    
    if (a.indexOf( "lo" ) >= 0) {   // true
        // found it!
    }
    if (a.indexOf( "lo" ) != -1) {  // true
        // found it }
    if (a.indexOf( "ol" ) < 0) {    // true
        // not found!
    }
    if (a.indexOf( "ol" ) == -1) {  // true
        // not found!
    }
```

我觉得使用`>= 0`和`== -1`不是太优雅。这样有点“暴露式抽象”的意思，也就是在我们自己的代码中暴露了底层的具体实现，即使用`-1`作为失败时的返回值这个具体实现。所以我倾向于屏蔽这些实现细节。

现在我们明白`~`能起到什么作用了！对`indexOf()`使用`~`可以将结果“强制类型转换”（实际上是转换）为适当的`布尔`值：

```
    var a = "Hello World";
    
    ~a.indexOf( "lo" );         // -4 <-- truthy!
    
    if (~a.indexOf( "lo" )) {   // true
        // found it!
    }
    
    ~a.indexOf( "ol" );         // 0  <-- falsy!
    !~a.indexOf( "ol" );        // true
    
    if (!~a.indexOf( "ol" )) {  // true
        // not found!
    }
```

`~`将`indexOf(..)`的返回值转换为：失败情况的`-1`转换`为假值0`，其他情况则转换为`真值`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">-(x+1)对于~而言意味着~-1为-0，但是实际上是0，因为它是字位操作，而非数学运算。</td>
    </tr>
</table>

从技术角度，`if (~a.indexOf(..))`仍然是将`indexOf(..)`的返回结果进行隐式强制类型转换，`0`转为为`false`，其他情况则是`true`。但是总的来说，我感觉`~`更象显式强制类型转换，只要你了解它的实际原理。

我认为使用`~`比`>= 0`和`== -1`更简洁。

#####字位截除

你在JS代码中可能会时不时遇到`~`，一些程序员使用`~~`来截除`数字`值的小数部分（即转换为整数）。通常我们认为这和`Math.floor(..)`效果是一样的，实际上并不是。

`~~`的具体工作原理是，第一个`~`执行“强制类型转换”`ToInt32`并反转字位，然后第二个`~`在进行一次字位反转，将所有字位反转回原来的样子。所有的结果既是“强制类型转换”`ToInt32`（也叫做截除）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">~~和!!很相似，我们在第83页“显式强制转换：*-->Boolean”会介绍。</td>
    </tr>
</table>

不过我们需要对`~~`多加注意和说明。首先，它仅对32位数值可靠。更重要的是，和`Math.floor(..)`不同，它对负数无效。

```
    Math.floor( -49.6 );    // -50
    ~~-49.6;                // -49
```

抛开与`Math.floor(..)`的区别不谈，`~~x`能够将值截除为一个32位整数。同样地，`x | 0`也可以，并且显得（稍微）更便捷一些。

那么我们为什么倾向于使用`~~x`而不是`x | 0`呢？因为考虑到操作符优先级（详见第五章）：

```
    ~~1E20 / 10;        // 166199296
    1E20 | 0 / 10;      // 1661992960
    (1E20 | 0) / 10;    // 166199296
```

和这里介绍过的其他操作符号一样，我们的建议是，只有在确保完全理解的前提下，才推荐使用`~`和`~~`进行显式强制类型转换。

#####显式：解析数字字符串

要将`字符串`强制类型转换为`数字`，还可以通过解析字符串中的数字来实现。然而这个方法和我们之前介绍过的方法还是有明显的区别。

例如：

```
    var a = "42";
    var b = "42px";

    Number( a );    // 42
    parseInt( a );  // 42
    
    Number( b );    // NaN
    parseInt( b );  // 42
```

解析字符串中的数字可以允许字符串中含有非数字字符，按从左自右的顺序，如果遇到非数字字符则停止解析。然而强制类型转换不允许非数字字符，否则会失败并返回值`NaN`。

字符串解析并不能被视为强制类型转换的替代方法。它们虽然相似，但却有着不同的用途。如果你能够忽略字符串右边的非数字字符，则可以使用字符串解析。而将`字符串`强制类型转换为`数字`则要求字符串中所有的字符都是数字，"42px"这样的非数字字符串是不行的。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">
            parseInt(..)还有一个同胞，parseFloat(..)，它的功能是从字符串中解析浮点数。
        </td>
    </tr>
</table>

请记住，`parseInt(..)`针对的是字符串值。向`parseInt(..)`传递数字和其他类型的参数是没有意义的，比如：`true`，`function(){...}`，和`[1,2,3]`。

如果传递的参数不是字符串，参数值将会首先被强制类型转换为字符串（见`第59页的“ToString”`），显而易见这是隐式强制类型转换。这样的代码风格不好，所以应该避免向parseInt(..)传递非字符串参数。

在ES5之前，`parseInt(..)`中有一个不太为人知的特性，成为很多JS程序bug的根源。如果你没有传递第二个参数来指定字符串转换为数字时的基数（也叫做radix），`parseInt(..)`将根据字符串的第一个字符来自己猜测决定。

如果第一个字符是`x`或者`X`，则该函数猜测你要将字符串转换为十六进制数字。如果第一个字符是`0`，则转换为八进制数字。

十六进制数字（以'x'或者'X'开头）并不是很容易被混淆起来。但是八进制数字则不然，它们非常常见。例如：

```
    var hour = parseInt( selectedHour.value );
    var minute = parseInt( selectedMinute.value );
    
    console.log(
       "The time you selected was: " + hour + ":" + minute
);
```

这段代码看起来没有问题。但是当小时数为`08`，分钟数为`09`时，结果将是`0:0`。原因是`8`和`9`不是有效的八进制数。

这个问题的解决方法很简单，同时也很容易被忽略：总是将第二个参数设置为10。这样就绝对安全了：

```
    var hour = parseInt( selectedHour.value, 10 );
    var minute = parseInt( selectedMiniute.value, 10 );
```

从ES5开始，`parseInt(..)`不再进行这样的猜测。或者说，函数默认转换为十进制数。这样好得多。如果你的代码要在ES5之前的环境下运行，仍然要注意将第二个参数设置为10。

#####解析非字符串

另一个有些臭名昭著的`parseInt(..)`特性，多年前曾经出现在一个讽刺笑话帖子中：

```
    parseInt( 1/0, 19 ); // 18
```

假设是这样（虽然完全不成立），“如果我传递一个`Infinity`参数，那么解析结果应该也是`Infinity`，而不是`18`”。JS返回这样的结果一定是疯了，对不对？

虽然这个例子纯属杜撰，让我们姑且放任之，来看一看JS是否真有那么疯狂。 

首先，这个例子中的第一个错误是传递了一个非字符串参数给`parseInt(..)`。千万不要这样做，否则你是在自找麻烦。如果你的确这样做了，JS也会礼貌地将参数强制类型转换为它能够处理的字符串。

有人可能会觉得这样做不合理，`parseInt(..)`应该拒绝非字符串参数。那么它是不是应该为此产生一个错误呢？坦白说这是Java的做法。我一想到JS代码中到处是抛出的错误，然后必须使用`try..catch`来处理错误，整个人都不好了。

那么它是不是应该为此返回`NaN`？也许吧，但是对于下面这样的情况：

```
    parseInt( new String( "42") );
```

函数是否应该运行失败？因为参数不是一个字符串。如果你希望该字符串封装对象被解封装（JJ-??）为`"42"`，那么数字`42`被首先转换为`"42"`，然后函数返回`42`不是很正常吗？

我认为这样办显式、半隐式的强制类型转换很多时候是非常有用的。例如：

```
    var a = {
        num: 21,
        toString: function() { return String( this.num * 2 ); }
    };

    parseInt( a ); // 42
```

`parseInt(..)`将参数强制类型转换为字符串然后解析之，这本身是合理的。如果你传递垃圾参数而得到垃圾结果，你无法抱怨垃圾箱本身，因为它只是在忠实地履行自己的职责。

因此，如果我们传递`Infinity`（`1/0`的计算结果）这样的值，应该将其强制转换为什么样的字符串最为合理呢？我只能想到两种选择：`"Infinity"`和`"∞"`。而我很高兴JS选择了`"Infinity"`。

我觉得JS中所有的值都有一个对应的字符串表示是一件好事，能够方便我们调试和推导。

现在我们来看看基数19是怎么回事？显然这是杜撰出来的。我们在实际的JS代码中不会用到基数19。这是很荒谬的，但是让我们由它去。对于基数19来说，有效的数字字符是`0-9`和`a-i`（区分大小写）。

让我们回到例子`parseInt(1/0, 19)`。它实际上是执行`parseInt("Infinity", 19)`。那么它如何解析呢？第一个字符是"I"，以19为基数时的值为`18`。第二个字符`"n"`不是有效的数字字符，因而解析到此停止，和遇到`"42px"`中的`"p"`一样。

那么结果是什么呢？结果是`18`，而非错误或者`Infinity`。这个结果很合乎情理，这就是JS的工作机制，很重要，不应该被轻易忽略。

另外一个看起来令人惊讶但也是合乎情理的有关`parseInt(..)`的例子是：

```
    parseInt( 0.000008 );       // 0   ("0" from "0.000008")
    parseInt( 0.0000008 );      // 8   ("8" from "8e-7")
    parseInt( false, 16 );      // 250 ("fa" from "false")
    parseInt( parseInt, 16 );   // 15  ("f" from "function..")
    
    parseInt( "0x10" );         // 16
    parseInt( "103", 2 );       // 2
```

`parseInt(..)`的行为实际上是前后一致并且可预测的。如果你使用方法正确，得到的结果就没问题。如果使用不当则会得到莫名其妙的结果，但这并不能归咎于JavaScript本身。

#####显式：*-->Boolean

现在让我们来看一看从非布尔值强制类型转换为布尔值。

和前面介绍过的`String(..)`和`Number(..)`一样，`Boolean(..)`（没有new关键字）是一种显示的`ToBoolean`强制类型转换：

```
    var a = "0";
    var b = [];
    var c = {};

    var d = "";
    var e = 0;
    var f = null;
    var g;
    
    Boolean( a ); // true
    Boolean( b ); // true
    Boolean( c ); // true
    
    Boolean( d ); // false
    Boolean( e ); // false
    Boolean( f ); // false
    Boolean( g ); // false
```

虽然`Boolean(..)`显而易见是显式的，但是却并不常用。

就象一元运算符`+`将值强制类型转换为数字（见前面的介绍），一元运算符`!`反操作显式地将值强制类型转换为`布尔值`。问题在于它同时还将正值反转为负值，或者反之。所以JS程序员经常使用`!!`操作符将值显式强制类型转换为布尔值，因为第二个`!`会将结果反转为原值：

```
    var a = "0";
    var b = [];
    var c = {};

    var d = "";
    var e = 0;
    var f = null;
    var g;

    !!a; // true
    !!b; // true
    !!c; // true

    !!d; // false
    !!e; // false
    !!f; // false
    !!g; // false
```

在布尔值上下文中，诸如`if(..)..`语句，如果不使用`Boolean(..)`和`!!`，以上的`ToBoolean`强制类型转换都是隐式地进行的。但是我们想要在这里显式地将值强制类型转换为`布尔值`，从而让代码更加清晰。

另一个相关的例子是在JSON序列化的时候将`true/false`强制类型转换为布尔值：

```
    var a = [ 1,
            function(){ /*..*/ },
            2,
            function(){ /*..*/ }
    ];

    JSON.stringify( a ); // "[1,null,2,null]"

    JSON.stringify( a, function(key,val){
        if (typeof val == "function") {
            // force `ToBoolean` coercion of the function
            return !!val;
        }
        else {
            return val;
    } } );
    // "[1,true,2,true]"
```

如果你有Java背景，可能对这样的用法比较熟悉：

```
    var a = 42;

    var b = a ? true : false;
```

`? :`三参数操作符判断条件是否为真，如果为真则将变量b赋值`true`，否则赋值`false`。

表面上这是一个显式的`ToBoolean`强制类型转换，因为结果不是`true`就是`false`。

然而其中包含了隐式强制类型转换，因为表达式首先必须被强制类型转换为`布尔值`以便进行判断。我将其称为“显式的隐式”。我建议你不要这样写JavaScript代码，因为它非但没有任何好处，有时还会造成造成误解。

使用`Boolean(a)`和`!!a`来进行显式强制类型转换则要好得多。

####隐式强制类型转换

隐式强制类型转换指的是那些隐藏的类型转换，其隐式产生的副作用也不是很明显。换句话说，所有对你来说不显而易见的类型转换都是隐式强制类型转换。

显式强制类型转换旨在让代码更加清晰易读，而隐式强制类型转换则恰恰相反，会让代码更加晦涩难懂。

从表面上看，这是强制类型转换最为人诟病的地方。程序员对“JavaScript 强制类型转换”的抱怨大都是针对隐式强制类型转换（无论他们是否意识到这一点）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">《JavaScript: The Good Parts》的作者Douglas Crockford在许多场合和文章当中都主张尽量避免使用JavaScript强制类型转换。看来在他的观点中，隐式强制类型转换是很糟糕的。然而如果你看看他写的代码，会发现许多隐式和显式强制类型转换。事实上他的困扰大都来自于==操作符，但在本章中你会发现，这仅仅是强制类型转换的一小部分。</td>
    </tr>
</table>

隐式强制类型转换真有这么糟糕吗？真的很危险吗？真的是JavaScript的一个设计缺陷吗？我们真的应该彻底避免使用它吗？

我猜想读者们也许会急迫地回答“是的！”。

其实不然，请听我细细道来。

让我们从另一个角度来看看隐式强制类型转换是怎么回事，能够如何使用，而非仅仅将其当作“显式强制类型转换的对立面”，因为这样理解太狭隘，忽略了它们之间一个重要的差别。

我们认为隐式强制类型转换的作用是减少代码冗余，让代码更加清晰易读。

#####简单化隐式

首先让我们来看看下面这个使用某种强类型语言的伪代码的例子：

```
    SomeType x = SomeType( AnotherType( y ) )
```

在上例中，变量`y`中是某个类型的值，我们要将其转换为类型`SomeType`。问题是该语言无法直接将`y`转换为类型`SomeType`。它需要一个中间步骤，首先将其转换为类型`AnotherType`，然后再从`AnotherType`转换为`SomeType`。

如果语言（或者你使用该语言进行自定义）允许你这样写：

```
    SomeType x = SomeType( y )
```

你不觉得这样做简化了中间步骤，让类型转换代码更简洁了吗？因为在这段代码中，变量y在转换为类型SomeType之前先转换为类型AnotherType这一步骤并不重要，所以可以被简化。

有人也许会说，没错，在某些情况下是这样的。但是我想对于很多其他情况来说，通过语言本身或者自定义的特性来剔除和隐藏一些不必要的细节，对于提高代码可读性来说是很有必要的。

毋庸置疑，这些中间步骤仍然会在幕后执行。但是如果这些细节在代码中被隐藏后，我们就可以只关注变量`y`转换到类型`SomeType`本身，而忽略其他不重要的细节。

虽然JS的隐式强制类型转换与此并非完全是一码事，在本章中的其余部分，我会坚持我的观点，即隐式强制类型转换同样能够让你的代码更加简洁。

但是这也不是绝对的有益无害，隐式强制类型转换绝对也会带来一些负面的影响，有时甚至更甚于它带来的好处。因此我们更应该学习如何避免这些负面的东西。

许多程序员认为如果某个机制能够带来好处*A*但是同时又会带来坏处*Z*，那么为了安全起见就必须彻底地将其弃用。

我的建议是不要有这样的想法。不要“因噎废食”。不要因为你觉得你看到的都是负面影响而想当然地认为隐式强制类型转换都是不好的。我认为其也有好的方面，我愿意帮助你们去发现并使用它们。

#####隐式：Strings <--> Numbers

在本章前面的部分，我们介绍了`字符串`和`数字`之间的显示强制类型转换。现在让我们来看看它们之间的隐式强制类型转换。首先让我们来看看一些导致隐式强制类型转换的操作的细节。

操作符`+`被重载以便同时支持`数字`的加法和`字符串`的拼接。那么JS如何知道我们要执行哪种操作呢？例如：

```
    var a = "42";
    var b = "0";

    var c = 42;
    var d = 0;
    
    a + b; // "420"
    c + d; // 42
```

是什么不同导致了`"420"`和`42`这两个不同的结果？常见的误解是因为某个或者两个操作数为`字符串`，因而`+`进行的是`字符串`拼接。这样的理解部分正确，实际情况比这个复杂得多。

例如：

```
    var a = [1,2];
    var b = [3,4];

    a + b; // "1,23,4"
```

两个操作数都不是`字符串`，但是它们均被强制转换为`字符串`然后进行拼接。这到底是怎么回事呢？

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">下面两个段落是规范中有关该问题的详细解释，如果你觉得太难理解可以跳过。</td>
    </tr>
</table>

根据ES5规范，第11.6.1节，如果运算符是`字符串`，或者其能够根据下面步骤产生`字符串`表示的话，`+`运算（操作数为某个`对象`值）将进行拼接操作。因此当`+`的其中一个操作数为`对象`（包括`数组`）的话，它首先对操作数的值调用`ToPrimitive`抽象操作（第9.1节），该抽象操作接着调用`[[DefaultValue]]`算法（第8.12.8节），上下文提示为`数字`(JJ-??)。

如果你多加留意，会发现该操作和`ToNumber`抽象操作处理`对象`的方式一样（`见第65页“ToNumber”`）。因为`数组`的`valueOf()`操作无法产生简单基本类型，所以它将转而调用`toString()`产生`字符串`表示。因此上例中的两个数组变成了`"1,2"`和`"3,4"`。`+`将这两个`字符串`拼接起来产生你要的结果：`"1,23,4"`。

让我们暂时撇开这些繁琐的细节，回到之前那个简单的描述：如果`+`操作数其中一个是`字符串`（或者通过以上步骤可以产生），则执行`字符串`拼接操作。否则执行`数字`加法。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">强制类型转换一个比较常被提及的gotcha(JJ-??)是[] + {}和{} + []，它们产生的结果不同，分别是"[object Object]"和0。我们将在第134页的“块”一节详细介绍。</td>
    </tr>
</table>

这对于隐式强制类型转换意味着什么呢？

意味着你可以通过将`数字`和空字符串`""`相加来将其强制类型转换为字符串：

```
    var a = 42;
    var b = a + "";
    
    b; // "42"
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">数字加法操作符+是可以双向互换的，即2 + 3和3 + 2一样。使用+的字符串拼接操作显示不是这样，但是对于空字符串""而言，a + ""和"" + a结果是一样的。</td>
    </tr>
</table>

使用`a + ""`这样的方式隐式强制转换数字为字符串是非常常见的。有意思的事，许多诟病隐式强制类型转换的人也仍然这样写代码，而不是使用显示强制类型转换。

我想这是一个很好的例子，无论隐式强制类型转换如何被诟病，它仍然有适用的地方。

我们比较一下`a + ""`和之前介绍过的`String(a)`，两者之间有一个细微的区别需要注意。`a + ""`中，`ToPrimitive`抽象操作会对`a`调用`valueOf()`，返回值则通过`ToString`抽象操作转换为`字符串`。而`String(a)`则是直接调用`ToString()`。

两者最终都返回一个`字符串`，但是如果你使用的是`对象`而非`数字`基本类型，可能得到的结果会不一样！

例如：

```
    var a = {
        valueOf: function() { return 42; },
        toString: function() { return 4; }
    };
    
    a + ""; // "42"
    
    String( a );    // "4"
```

通常来说，如果你的代码中没有这些令人费解的数据结构和操作的话，是不会有机会碰到这个问题的，但是如果你对某些对象使用了自定义的`valueOf()`和`toString()`方法，就需要特别小心，因为这会影响到强制类型转换的结果。

那么反过来从`字符串`强制类型转换为`数字`又如何呢？

```
    var a = "3.14";
    var b = a - 0;
    
    b; // 3.14
```

操作符`-`只能用于数字减法，因此`a - 0`会将`a`强制类型转换为`数字`。更为少见的，`a * 1`和`a / 1`也能得到相同的结果，因为这两个操作符也只能用于数字。

那么针对`对象`执行`-`操作又如何？和前面的`+`类似：

```
    var a = [3];
    var b = [1];
    
    a - b; // 2
```

上面两个数组都必须被转换为`数字`，但它们首先被强制类型转换为`字符串`（使用`toString()`），然后被强制类型转换为`数字`，以便`-`减法操作符能够执行。

所以，隐式强制类型转换真如你耳闻那样的糟糕吗？我个人持不同意见。

让我们比较一下`b = String(a)`（显式）和`b = a + ""`（隐式）。我想两种方式都有用。`b = a + ""`更为常见，无论隐式强制类型转换如何备受争议，仍然有它的用武之地。

#####隐式：Booleans-->Numbers

我认为在某一种情况下，隐式强制类型转换会非常有帮助，就是将一些复杂的布尔逻辑转换为数字加法的时候。当然，这种方式并不常见，但是特殊情况需要特殊处理。

例如：

```
    function onlyOne(a,b,c) {
        return !!((a && !b && !c) ||
            (!a && b && !c) || (!a && !b && c));
    }
    
    var a = true;
    var b = false;
    
    onlyOne( a, b, b ); // true
    onlyOne( b, a, b ); // true
    
    onlyOne( a, b, a ); // false
```

如果只有一个参数为`true`（或者可以为真truthy(JJ--??)），函数`onlyOne(..)`应该返回`true`。它在做为真truthy测试时使用了隐式强制类型转换，其他地方使用的则是显式强制类型转换，包括最后的返回值。

如果我们想让这个函数用相同方式处理四个，五个，或者二十个参数呢？很难想象使用上面的代码来进行繁杂的比较操作。

这里我们则可以使用从`布尔值`到`数字（0或者1）`的强制类型转换：

```
    function onlyOne() {
        var sum = 0;
        for (var i=0; i < arguments.length; i++) {
            // skip falsy values. same as treating
            // them as 0's, but avoids NaN's.
            if (arguments[i]) {
        sum += arguments[i];
    }
    }
        return sum == 1;
    }
   
    var a = true;
    var b = false;
   
    onlyOne( b, a );                // true
    onlyOne( b, a, b, b, b );       // true
   
    onlyOne( b, b );                // false
    onlyOne( b, a, b, b, b, a );    // false
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">当然除了在onlyOne(..)使用loop循环，你也可以简单明了地使用ES5种的reduce(..)函数，上例只是为了说明问题。</td>
    </tr>
</table>

在这里我们通过累加真值（true/truthy）强制类型转换的结果`1`。`sum += arguments[i]`执行过程中使用了隐式强制类型转换。如果只有一个参数为`true`，数字累加结果为`1`，否则结果不为`1`，因此条件不成立。

我们也可以使用显式强制类型转换来实现：

```
    function onlyOne() {
        var sum = 0;
        for (var i=0; i < arguments.length; i++) {
            sum += Number( !!arguments[i] );
        }
        return sum === 1;
    }
```

首先我们用`!!arguments[i]`将值强制类型转换为`true`或`false`。因此你可以传递非布尔值，如：`onlyOne("42, 0)`，这样仍然有效（否则会返回拼接后的`字符串`，这样逻辑就不对了）。

一旦确定这是一个`布尔值`，我们使用`Number(..)`进行另一个显式强制类型转换以确保返回值为`0`或者`1`。

是不是在这里显示强制类型转换要更好些？如代码注释所说，它的确避免了`NaN`带来的问题。但是这一切最终取决于你自身的需要。我个人认为前者，即隐式强制类型转换，更为简洁（前提是你不会传递`undefined`和`NaN`这样的值），而显式强制类型转换有一些不必要的繁杂。

总之如同本书讨论的所有内容一样，一切都取决你自身的判断。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">无论是隐式还是显式强制类型转换，你都能够很容易地修改onlyTwo(..)或者仅仅是Five(..)来处理更多的情况，只需要将最后的比较值从1分别改为2或者5。这比加入一大堆&amp;&amp;和||表达式要简洁的多。所以强制类型转换在这里是很有用的。</td>
    </tr>
</table>

#####隐式:**-->Boolean

现在让我们来看看到`布尔值`的隐式强制类型转换，到目前为止，这类情况最为常见，也最容易出错。

请记住，这类转换涉及的是隐式强制类型转换。对于`数字`和`字符串`操作来说，强制类型转换的过程很清楚。

那么，到布尔值的隐式强制类型转换涉及哪些表达式和操作呢？

- `if (..)`语句中条件判断表达式
- `for ( .. ; .. ; .. )`语句中的条件判断表达式（第二个）
- `while (..)`和`do..while(..)`循环中的条件判断表达式
- `? :`中的条件判断表达式
- 逻辑操作符`||`（逻辑或）和`&&`（逻辑与）左边的操作数（作为条件判断表达式）。

以上情况下的值，如果本身不是`布尔值`的话，会被隐式强制类型转换为`布尔值`，遵循本章之前介绍过的`ToBoolean`抽象操作的规则。

例如：

```
    var a = 42;
    var b = "abc";
    var c;
    var d = null;
    
    if (a) {
        console.log( "yep" );   // yep
    }

    while (c) {
        console.log( "nope, never runs" );
    }

    c = d ? a : b; 
    c;                          // "abc"
    
    if ((a && d) || c) {
        console.log( "yep" );   // yep
    }
```

在以各种情况下，非布尔值会被隐式强制类型转换为布尔值，以便进行条件判断。

#####||和&&操作符

你很有可能已经在其他语言中见到过`||`（逻辑或）和`&&`（逻辑与）操作符。所以应该很自然地认为它们在JavaScript中的功能也和他语言一样。

然而有一个细微的差别不太为人所知，但是却十分重要。

实际上我不太赞成将它们称为“逻辑操作符”，因为这个叫法并不能完全体现它们的功能。如果可以用一个更精确（也更冗长）的词的话，我会使用“选择器操作符”，或者“操作数选择器操作符”。

原因是在JavaScript中，它们返回的结果值并非是`布尔值`，这与其他语言不同。

那么它们返回什么样的结果值呢？它们返回其两个操作数中的一个（且仅一个）的值。换句话说，它们选择操作数中的某一个，然后返回其值。

这里我们引述ES5规范中的第11.11节：

*&&和||操作符的返回值并不一定是布尔值。它们的返回值总是两个操作数其中的一个的值*

让我们举个例子：

```
    var a = 42;
    var b = "abc";
    var c = null;

    a || b;     // 42 
    a && b;     // "abc"
    
    c || b;     // "abc" 
    c && b;     // null
```

等等，什么？仔细想一下。在C和PHP这样的语言中，这些表达式返回`true`或者`false`，然而JS（以及Python和Ruby）则返回操作数的值。

`||`和`&&`操作符首先会对第一个操作数（`a`和`c`）进行布尔值条件判断。如果该操作数不是布尔值（如本例）则执行`ToBoolean`强制类型转换，以便执行条件判断。

对于`||`操作数，如果条件判断结果为`true`，`||`表达式返回第一个操作数（`a`和`c`）的值。如果条件判断结果为`false`则返回第二个操作数（`b`）的值。

相反地，对于`&&`操作数，如果条件判断结果为`true`，`&&`表达式返回第二个操作数（`b`）的值。如果条件判断结果为`false`则返回第一个操作数（`a`和`c`）的值。

`||`和`&&`操作符的返回值总是其某一个操作数的值，而非条件判断的结果值（也许涉及强制类型转换）。如`c && b`, `c`为`null`，因而是个假值。然而`&&`表达式返回的结果值为`null`（`c`的值），而非其在条件判断中经过强制类型转换后的`false`。

现在你理解为什么这些操作符被称为“操作数选择器”了吧？

从另一个角度来理解：

```
    a || b;
    // roughly equivalent to:
    a ? a : b;

    a && b;
    // roughly equivalent to:
    a ? b : a;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">之所以说a || b大致等价于a ? a : b，是因为它们的返回值相同，但是它们之间仍然有一个细微的差别。在a ? a : b中，如果a是一个更为复杂的表达式（比如一个有返回值的函数调用等等），则a表达式有可能被执行两次（如果第一次结果为真）。相反，对于a || b，表达式只会执行一次，其结果值会被用于条件判断以及返回值（如果适用）。这个差别也存在于a &amp;&amp; b和a ? b : a中。</td>
    </tr>
</table>