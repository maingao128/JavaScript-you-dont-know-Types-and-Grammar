#你不知道的JavaScript － 类型和语法

##序

曾有人说：“JavaScript是唯一一门程序员先用后学的语言。”

每次听到这句话我都会付诸一笑，因为它对于我就是如此，不知道对其他程序员是否也一样。JavaScript，也许还有CSS和HTML，在互联网早期的大学计算机课程中并非主流的教学语言。新手程序员大多通过搜索和“查看源代码”的方式来自学这些Web的基础语言。

我仍然记得我高中时代的第一个网站项目。当时的任务是搭建一个网上商店，无论什么样的都行，因为我是詹姆斯∙邦德的粉丝，所以我决定搭建一个“黄金眼”商店。它包罗万象：背景音乐是“黄金眼”主题曲，有一个用JavaScript开发的瞄准器跟随鼠标移动，每次点击鼠标的时候会发出一声枪响。Q(JJ-??)实在应该为这个网站杰作感到骄傲。

我之所以讲到这个故事，是因为我当时使用的开发方式直到现在仍然有许多程序员在使用。我在项目中“拷贝－粘贴”了很多JavaScript代码，但根本没有理解它们是干什么的。现在流行的jQuery这样的JavaScript工具集，也在以它们各自的方式潜移默化地进一步鼓励了不深入学习JavaScript的方式。

我并不反对使用JavaScript工具集，事实上我还是MooTools JavaScript团队的成员之一。这些工具集功能如此强大的原因，恰恰是它们的开发者们从根本上了解它们，并且将其运用到了极致。了解这门语言的基本知识对我们来说仍然是非常重要的，这与掌握那些工具集一样会对我们非常有帮助。象Kyle Simpson的《你不知道的JS》系列这样的书，我们实在没有理由不学习。

《类型和语法》是该系列的第三本，它介绍了JavaScript核心基础知识，这些知识你永远不可能从“拷贝－粘贴”和JavaScript工具集中学到。前置（coercion）及其隐患、原生构造方法(JJ-??)、以及JavaScript的全部基础知识都在本书中做了详细的介绍，并配合以示例代码。同本系列的其他作品一样，Kyle的行文直中要点，没有多余的套话和修辞(JJ-??)，是我喜欢的技术书风格。

希望你们喜欢《类型和语法》这本书，并能够常读常新。

-David Walsh[http://davidwalsh.name](http://davidwalsh.name)
Senior Web Developer at Mozilla

------

##前言

我想你已经注意到了本书中的“JS”一词，但是它并非是用来咒骂JavaScript的简语，虽然咒骂一门语言是我们作为程序员的标志。

从互联网最早期开始，JavaScript就一直是实现内容交互体验的基本技术。虽然刚开始是用来实现鼠标移动轨迹闪烁效果，还有令人讨厌的弹出消息框。大约20年之后，JavaScript技术和功能得到了数量级的提高，没有人再怀疑它在互联网，这个世界上使用最广泛的软件系统，中的重要性和核心地位。

但是作为一门语言，它一直为人诟病，包括其历史沿革，更多是它的设计理念。它的命名，相对于其更成熟的哥哥Java，也被Brendan Eich称为“傻弟弟”。其实它的命名仅仅是政治和市场考量下的一个偶然。两个语言之间千差万别，“JavaScript”和“Java”之间如同“Carnival”（嘉年华）和“Car”之间一样毫无关联。

JavaScript在概念上和语法习惯上借鉴了许多语言，包括壮观的C风格的程序根，和相对隐晦的Scheme/Lisp风格的函数根，它能为更多的开发人员接受，包括没有编程经验的人。用JavaScript编写“Hello World”非常简单，让人很容易上手。

JavaScript或许是最容易上手和使用的语言之一，但是它的一些古怪的行为使得它不像其他语言那样容易完全掌握。使用C或者C++开发一个完整的程序需要对该语言有一个相当深入的了解。然而对于JavaScript来说，就算你使用它开发了一个完整的系统，也不见得对这门语言有什么深入理解。

这门语言中那些隐藏得很深的复杂概念，往往以一种看似简单的方式呈现，例如：将函数作为回调参数传递，使得JavaScript程序员乐于使用现成的语言机制，而不愿意去了解其中的原因。

JavaScript是一门简单易用的语言，应用广泛，同时又有着复杂和声名狼藉的语言机制，如果不用心掌握，即使经验丰富的JavaScript程序员也会对其出现理解上的偏差。

JavaScript的悖论就在于此，它的阿基里斯之踵正是我们要在本书解决的问题。因为你不需要理解就能够使用它，所以常常最终也不会去理解它。

###使命

在使用JavaScript时，每当遇到令人讶异或者抓狂的情况，你的反应如果是置之不理（这是人之常情），你很快会发现自己无法发挥这门语言的任何优势(JJ-??)。

这部分经常被称为“好的部分（The Good Parts）”，但我恳请读者朋友们不如把它视作“容易的部分”，“安全的部分”，甚至于“不完整的部分”。

《你不知道的JS》系列涉及的是另一个部分，即深入掌握JavaScript的所有知识，特别是那些重点难点。

我们让本书的内容对于JS程序员来说易于理解，而不强迫他们深入到原理。此外，在碰到疑难问题的时候我们不会避而不谈。

我不会满足于只是让代码运行而不明就里，，你也不应该仅仅满足于此。我会逐步用一些难点来挑战你，最终让你全面掌握JavaScript的威力。一旦掌握了这些知识，你将无法想象不需要技巧，框架，术语会是多么美妙的事情(JJ-??)。

本系列中的每本书全面深入地探讨了JavaScript中那些被误解，或者被低估的关键知识点。读完之后，从理论和实践上，对那些必须掌握的知识你都会有一个充分和自信的理解。

目前你对JavaScript的认识可能都来自于那些对JavaScript一知半解的人。JavaScript是一门语言，同时也是这门语言的一道影子。如果你还不真正了解它的话，读完本系列你会了解。让我们尽情地开始阅读吧。

###回顾

JavaScript是一门优秀的语言。它的各个部分学习起来都不难，但是要完全整体掌握则很难。当程序员遇到困惑时往往归咎于语言本身，而不是他们自身对语言的缺乏理解。本系列丛书旨在解决这个问题，让你能够发自内心地喜欢上这门语言。

![](images/JJ-??)
本书中的许多示例需要ES6这样新的JavaScript引擎。一些代码可能无法在老的引擎（ES6之前）上运行。

###书写约定

本书使用以下书写约定：

*斜体字*
表示新术语，URL，电子邮件，文件名，和文件扩展名。

等宽字
用于显示程序代码，和在段落中显示程序代码中的内容，如：变量名和函数名，数据库，数据类型，环境变量，声明语句，和关键词。

####粗体等宽字
需要用户输入的命令和其他文本。

*斜体等宽字*
需要用户提供替换值的文本，或者根据上下文计算的值。

![](images/JJ-??)
提示和建议

![](images/JJ-??)
注解

![](images/JJ-??)
警告和提醒

###示例代码

本书的附带资料（如：示例代码，练习等）在[http://bit.ly/ydkjs-types-code](http://bit.ly/ydkjs-types-code)可以下载。

本书旨在帮助你解决实际问题。你可以在你的程序和文档中使用本书提供的示例代码。除非你使用了相当数量的示例代码，否则你不需要经过我们的许可。例如，你不必征得我们的同意既可在你的程序中使用几段本书的示例代码。如果你将O'Reilly出版的图书中的示例代码制作为光盘出售，则需要经过我们的许可。如果你在回答别人的问题时需要引用本书的内容和示例代码，你不需要征得我们许可。如果你的产品文档中引用了大量本书的示例代码，则需要征得我们许可。

如果你能够在使用到本书的地方注明出处，我们会非常感谢，不过这并不是强制的。注明出处通常包括书名，作者，出版方，和ISBN。例如：《你不知道的JS》，Kyle Simpson著，O'Reilly出版。Copyright 2015 Getify Solutions, Inc.,978-1-491-90419-0。

如果你觉得你的情况不属于上述两种情况，请通过[permis‐ sions@oreilly.com](permis‐ sions@oreilly.com)和我们联系。

###Safari Books Online

![](images/JJ-??)
[Safari Books Online](http://safaribooksonline.com)是及时点播式数字图书馆，为您提供来自世界顶尖科技和商业作者的专业书籍和视频[内容](https://www.safaribooksonline.com/explore)。

科技工作者、软件开发人员、Web设计师和商业创新从业者都将Safari Books Online作为他们研究、攻关、学习和认证培训的一个主要资源。

Safari Books Onine为企业、政府、教育和个人提供不同的计划和收费。

Safari Books Online会员能够访问上千本图书，教学视频，和来自[上百家出版方](https://www.safaribooksonline.com/our-library)，如：O'Reilly Media，Prentice Hall Professional, Addison- Wesley Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders, McGraw-Hill, Jones & Bartlett, Course Tech‐ nology，并且可以在数据库中检索的正式出版前的稿件。有关Safari Books Online更多的信息请访问我们的网站。

------

###联系我们

关本书的想法和问题，您可以通过以下方式和我们联系：

O’Reilly Media, Inc.
1005 Gravenstein Highway North
Sebastopol, CA 95472
800-998-9938 (in the United States or Canada) 707-829-0515 (international or local) 707-829-0104 (fax)

我们为本书建设了一个网页，上面有勘误，示例，和其他信息。可以通过[http://bit.ly/ydkjs_types-and-grammar](http://bit.ly/ydkjs_types-and-grammar.)这个链接访问。

有关本书的评论和技术问题，可以发送邮件到[bookquestions@oreilly.com](bookquestions@oreilly.com)。

有关其他图书的信息，课程，论坛，和新闻，请访问我们的网站[http://www.oreilly.com](http://www.oreilly.com)。

我们的Facebook页面：[http://facebook.com/oreilly](http://facebook.com/oreilly)

关注我们的Twitter：[http://twitter.com/oreillymedia](http://twitter.com/oreillymedia)

我们的Youtube频道：[http://www.youtube.com/oreillymedia](http://www.youtube.com/oreillymedia)

------

##第一章 类型

很多开发人员认为动态语言（如：JavaScript）是没有类型的。让我们看看ES5.1规范（[http:// www.ecma-international.org/ecma-262/5.1/](http:// www.ecma-international.org/ecma-262/5.1/)）对此怎样解释：

```
本规范中的算法所操纵的值均有一个相对应的类型。本条款中定义了所有可能的值类型。类型是对ECMAScript语言类型和规范类型的进一步细分。
ECMAScript语言类型对应ECMAScript程序员使用该语言直接操纵的值。ECMAScript语言中的类型有：Undefined，Null，Boolean，String，Number，和Object。
```

如果你喜欢强类型（又称为静态类型）语言，你也许不同意使用“类型”一词。在强类型语言中，“类型”一词的含义比在JavaScript中广得多。

有人认为JavaScript中的“类型”应该叫“标签”或者“子类型”更合适。

我们在本书中对类型做如下粗略定义（和规范中一样）：*类型*是值的内部属性集合，它定义了该值的行为特征，使其能够区别于其他值。对于语言解析引擎和开发人员来说都是如此。

换句话说，如果语言解析引擎和开发人员对数字42和字符串"42"区别对待，则说明它们具有不同的类型，一个是数字，一个是字符串。我们通常会对数字42做数学运算。而对字符串"42"做一些其他操作，如将其显示到网页等等。所以它们的类型是不同的。

这样的定义并非十全十美，不过对于本书而言已经足够，而且它也与JavaScript语言对自身的描述一致。

###类型的另一面

抛开学术定义上的分歧不谈，JavaScript中有无类型为什么这么重要？

要合理准确地对值进行类型转换（见`第四章`），我们必须正确理解各个类型及其内部行为特征。几乎所有的JavaScript程序都涉及到各种形式的类型强制，因此你需要在处理这些情况时有充分的把握和信心。

如果你要将数字42当作字符串来处理，比如获得其第二个字符"2"，你就需要先将其从数字转换（强制）为字符串。

道理很明显。

但是强制类型转换的方式可以有很多种。有一些是显示的，比较容易，也比较可靠。但是如果你不小心，强制类型转换可能会产生意想不到的结果。

强制类型转换带来的困扰是JavaScript程序员最头疼的事情之一。它经常被诟病太危险，以至于被认为是语言设计上的缺陷，需要尽量回避。

在全面理解JavaScript中的类型的前提下，我们旨在阐述为什么强制类型转换的坏名声被过分夸大了，甚至一定程度上是错误的，这也许能够彻底转变你对它的看法，让你认识到它的强大和实用之处。不过首先我们需要对值和类型有一个更好的理解。

###内置类型

JavaScript中有7种内置类型：

- null
- undefined
- boolean
- number
- string
- object
- symbol（ES6中新增）

除object之外，其他统称为基本类型。

typeof操作符检测值的类型，返回类型的字符串值。令人惊讶的是，以上7种类型和类型的字符串值并不一一对应：

```
    typeof undefined    === "undefined";    // true
    typeof true         === "boolean";      // true
    typeof 42           === "number";       // true
    typeof "42"         === "string";       // true
    typeof { life: 42 } === "object";       // true
    // added in ES6!
    typeof Symbol()     === "symbol";       // true
```

以上6个类型均有与其对应的字符串值，与类型名称相同。`Symbol`是ES6中新增的类型，我们将在`第三章`中介绍。

你可能注意到，null类型不在此列。它有些特殊，typeof运算符针对它的返回结果有bug：

```
    typeof null === "object"; // true
```

正确的返回结果应该是"null"，但是这是一个JavaScrtip固有的bug，已经存在近20年了，也可能永远不会被修复，因为太多的Web系统在“使用”这一bug，修复它将会产生更多的bug，导致大量的Web系统无法工作。

如果你想检测一个null值的类型，需要使用复合条件：

```
    var a = null;
    (!a && typeof a === "object"); // true
```

null是唯一一个“falsy”的基本类型（也称作false-like，见`第四章`），typeof对其仍然返回"object"。

那么typeof的第7个返回字符串值是什么呢？

```
    typeof function a(){ /* .. */ } === "function"; // true
```

上面的typeof的返回值容易让我们得出一个结论，就是`函数（function）`也是JavaScript的一个内置类型。然而如果你查阅规范就会知道，它实际上是`object`的一个子类型（subtype）。具体来说，函数被称为可调用对象（callable object），即该对象内部有一个[[Call]]属性，使其能够被执行。

函数是对象对我们很有用，更为重要的是，函数还可以拥有属性。例如：

```
    function a(b,c) {
        /* .. */
    }
```

函数对象的`length`属性设置为它的正式参数的数目：

```
    a.length; // 2
```

因为你为该函数定义了两个正式命名参数（b和c），所以函数的长度为2。

那么数组呢？JavaScript本身支持数组，那它是不是也是一个特殊类型？

```
    typeof [1,2,3] === "object"; // true
```

答案是no，数组也是object。确切地说，是object的一个子类型（见`第三章`），它另外一个特征是按照数字顺序进行索引（而非普通对象那样是字符串键值），并且它的`.length`属性会自动更新。

###值作为类型

JavaScript中变量没有类型，值才有。变量在任何时候都可以持有任何类型的值。

理解JavaScript类型的另一种方式是，JavaScript没有“强制类型检测”，就是语言解析引擎不要求一个变量总是持有与其初始值同样类型的值。变量可以一会持有字符串类型的值，一会持有数字类型的值，诸如此类。

值42的内部类型为number，它的类型无法更改。另一个值，如"42"，类型为字符串，能够通过强制类型转换的方式从数字42转换而来(coercion，见`第四章``)。

我们对变量使用typeof时，得到的并非是该变量的类型，因为JavaScript变量没有类型。我们得到的是变量持有的值的类型。

```
    var a = 42;
    typeof a; // "number"

    a = true;
    typeof a; // "boolean"
```

typeof操作符总是返回一个字符串：

```
    typeof typeof 42; // "string"
```

typeof 42首先返回"number"，然后typeof "number"返回"string"。

###undefined和undeclared

变量在没有持有任何值时其值为undefined。此时typeof返回"undefined"：

```
    var a;

    typeof a; // "undefined"

    var b = 42;
    var c;

    // later 
    b = c;

    typeof b; // "undefined"
    typeof c; // "undefined"
```

很多开发人员容易将“undefined”当作“undeclared”的同义词。然而在JavaScript中，它们之间有很大区别。

值为“undefined”的变量是那些已经在访问空间中声明过，但是当前并没有持有任何值的变量。相反，值为“undeclared”的变量是那些还没有在访问空间中声明过的变量。

例如：

```
    var a;

    a; // undefined
    b; // ReferenceError: b is not defined
```

浏览器在处理这类情况的时候显示的错误信息很容易误导人。如你所见，“b is not defined”这样的信息比较容易让人理解为“b is undefined”。再次说明，“undefined”和“is not defined”非常不同。如果浏览器显示诸如“b is not found”或者“b is not declared”这样的错误信息，就能避免不必要的误解。

typeof在处理undeclared变量时有一个特殊的行为更加深了我们的困惑。例如：

```
    var a;

    typeof a; // "undefined"

    typeof b; // "undefined"
```

typeof对于“undeclared”（或者“not defined”）的变量也返回"undefined"。请注意在执行typeof b时没有产生任何错误，即使b是一个undeclared变量。这是typeof中的一个特殊的安全防范。

同上所述，如果typeof对undeclared变量返回“undeclared”而非合用“undefined”，情况会好很多。

###typeof Undeclared

不管怎么说，这样的安全防范对于在浏览器中运行的JavaScript来说是很有帮助的，因为多个script文件可以将变量加载到共享的全局命名空间中。

很多开发人员觉得全局命名空间中不应该有任何变量，所有的东西应该被封装到模块和私有命名空间中。理论上说这样不错，虽然在实际操作中基本不可能实现，但仍不失为一个值得努力的目标。幸运的是在ES6中加入了对模块的优先支持，最终将会让其更具可操作性。

我们举个简单的例子，在你的程序中通过一个全局变量DEBUG来作为“调试模式”的开关。在执行诸如将信息写入控制台这样的调试任务前，你会检查DEBUG变量是否已经被声明过。这时最顶层的全局变量声明var DEBUG = true只包含在“debug.js”文件中，该文件只有在开发和测试时才在浏览器中加载，在生产环境中则不加载。

然而，你需要在程序的其他地方特别注意检查DEBUG变量的方式，以免出现ReferenceError错误。这时安全防范就很有用：

```
    // oops, this would throw an error!
    if (DEBUG) {
        console.log( "Debugging is starting" );
    }
    // this is a safe existence check
    if (typeof DEBUG !== "undefined") {
        console.log( "Debugging is starting" );
    }

```

即使对非用户定义的变量来说，这样的检查也是很有用的。如果你在为一个内置的API做特性检查，这也可以帮助你避免出现错误：

```
    if (typeof atob === "undefined") {
        atob = function() { /*..*/ };
    }
```

如果你在为某个之前没有的特性定义一个“polyfill”，你可能会避免使用var来声明atob。如果你在if语句中使用var atob声明变量，该声明会被提升（参见本系列的Scope & Closures一书）到范围中的最顶层，即使if条件未通过（因为atob全局变量已经存在）。在一些浏览器中和对于一些特殊的内置全局变量（通常被称为host objects），这样的重复声明会产生错误。而去掉var可以防止声明被提升。

另一种对全局变量做检查但是不使用typeof安全防范的方法，是检查所有全局变量是否也是全局对象的属性，在浏览器中全局变量是window。所以上述检查可以写成这样：

```
    if (window.DEBUG) {
        // ..
    }
    
    if (!window.atob) {
        // ..
    }
```

和访问undeclared变量不同，当试图访问的对象属性不存在时，并不会产生ReferenceError错误。

另一方面，许多程序员避免通过window来访问全局变量，特别是当你的代码在多个JS环境下运行（不仅仅在浏览器，还在服务器端node.js，诸如此类），此时全局变量并不一定是window。

从技术角度而言，即便不是全局变量，使用typeof来做安全防范仍然是有用的，虽然这种情况不太常见，所以一些开发人员不太倾向使用这种方式。设想如果你想让别人拷贝粘贴一个工具函数到他们的程序中，你需要在函数中检查一些变量是否已经在它拷贝到的程序中被使用：

```
    function doSomethingCool() {
        var helper =
            (typeof FeatureXYZ !== "undefined") ?
            FeatureXYZ :
            function() { /*.. default feature ..*/ };
        var val = helper();
        // .. 
    }
```

doSomethingCool()检查变量FeatureXYZ，如果已存在就使用它，否则使用自己定义的版本。如果有人将这段代码引入到他们自己的模块和程序中，它会安全地检查FeatureXYZ是否已经被定义过：

```
    // an IIFE (see the "Immediately Invoked Function Expressions"
    // discussion in the Scope & Closures title in this series)
    (function(){
        function FeatureXYZ() { /*.. my XYZ feature ..*/ }

        // include `doSomethingCool(..)`
        function doSomethingCool() {
            var helper =
                (typeof FeatureXYZ !== "undefined") ?
                FeatureXYZ :
                function() { /*.. default feature ..*/ };
            var val = helper();
    // .. }
        doSomethingCool();
    })();
```

在这里FeatureXYZ不是一个全局变量，但是我们还是使用typeof安全防范。重要的是我们没有使用对象（如前面提到的windows.___）来做检查，因而typeof非常有用。

有些程序员可能倾向使用“依赖注入”（dependency injection）的方式，不是使用doSomethingCool()来检查FeatureXYZ是否已经在别处定义过，而是需要将依赖关系通过参数显示地传递进来，如：

```
    function doSomethingCool(FeatureXYZ) {
        var helper = FeatureXYZ ||
            function() { /*.. default feature ..*/ };
        var val = helper();
        // ..
    }
```

实现类似功能的方式有很多。它们之间没有“错”与“对”之分，每种方法都各有利弊。总而言之，使用typeof来检查undeclared变量为我们提供了更多的选择。

###回顾

JavaScript有7种内置类型：null，undefined，boolean，number，string，object，和symbol。可以使用typeof操作符来查看。

变量没有类型，但是它们持有的值有类型。类型定义了值的内在行为特征。

很多开发人员认为“undefined“和“undeclared”基本上是一样的，但是在JavaScript中，它们区别很大。`undefined`是变量可以持有的值的一种。“Undeclared”表示变量还没有被声明过。

不幸的是JavaScript将二者合并起来使用，不仅在相关的错误信息中如此（“ReferenceError:a is not defined”），typeof的返回值"undefined"也涵盖了这两种情况。

然而，使用typeof做安全防范对于检查undeclared的变量来说是非常有用的。

------

