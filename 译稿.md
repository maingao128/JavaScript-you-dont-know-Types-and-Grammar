#你不知道的JavaScript － 类型和语法

##序

有人说JavaScript是唯一一门先用后学的编程语言。

每次听到这话我都会心一笑，因为我自己就是这样，我想很多开发人员也是如此。JavaScript，也许还有CSS和HTML，在互联网早期的大学计算机课程中并不是主流教学语言。初学者大多通过搜索引擎和“查看源代码”的方式来自学。
©
我仍然记得自己高中时代做的第一个网站。那是搭建一个网上商店，因为是007的粉丝，所以我决定做一个“黄金眼”商店。它包罗万象，背景音乐是“黄金眼”主题曲，有一个用JavaScript做的瞄准器随着鼠标移动，每次点击鼠标时会发出一声枪响。想必Q（007中的一个角色）也应该会为这个杰作感到骄傲吧。

之所以讲到这个故事，是因为我当时使用的开发方式直到现在仍然有许多开发人员在使用，那就是“拷贝＋粘贴”。在项目中我“拷贝＋粘贴”了大量JavaScript代码，但根本没有真正理解它们。那些十分普及的JavaScript工具库，如：jQuery，也在潜移默化地影响着我们，使得我们不用再去深入了解JavaScript的本质。

我并不反对使用JavaScript工具库，实际上我还是MooTools JavaScript团队的成员之一。这些工具库之所以功能强大，原因正是它们的开发者理解这门语言的本质和精华，并且将它们运用到了极致。学会使用这些工具库非常有帮助，与此同时掌握这门语言的基础知识仍然是十分重要的。现在有了Kyle Simpson的《你不知道的JS》系列丛书，我们更有理由好好学习了。

《类型和语法》是该系列的第三本书，它介绍了JavaScript核心基础知识，这些东西我们永远不可能从“拷贝＋粘贴”和JavaScript工具库中学到。本书对强制类型转换（coercion）及其隐患、原生构造函数(natives as constructors)、以及JavaScript的所有基础知识都做了详细的介绍，并配以示例代码。同本系列的其他作品一样，Kyle的行文切中要点，没有多余的套话和修辞，正是我喜欢的技术书的风格。

希望大家喜欢《类型和语法》这本书，并能够常读常新。

-David Walsh ([http://davidwalsh.name](http://davidwalsh.name)),
Mozilla资深开发人员

------

##前言

本书使用了“JS”一词，这里并无贬义，虽然我们作为开发人员最喜欢做的事情就是吐槽编程语言。

JavaScript从互联网最早期开始就一直是实现交互体验的基本技术。虽然最初是用来实现诸如鼠标移动轨迹闪烁效果，和烦人的弹出消息框这些东西。将近二十年之后，JavaScript在技术和功能方面都得到了数量级的提升，没有人再质疑它在互联网中的重要地位。

但是作为一门编程语言它一直为人所诟病，包括它的历史沿革，更多的则是它的设计理念。Brendan Eich曾因为它的名字戏称它为“傻小弟”（相对于成熟的Java而言）。实际上这个名字完全是政治和市场考量下的产物。两个语言之间千差万别，“JavaScript”之于“Java”如同“Carnival”（嘉年华）之于“Car”（汽车）一样，没有半点关系。

JavaScript在概念和语法风格上借鉴了其他编程语言，包括C风格的程序根，和隐晦的Scheme/Lisp风格的函数根，这使得它能为不同背景的开发人员所接受，包括那些没有多少编程经验的人。用JavaScript编写一个“Hello World”程序非常简单。

JavaScript可能是最容易上手的编程语言之一，但其中的一些奇特之处使得它不像其他语言那样容易全面掌握。用C或者C++开发一个完整的应用程序要求开发者对这门语言有相当深入的了解。然而对于JavaScript，即使我们用它开发了一个完整的系统也不见得就能深入理解它。

这门语言中有些复杂的概念隐藏得很深，却常以一种看似简单的方式呈现，例如：将函数作为回调函数传递，JavaScript开发人员往往满足于使用这些现成便利的机制，而不愿去探究其中的原理。

JavaScript是一门简单易用的语言，应用广泛，同时它的语言机制又十分复杂和微妙。即使经验丰富的开发人员也需要用心学习才能真正掌握它。

JavaScript让人纠结的地方就在于此，它的阿基里斯之踵正是本书要解决的问题。因为人们毋需理解就能用它来编程，所以常常放松对它的学习。

###使命

碰到JavaScript中那些令人惊诧和抓狂的情况时，如果我们置之不理或者不求甚解，很快就会发现自己根本无从发挥这门语言的威力。

这些部分叫做JavaScript的“精华（The Good Parts）”，但我宁愿读者朋友们把它们视为“容易的部分”，“安全的部分”，或者是“不完整的部分”。

《你不知道的JS》系列旨在介绍JavaScript的另一面，让你深入掌握JavaScript的*全部*，特别是那些难点。

JS开发人员常常满足于一知半解，不愿更深入地去了解，本书要解决的正是这个问题。我们会直面那些疑难问题，而不是退避三舍。

我自己不会满足于仅仅让代码运行起来而不明就里，你也应该这样。在本书中我会逐步介绍JavaScript中那些不太为人知的地方，最终让你对这门语言有一个全面的了解。一旦掌握了这些知识，那些什么技巧、框架、和时髦术语都不在话下。

本系列丛书全面深入地介绍了JavaScript中最被误解和忽视的关键知识点。让你在读完之后从理论和实践上都能对掌握这门语言有足够的信心。

当前你对JavaScript的了解可能都来自于那些一知半解的“专家”。你知道的仅仅是冰山一角。读完本系列丛书后你将会真正了解这门语言。现在就让我们愉快地开始吧。

###回顾

JavaScript是一门优秀的语言。部分学习起来很容易，但是要整体掌握则很难。开发人员们遇到困惑时往往归咎于语言本身，而不是反省他们自身对语言的理解有多匮乏。本系列丛书旨在解决这个问题，使你能够发自内心地喜欢上这门语言。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">本书中的许多示例需要新版本的JavaScript引擎，比如：ES6。有些代码可能无法在老版本的引擎（ES6之前）中运行。</td>
    </tr>
</table>


###书写约定

本书使用以下书写约定：

*斜体字*
表示新术语，URL，电子邮件，文件名，和文件扩展名。

`等宽字`
用于程序代码，以及在段落中引用的程序代码内容，如：变量名，函数名，数据库，数据类型，环境变量，声明语句，和关键词等。

####`粗体等宽字`
需要用户输入的命令和其他文本。

*`斜体等宽字`*
需要用户提供替换值的文本，或者根据上下文计算的值。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">提示和建议</td>
    </tr>
</table>

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">注解</td>
    </tr>
</table>

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">警告和提醒</td>
    </tr>
</table>

###示例代码

本书附带的资料（如：示例代码，练习等）可以从[http://bit.ly/ydkjs-types-code](http://bit.ly/ydkjs-types-code)下载。

本书旨在帮助你解决实际问题。你可以在你的程序和文档中使用本书中的示例代码。除非大量使用，否则不需要经过我们许可。例如，你毋需征得我们的同意即可在程序中使用本书中的某几段示例代码。如果你欲将O'Reilly出版物中的示例代码制作为光盘出售则需要经过我们许可。如果你在回答别人的问题时引用了本书中的内容和示例代码，也不需要征得我们许可。如果你在产品文档中引用了大量本书中的示例代码，则需要征得我们许可。

如果你能够在使用到本书内容的地方注明出处，我们会非常感激，不过这不是强制的。注明出处通常包括书名，作者，出版方，和ISBN。例如：《你不知道的JS》，Kyle Simpson著，O'Reilly出版。Copyright 2015 Getify Solutions, Inc.，978-1-491-90419-0。

如果你的情况不属于上述种种，请通过[permissions@oreilly.com](permissions@oreilly.com)和我们联系。

###Safari Books Online

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/safari.png'></td>
        <td style="border: none;"><a href='http://safaribooksonline.com'>Safari Books Online</a>是一个即时点播数字图书馆，为您提供来自世界顶尖科技和商业作者的专业书籍和视频<a href='https://www.safaribooksonline.com/explore/'>内容</a>。</td>
    </tr>
</table>

科技工作者、软件开发人员、Web设计师、和商业创新从业者都将Safari Books Online作为他们研究、攻关、学习和认证培训的一个主要资源。

Safari Books Onine为[企业](https://www.safaribooksonline.com/enterprise/)、[政府](https://www.safaribooksonline.com/government/)、[教育](https://www.safaribooksonline.com/academic-public-library/)和个人提供不同的[计划和收费](https://www.safaribooksonline.com/pricing/)。

Safari Books Online的会员可以通过一个可检索数据库来访问数千本图书,教学视频，和正式出版前的稿件，它们来自[上百家出版方](https://www.safaribooksonline.com/our-library)，如：O'Reilly Media，Prentice Hall Prossional, Addison- Wesley Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders, McGraw-Hill, Jones & Bartlett, Course Tech‐ nology等。有关Safari Books Online更多的信息请访问我们的网站。

------

###联系我们

任何关于本书的看法和问题，可以通过以下方式和出版方联系：

O’Reilly Media, Inc.
1005 Gravenstein Highway North
Sebastopol, CA 95472
800-998-9938 (in the United States or Canada) 707-829-0515 (international or local) 707-829-0104 (fax)

我们为本书设立了一个网页，上面有勘误，示例，和其他信息。可以通过这个链接访问[http://bit.ly/ydkjs_types-and-grammar](http://bit.ly/ydkjs_types-and-grammar)。

有关本书的评论和技术问题，可以发送邮件到[bookquestions@oreilly.com](bookquestions@oreilly.com)。

有关其他图书的信息，课程，论坛，和新闻，请访问我们的网站[http://www.oreilly.com](http://www.oreilly.com)。

我们的Facebook页面：[http://facebook.com/oreilly](http://facebook.com/oreilly)

我们的Twitter：[http://twitter.com/oreillymedia](http://twitter.com/oreillymedia)

我们的Youtube频道：[http://www.youtube.com/oreillymedia](http://www.youtube.com/oreillymedia)

------

##第一章 类型

很多人认为JavaScript这样的动态语言是没有类型的。让我们看看ES5.1规范（[http://www.ecma-international.org/ecma-262/5.1/](http:// www.ecma-international.org/ecma-262/5.1/)）对此怎样解释：

```
本规范中的算法操纵的值均有相应的类型。本节中定义了所有可能出现的值类型。类型是对ECMAScript的语言类型和规范类型的进一步细分。
我们在ECMAScript语言中直接操纵的值均有一个ECMAScript语言类型与之对应。ECMAScript语言类型包括：Undefined，Null，Boolean，String，Number，和Object。
```

如果你喜欢强类型（又称为静态类型）语言，或许不认同在这里使用“类型（type）”一词。在强类型语言中，“类型”一词的含义比在JavaScript中广得多。

也有人认为JavaScript中的“类型”应该叫“标签（tags）”或者“子类型（subtypes）”更为恰当。

在本书中我们对类型做如下粗略的定义（与规范相同）：*类型*是值的一组内部特征，它定义了该值的行为特征，使其能够区别于其他值，该定义对于语言引擎和开发人员均适用。

换句话说，如果语言引擎和开发人员处理`42`（数字）和`"42"`（字符串）的方式不同，则说明它们的类型不同，一个是数字，一个是字符串。我们通常对数字`42`进行数学运算，而对字符串`"42"`进行字符串操作，如在网页上显示等。

这样定义并非无懈可击，不过对于本书而言已经足矣，并且这也与JavaScript语言对自身的描述一致。

###类型

JavaScript有没有类型真的那么重要吗？

为了合理准确地进行类型转换（见`第四章`），我们必须正确理解各个类型及其内部行为特征。几乎所有的JS程序都会涉及各式各样的强制类型转换，我们在处理这些情况时需要有充分的把握和信心。

如果要将`number``42`当作`string`来处理，比如获得其中第二个字符`"2"`，我们就需要先将其从`number`转换（强制类型转换）为`string`。

这看似简单明了，然而强制类型转换的方式可以有很多种。有些是显式的，比较好理解，也很安全。但如果稍不留神，强制类型转换就可能会产生意想不到的结果。

强制类型转换是令JavaScript开发人员最头疼的地方之一。它经常被人诟病为语言设计上的缺陷，太过*危险*，应该敬而远之。

在对JavaScript的类型有了一个全面的了解之后，我们或许能够改变对它的成见，认识到它的威力和好处，并且明白为什么强制类型转换的缺点被过分放大了。不过首先我们需要深入学习值（values）和类型（types）。

###内置类型

JavaScript有七种内置类型：

- 空值 null
- 未定义 undefined
- 布尔值 boolean
- 数字 number
- 字符串 string
- 对象 object
- 标识 symbol（ES6中新增）

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">除<i>object</i>之外，其他统称为基本类型。</td>
    </tr>
</table>

我们用`typeof`运算符来检测值的类型，它返回类型的字符串值。有趣的是以上七种类型和它们的字符串值并不一一对应：

```
    typeof undefined    === "undefined";    // true
    typeof true         === "boolean";      // true
    typeof 42           === "number";       // true
    typeof "42"         === "string";       // true
    typeof { life: 42 } === "object";       // true
    
    // added in ES6!
    typeof Symbol()     === "symbol";       // true
```

以上六种类型均有同名的字符串值与之对应。`Symbol`是ES6中新加入的类型，我们将在`第三章`中介绍。

你可能注意到类型`null`不在此列。它比较*特殊*，`typeof`针对它的返回结果有bug：

```
    typeof null === "object"; // true
```

正确的返回结果应该是`"null"`，这个bug由来已久，已经存在了将近20年，也许永远也不会被修复，因为牵涉到太多的Web系统，“修复”它会*产生*更多的bug，从而导致大量系统无法正常工作。

我们需要使用复合条件来检测`null`值的类型，：

```
    var a = null;

    (!a && typeof a === "object"); // true
```

`null`是基本类型中唯一的一个“假值”（falsy，也称作false-like，见`第四章`）类型，`typeof`对其仍旧返回`"object"`。

`typeof`的返回值还有一种情况，即：

```
    typeof function a(){ /* .. */ } === "function"; //
     true
```

通过上例似乎可以得出这样的结论，`function（函数）`也是JavaScript的一个内置类型。然而我们查阅规范就会知道，它实际上是`object`的一个“子类型（subtype）”。具体来说，函数是“可调用对象”（callable object），其内部有一个`[[Call]]`属性让它成为可调用对象。

函数是对象，这一点很有用，更重要的是函数还可以拥有属性。例如：

```
    function a(b,c) {
        /* .. */
    }
```

函数对象的`length`属性值是它正式声明的参数数目：

```
    a.length; // 2
```

因为该函数声明了两个命名参数（named parameters，即`b`和`c`），所以它的`length`值为`2`。

那么数组的情况又如何呢？JavaScript支持数组，那它是不是也是一个特殊类型？

```
    typeof [1,2,3] === "object"; // true
```

非也，数组也是对象。确切地说是`object`的一个子类型（见`第三章`），其中的元素按数字顺序来索引（而非一般对象那样通过字符串键值），它的`length`属性会根据元素数量自动更新。

###值和类型

JavaScript中变量是没有类型的，只有值才有。变量随时可以持有任意类型的值。

从另一个角度来理解就是JavaScript不“强制指定类型”，也就是说语言引擎不要求变量总是持有与其初始值相同类型的值。一个变量可以当前被赋予字符串类型的值，随后又被赋予数字类型的值。

值`42`的类型为`number（数字）`，其类型无法更改。值`"42"`的类型为`string（字符串）`，数字`42`可以通过*强制类型转换（coercion）*（见`第四章`）转换为字符串`"42"`。

在对变量执行`typeof`操作时，得到结果的并非是该变量的类型，而是变量持有的值的类型，因为JavaScript中变量是没有类型的。

```
    var a = 42;
    typeof a; // "number"

    a = true;
    typeof a; // "boolean"
```

`typeof`运算符总是返回字符串：

```
    typeof typeof 42; // "string"
```

`typeof 42`首先返回字符串`"number"`，然后`typeof "number"`返回`"string"`。

###undefined和“undeclared”

变量在未持有值的时候为`undefined`。此时`typeof`返回`"undefined"`：

```
    var a;

    typeof a; // "undefined"

    var b = 42;
    var c;

    // later 
    b = c;

    typeof b; // "undefined"
    typeof c; // "undefined"
```

很多人容易将“undefined”等同为“未声明（undeclared）”。然而它们在JS中大相径庭。

对于已在作用域中声明过但是还未持有值的变量，它们的值为“undefined”。对于还没有在作用域中声明过的变量，它们的值为“undeclared”。

例如：

```
    var a;

    a; // undefined
    b; // ReferenceError: b is not defined
```

浏览器对于这类情况的报错信息很让人抓狂。上面的例子中，“b is not defined”容易让人理解为“b is undefined”。因此必须再次说明，“undefined”和“is not defined”截然不同。如果浏览器象“b is not found”或“b is not declared”这样报错的话就能避免很多不必要麻烦。

`typeof`在处理未声明（undeclared）变量时的一些特异功能让人更加抓狂。例如：

```
    var a;

    typeof a; // "undefined"

    typeof b; // "undefined"
```

对于“未声明（undeclared）”（或者“not defined”）变量，`typeof`同样返回`"undefined"`。请注意虽然`b`是一个未声明变量，但`typeof b`执行时并没有报错。这是由于`typeof`一个特殊的安全防范机制所致。

如果`typeof`能对未声明变量返回“undeclared”而非“undefined”的话情况会好很多。

###typeof Undeclared

这样的安全防范机制对于在浏览器中运行的JavaScript来说还是很有用的，因为很多script文件会将变量加载到共享全局命名空间中。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px; "><img src='images/note.png'></td>
        <td style="border: none;">很多人认为全局命名空间中不应该有变量存在，所有东西都应该被封装到模块和私有／独立的命名空间中。理论上这样没错，但在现实中基本不可能，虽然其仍不失为一个值得努力的方向。好消息是ES6中加入了对模块的支持，使得我们离这一目标更近了一步。
        </td>
    </tr>
</table>

一个简单的例子是在程序中使用全局变量`DEBUG`作为“调试模式”的开关。在执行诸如输出信息到控制台这样的调试任务前，我们会检查`DEBUG`变量是否已经被声明过。最顶层的全局变量声明`var DEBUG = true`只出现在“debug.js”文件中，该文件只在开发和测试时才加载到浏览器，在生产环境中则不加载。

我们需要特别注意的是，在程序的其它地方要怎样来检查全局变量`DEBUG`才能避免出现`ReferenceError`错误。这时`typeof`的安全防范机制就成了我们的好帮手：

```
    // 这样会抛出错误
    if (DEBUG) {
        console.log( "Debugging is starting" );
    }

    // 这样是安全的
    if (typeof DEBUG !== "undefined") {
        console.log( "Debugging is starting" );
    }

```

这类检查不仅对用户定义的变量有用，对检查内建的API也很有用：

```
    if (typeof atob === "undefined") {
        atob = function() { /*..*/ };
    }
```


<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">如果要为某个缺失的功能写“polyfill”（衬垫代码或者补充代码，用来补充当前运行环境中缺失的功能），我们或许不会用<b>var atob</b>来声明变量atob。如果在<b>if</b>语句中使用<b>var atob</b>，该声明会被提升（hoisted，参见本系列的《Scope &amp; Closures》一书）到作用域（当前脚本或函数的作用域）的最顶层，即使<b>if</b>条件不成立时也是如此（因为atob全局变量已经存在）。在一些浏览器中，对于一些特殊的内建全局变量（通常被称为“宿主对象，host objects”），这样重复声明会报错。去掉<b>var</b>则可以防止声明被提升。
        </td>
    </tr>
</table>

另外有一种不通过`typeof`的安全防范机制来检查全局变量是否已经存在的方法，即检查全局变量是否也是全局对象中的属性，在浏览器中该全局对象是`window`。所以前面的例子也可以这样来实现：

```
    if (window.DEBUG) {
        // ..
    }
    
    if (!window.atob) {
        // ..
    }
```

与未声明变量不同，访问不存在的对象属性并不会产生`ReferenceError`错误。

许多开发人员会尽量避免使用`window`来访问全局对象，尤其是当代码需要运行在多种JS环境下时（不仅是浏览器，还有服务器端，如node.js等），因为此时全局对象并非总是`window`。

从技术角度来说，`typeof`的安全防范机制对于非全局变量仍然是有用的，虽然这种情况很少见，也有一些开发人员不大愿意这样做。如果你想让其他人在他们的程序中拷贝粘贴你的工具函数，你就需要在函数中做一些检查来确定某些变量是否已经在宿主程序中定义过：

```
    function doSomethingCool() {
        var helper =
            (typeof FeatureXYZ !== "undefined") ?
            FeatureXYZ :
            function() { /*.. default feature ..*/ };

        var val = helper();
        // .. 
    }
```

`doSomethingCool()`检查变量`FeatureXYZ`是否已存在，如果是就使用之，否则使用自己定义的版本。如果其他模块和程序使用到这个函数，它会检查变量`FeatureXYZ`是否已在宿主程序中定义，从而让代码更安全：

```
    // an IIFE (see the "Immediately Invoked Function Expressions"
    // discussion in the Scope & Closures title in this series)
    (function(){
        function FeatureXYZ() { /*.. my XYZ feature ..*/ }

        // include `doSomethingCool(..)`
        function doSomethingCool() {
            var helper =
                (typeof FeatureXYZ !== "undefined") ?
                FeatureXYZ :
                function() { /*.. default feature ..*/ };

            var val = helper();
            // .. 
        }
        
        doSomethingCool();
    })();
```

这里`FeatureXYZ`并不是一个全局变量，但我们还是使用`typeof`的安全防范机制来做检查。关键是我们没有全局对象可用（如前面提到的`windows.___`），因此`typeof`在这种情况下很管用。

一些开发人员倾向使用一种叫“依赖注入”（dependency injection）的设计模式，即将需要的对象作为参数显式地传递进来，而不是通过函数`doSomethingCool()`来检查变量`FeatureXYZ`是否已经定义过，如：

```
    function doSomethingCool(FeatureXYZ) {
        var helper = FeatureXYZ ||
            function() { /*.. default feature ..*/ };
        var val = helper();
        // ..
    }
```

实现此类检查的方法有很多。它们各有利弊，没有对错之分。总的来说`typeof`的安全机制为我们提供了更多选择。

###回顾

JavaScript有七种内置类型：`null`，`undefined`，`boolean`，`number`，`string`，`object`，和`symbol`。可以使用`typeof`运算符来查看。

变量没有类型，但它们持有的值有类型。类型定义了值的内在行为特征。

很多开发人员将“undefined“和“undeclared”混为一谈，但是在JavaScript中它们完全不同。`undefined`是一种变量可以持有的值。“undeclared”表示变量还没有被声明过。

不幸的是JavaScript却将它们混为一谈，在访问"undeclared"变量时这样报错：“ReferenceError:a is not defined”，对"undefined"和"undeclared"变量`typeof`都返回"undefined"。

不过在某些场合使用`typeof`的安全防范机制（阻止报错）来检查未声明（undeclared）变量还是非常有用的。

------

##第二章 值

`array`，`string`，和`number`是程序的基本组成部分，然而在JavaScript中，这些类型的部分特性可以说是“让我欢喜让我忧”。下面我们来逐一了解以便能合理运用。

###数组

和强类型语言不同，在JavaScript中`array`可以容纳任何类型的值，可以是`string`，`number`，`object`，甚至是其他`array`（多维数组就是通过这种方式来实现的）：

```
    var a = [ 1, "2", [3] ];

    a.length;       // 3
    a[0] === 1;     // true
    a[2][0] === 3;  // true
```

我们不需要预先设定数组的大小（参考`第44页的Array(..)`），声明后即可向其中加入值：

```
    var a = [ ];

    a.length;   // 0
    
    a[0] = 1;
    a[1] = "2";
    a[2] = [ 3 ];

    a.length;   // 3
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;"><b>delete</b>运算符能够将值从<b>数组</b>中移除，但需要注意的是，值被移除后数组的<b>length</b>属性并不会相应发生变化。我们会在<b>第五章</b>详细介绍<b>delete</b>运算符。
        </td>
    </tr>
</table>

我们在创建“稀疏（sparse）”`array`（含有空白／空缺单元的数组）时需要特别注意：

```
    var a = [ ];

    a[0] = 1;
    // no `a[1]` slot set here
    a[2] = [ 3 ];
    
    a[1];       // undefined
    
    a.length;   // 3
```

上面的代码可以正常运行，但是其中的“空白单元”可能会产生令人困惑的结果。`a[1]`的值为`undefined`，但这与将其显式赋值为`undefined`（`a[1] = undefined`）还是不一样。详情参见`第44页的“Array(..)”`。

`array`通过数字进行索引，有趣的是因为`array`的类型是`object`，所以也可以包含`string`键值和属性（这些并不计算在数组长度`length`内）：

```
    var a = [ ];

    a[0] = 1;
    a["foobar"] = 2;
    
    a.length;       // 1
    a["foobar"];    // 2
    a.foobar;       // 2
```

这里有一个坑需要多加注意，即如果`string`键值能够被强制类型转换为十进制`number`的话会被当做`number`索引来处理！

```
    var a = [ ];

    a["13"] = 42;
    
    a.length; // 14
```

在`array`中使用`string`作为键值/属性并不是一个好方法。建议使用`object`来存放键值/属性这样的值，用`array`来存放通过数字索引的值。

###类数组

有时我们需要将类`array`（一组通过数字索引的值）转换为真正的`array`，通常是对一组值调用`array`工具函数（如：`indexOf(..)`，`concat(..)`，`forEach(..)`等）。

例如，一些DOM查询操作返回DOM元素列表，它们并非真正意义上的`array`，但和`array`十分类似。另一个常见的例子是一些函数通过`arguments`对象（类数组）以列表的方式来访问函数参数（在ES6中已废止）。

工具函数`slice(..)`经常用来实现这类转换：

```
    function foo() {
        var arr = Array.prototype.slice.call( arguments );
        arr.push( "bam" );
        console.log( arr );
    }

    foo( "bar", "baz" ); // ["bar","baz","bam"]
```

如上例所示，如果`slice()`不带其他参数的话会返回当前数组参数（在本例中是一个类`array`）的一个复本。

ES6中的内置工具函数`Array.from(..)`也有同样的功能：

```
    ...
    var arr = Array.from( arguments );
    ...
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>Array.from(..)</b>有一些功能非常强大，我们将在本系列的<i>《ES6规范及更多》</i>一书中详细介绍。
</td>
    </tr>
</table>

###字符串

`string`通常被看作是由字符组成的`array`。然其内部实现有没有用到`array`并不一定，重点在于我们要认识到JavaScript中的`string`和字符`array`并不是一回事。它们仅仅是表面上看起来像而已。

例如下面的两个值：

```
    var a = "foo";
    var b = ["f","o","o"];
```

如上例所示，`string`和`array`确实有相似之处，都是类`array`。比如它们都有`length`属性，以及`indexOf(..)`（从ES5开始`array`支持此方法）和`concat(..)`方法：

```
    [source,js]

    a.length;                           // 3
    b.length;                           // 3

    a.indexOf( "o" );                   // 1
    b.indexOf( "o" );                   // 1

    var c = a.concat( "bar" );          // "foobar"
    var d = b.concat( ["b","a","r"] );  // ["f","o","o","b","a","r"]

    a === c;                            // false
    b === d;                            // false

    a;                                  // "foo" 
    b;                                  // ["f","o","o"]
```

那是否因此就可以说它们都是“字符数组”？答案是否定的，见下例：

```
    a[1] = "O";
    b[1] = "O";

    a; // "foo"
    b; // ["f","O","o"]
```

JavaScript中的`string`是不可变（immutable）的，而`array`是可变的。并且`a[1]`这样的做法在JavaScript中并非总是合法。老版本的IE就不允许（现在可以了）。*正确*的做法应该是`a.charAt(1)`。

`string`不可变是指`string`的成员函数不会改变`string`的原始值，而是创建并返回一个新的`string`。而`array`的成员函数都是在其原始值上进行操作。

```
    c = a.toUpperCase();
    a === c;    // false
    a;          // "foo"
    c;          // "FOO"

    b.push( "!" );
    b;          // ["f","O","o","!"]
```

很多`array`函数在处理`string`时非常有用，虽然`string`没有这些函数，但我们可以从`array`中“借用”这些非变更方法（nonmutation）来处理`string`：

```
    a.join;         // undefined
    a.map;          // undefined

    var c = Array.prototype.join.call( a, "-" );
    var d = Array.prototype.map.call( a, function(v){
        return v.toUpperCase() + ".";
    } ).join( "" );
    
    c;              // "f-o-o"
    d;              // "F.O.O."
```

另外一个例子是`string`的反转（JavaScript面试常见问题）。`array`有一个`string`没有的可变更成员函数`reverse()`：

```
    a.reverse;      // undefined

    b.reverse();    // ["!","o","O","f"]
    b;              // ["f","O","o","!"]
```

遗憾的是我们无法“借用”`array`的可变更成员函数，因为`string`是不可变的：

```
    Array.prototype.reverse.call( a );
    // 返回值仍然是字符串"foo"的一个封装对象（见第三章）:(
```

一个变通（也叫破解）的办法是先将`string`转换为`array`，处理完毕后再将结果转换回`string`：

```
    var c = a
        // split `a` into an array of characters
        .split( "" )
        // reverse the array of characters
        .reverse()
        // join the array of characters back to a string
        .join( "" );
    
    c; // "oof"
```

对于简单的`string`这样完全没问题，有时这类简单粗暴的办法也挺管用。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">请注意！上述方法对于包含复杂字符（unicode，如：星号，多子节字符等等）的<b>字符串</b>并不适用。这时我们需要功能更加完备，能够处理unicode的工具库。可以参考Mathias Bynen的<a href='https://github.com/mathiasbynens/esrever'>Esrever</a>。</td>
    </tr>
</table>

如果我们经常需要以*字符数组*的方式来处理`string`的话，不如直接用`array`。这样就不用在`string`和`array`之间来回折腾了。可以在需要时用`join("")`将`字符数组`转换为`string`。

###数值

JavaScript中只有一种`number`类型，包括“整数”和带小数的十进制数。“整数“之所以加引号是因为和其他语言不同，JavaScript中没有真正意义上的整数，这也是它一直以来为人所诟病的地方。这种情况在将来或许会有所改观，不过就目前而言所有的数值均为`number`类型。

JavaScript中的“整数”就是没有小数位的十进制数。所以`42.0`即等同于“整数”`42`。

与大部分现代编程语言一样，包括所有的脚本语言，JavaScript的`number`类型是基于“IEEE 754”标准来实现的，通常被称为“浮点数”。JavaScript使用的是其中的“双精度”格式（即“64位二进制”）。

网上很多文章详细介绍了二进制浮点数在内存中的存储方式，以及不同方式各自的考量。为了合理使用`number`类型，我们并不一定要理解数位（bit）在内存中的存储方式，所以本书对此不多做介绍，有兴趣的读者可以参见IEEE 754的相关细节。

###数字语法

JavaScript中的数字常量一般用十进制（base-10）表示。例如：

```
    var a = 42;
    var b = 42.3;
```

数字前面的0可以省略：

```
    var a = 0.42;
    var b = .42;
```

小数点后的小数部分最后面的0也可以省略：

```
    var a = 42.0;
    var b = 42.;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;"><b>42.</b>这种写法是合法的，只是不太常见，考虑到代码的可读性我们不建议使用。</td>
    </tr>
</table>

默认情况下大部分`number`都以十进制显示，小数部分最后面的0被省略。如：

```
    var a = 42.300;
    var b = 42.0;

    a; // 42.3
    b; // 42
```

特别大和特别小的`number`默认用指数格式显示，即`toExponential()`函数的输出结果，例如：

```
    var a = 5E10;
    a;                  // 50000000000
    a.toExponential();  // "5e+10"

    var b = a * a;
    b;                  // 2.5e+21
    
    var c = 1 / a;
    c;                  // 2e-11
```

由于`number`值可以使用`Number`对象来进行封装（boxed，见`第三章`），因此`number`值可以调用`Number.prototype`中的方法（见`第三章`）。例如，`toFixed(..)`方法能够指定小数部分的显示位数：

```
    var a = 42.59;

    a.toFixed( 0 ); // "43"
    a.toFixed( 1 ); // "42.6"
    a.toFixed( 2 ); // "42.59"
    a.toFixed( 3 ); // "42.590"
    a.toFixed( 4 ); // "42.5900"
```

请注意上例中的输出结果实际上是给定`number`的`string`形式，如果指定小数部分的显示位数多于实际值的位数则用`0`补齐。

`toPrecision(..)`方法能够指定*有效数*的显示位数：

```
    var a = 42.59;

    a.toPrecision( 1 ); // "4e+1"
    a.toPrecision( 2 ); // "43"
    a.toPrecision( 3 ); // "42.6"
    a.toPrecision( 4 ); // "42.59"
    a.toPrecision( 5 ); // "42.590"
    a.toPrecision( 6 ); // "42.5900"
```

以上方法不仅适用于`number`变量，也适用于`number`常量。不过对`.`运算符我们需要特别注意，因为它也是一个合法的数字字符，会被优先识别为`number`常量的一部分，然后才是对象属性访问运算符。

```
    // invalid syntax:
    42.toFixed( 3 );    // SyntaxError

    // these are all valid:
    (42).toFixed( 3 );  // "42.000"
    0.42.toFixed( 3 );  // "0.420"
    42..toFixed( 3 );   // "42.000"
```

`42.toFixed(3)`是非法语法，因为`.`被视为常量`42.`的一部分（如前所述），因此没有`.`访问运算符来调用`toFixed`方法。

`42..toFixed(3)`则没有问题，因为第一个`.`被视为`number`的一部分，第二个`.`是属性访问运算符。只是这样看起来有些奇怪，现实中也很少见。在基本类型值上直接调用方法的形式并不常见，不过不常见并不代表*不好*和*不对*。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">一些工具库扩展了<b>Number.prototype</b>的内置方法（见<b>第三章</b>b），以提供更多的数值操作，比如用<b>10..makeItRain()</b>实现十分钟金钱雨动画等很2的功能。</td>
    </tr>
</table>

下面的语法也是合法的（请注意其中的空格）：

```
    42 .toFixed(3); // "42.000"
```

然而对于`number`常量而言这样的语法很容易造成误导，不建议使用。

`number`还可以用指数格式（exponent form）表示，常用于较大的数字，如：

```
    var onethousand = 1E3;                      // means 1 * 10^3
    var onemilliononehundredthousand = 1.1E6;   // means 1.1 * 10^6
```

`number`常量还可以用其他格式来表示，如：二进制，八进制，和十六进制。

当前版本的JavaScript都支持这些格式：

```
    0xf3; // hexadecimal for: 243
    0Xf3; // 同上

    0363; // octal for: 243
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从ES6开始，<b>严格模式（strict mode）</b>不再支持<b>0363</b>八进制格式（新格式见下）。<b>0363</b>格式在<b>非严格模式（non-strict mode）</b>中仍然支持，但是考虑到将来的兼容性最好不要再使用（我们现在使用的应该是<b>严格模式</b>）。</td>
    </tr>
</table>

ES6支持以下新格式：

```
    0o363;      // octal for: 243
    0O363;      // 同上

    0b11110011; // binary for: 243
    0B11110011; // 同上
```

考虑到代码的易读性，我们不推荐使用`0O363`格式，因为`0`和大写`O`在一起容易混淆。建议尽量使用小写的`0x`，`0b`，和`0o`。

###较小的数值

二进制浮点数最大的问题（不仅是JavaScript，所有遵循IEEE 754规范的语言都是如此），是会出现下面的情况：

```
    0.1 + 0.2 === 0.3; // false
```

从数学角度看上面的条件判断应该为`true`，但为什么是`false`呢？

简单来说，二进制浮点数中的`0.1`和`0.2`并不是十分精确，它们相加的结果并非刚刚好等于`0.3`，而是一个比较接近数字`0.30000000000000004`，所以上面的条件判断结果为`false`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">有人认为JavaScript应该采用一种可以精确呈现数字的实现方式。一直以来也出现过很多替代方案，只是都没有被接受成为标准，大概将来也不会。这个问题看起来简单，实则不然，否则早就解决了。</td>
    </tr>
</table>

现在问题来了，如果一些`number`无法做到完全精确，是否意味着`number`类型毫无用处呢？答案当然是否定的。

我们在处理带有小数的数字时需要特别小心。很多（或许是绝大多数）程序仅仅需要处理整数（integer），最大不超过百万或者万亿，此时JavaScript的`number`类型是绝对可靠的。

究竟应该怎样来判断`0.1 + 0.2`和`0.3`是否相等呢？

常见的方法是设置一个误差范围值，我们通常称为“机器精度（machine epsilon）”，对于JavaScript中的`number`来说这个值通常是`2^-52 (2.220446049250313e-16)`。

从ES6开始，该误差范围值定义在`Number.EPSILON`中，我们可以直接拿来用，也可以为ES6之前的版本polyfill该值：

```
    if (!Number.EPSILON) {
        Number.EPSILON = Math.pow(2,-52);
    }
```

我们可以使用`Number.EPSILON`来比较两个`number`是否（在指定的误差范围内）相等：

```
    function numbersCloseEnoughToEqual(n1,n2) {
        return Math.abs( n1 - n2 ) < Number.EPSILON;
    }

    var a = 0.1 + 0.2;
    var b = 0.3;

    numbersCloseEnoughToEqual( a, b );                  // true
    numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );  // false
```

能够呈现的最大浮点数为`1.798e+308`（这是一个相当大的数字），定义在`Number.MAX_VALUE`中。最小浮点数定义在`Number.MIN_VALUE`中，大约是`5e-324`，它不是负数但无限接近`0`！

###整数的安全范围

`number`的呈现方式决定了“整数”的安全值范围，其远小于`Number.MAX_VALUE`。

能够被“安全”呈现的最大整数是`2^53 - 1`，即`9007199254740991`，在ES6中定义为`Number.MAX_SAFE_INTEGER`。相应的最小整数是`-9007199254740991`，定义为`Number.MIN_SAFE_INTEGER`。

有时JS程序需要处理一些比较大的数字，如数据库中的64位ID等常见情况。由于JavaScript的`number`类型无法精确呈现64位数值，所以必须将它们保存（转换）为`string`来处理。

值得庆幸的是大数值操作并不常见（其比较操作可以通过`string`来实现）。如果我们确实需要对大数值进行数学运算的话，就目前来说还是需要借助相关的工具库。将来JavaScript也许会加入对大数值的支持。

###整数检测

要检测一个值是否是整数，可以使用ES6中的`Number.isInteger(..)`方法：

```
    Number.isInteger( 42 );     // true
    Number.isInteger( 42.000 ); // true
    Number.isInteger( 42.3 );   // false
```

也可以为ES6以前的版本polyfill`Number.isInteger(..)`方法：

```
    if (!Number.isInteger) {
        Number.isInteger = function(num) {
            return typeof num == "number" && num % 1 == 0;
        };
    }
```

要检测一个值是否是*安全的整数*，可以使用ES6中的`Number.isSafeInteger(..)`方法：

```
    Number.isSafeInteger( Number.MAX_SAFE_INTEGER );    // true
    Number.isSafeInteger( Math.pow( 2, 53 ) );          // false
    Number.isSafeInteger( Math.pow( 2, 53 ) - 1 );      // true
```

可以为ES6以前的版本polyfill`Number.isSafeInteger(..)`方法：

```
    if (!Number.isSafeInteger) {
        Number.isSafeInteger = function(num) {
            return Number.isInteger( num ) &&
                Math.abs( num ) <= Number.MAX_SAFE_INTEGER;
        }; 
    }
```

###32位有符号整数

虽然整数最大能够达到53位，但是部分数字操作（如：数位操作）只适用于32位`number`，所以这些操作中`number`的安全范围就要小很多。

此时安全范围是从`Math.pow(-2,31)`（-2147483648，约-21亿）到`Math.pow(2,31)`（2147483647，约21亿）。

`a | 0`可以将变量`a`中的数值转换为32位有符号整数。这个方法很管用，因为数位运算符`|`只适用于32位整数（它只关心32位以内的值，而忽略其他数位）。因此与0进行`或`操作即可截取`a`中的32位数位。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">一些特殊的值并不是32位安全（32-bit safe）的，如：<b>NaN</b>和<b>Infinity</b>（我们将在下节介绍）。32位安全是指数位运算中的值会执行虚拟操作<b>ToInt32</b>（见第四章），以便转换为符合数位运算符要求的<b>+0</b>值。</td>
    </tr>
</table>

###特殊数值

JavaScript的数据类型中有几个特殊值JS开发人员需要特别小心并合理使用。

####不是值的值

`undefined`类型只有一个值，即：`undefined`。`null`类型也只有一个值，即：`null`。它们的名称既是类型也是值。

`undefined`和`null`常被用来表示“空（empty）”值或“不是值”的值。它们之间有一些细微的差别。例如：

- `null`指空值。
- `undefined`指还未赋值。

或者：

- `undefined`指从未赋过值。
- `null`指曾被赋过值，但是目前没有值。

`null`是一个特殊关键字，不是标识符，因此我们不能将其当变量来使用和赋值。而`undefined`却是一个标识符，可以被当做变量来使用和赋值。

####Undefined

在`非严格（non-strict）`模式下，我们可以为全局标识符`undefined`赋值（这样的设计实在是欠考虑！）：

```
    function foo() {
        undefined = 2; // really bad idea!
    }
    
    foo();
    
    function foo() {
        "use strict";
        undefined = 2; // TypeError!
    }

    foo();
```

在`非严格`和`严格`两种模式下，我们可以声明一个名为`undefined`的局部变量。再次强调不建议这样做！

```
   function foo() {
        "use strict";
        var undefined = 2;
        console.log( undefined ); // 2
    }

    foo();
```

不要重新定义`undefined`，永远不要。

####void运算符

`undefined`是一个内置标识符（除非被重新定义，见前面的介绍），它的值为`undefined`，得到该值还有另外一个方法，即`void`运算符。

表达式`void ___`没有返回值，因此返回的是`undefined`。`void`并不改变表达式的结果，只是让表达式没有返回值：

```
    var a = 42;

    console.log( void a, a ); // undefined 42
```

我们习惯使用`void 0`来获得`undefined`（这主要源自C语言，当然使用`void true`和其他`void`表达式也行）。`void 0`，`void 1`，和`undefined`之间并没有实质上的区别。

`void`运算符在其他一些情况下也能派上用场，比如如果我们不想表达式返回任何结果，即使它有副作用（side effects）。

例如：

```
    function doSomething() {
        // note: `APP.ready` is provided by our application
        if (!APP.ready) {
            // try again later
            return void setTimeout( doSomething,100 );
        }
    
        var result;
        
        // do some other stuff
        return result;
    }

    // were we able to do it right away?
    if (doSomething()) {
        // handle next tasks right away
    }
```

这里`setTimeout(..)`函数返回一个数值（计时器间隔的唯一标识符，用来取消计时），但是为了确保`if`语句不产生误报（false positive），我们就要`void`掉它。

很多开发人员喜欢分开来写，效果一样，只是没有用到`void`：

```
    if (!APP.ready) {
        // try again later
        setTimeout( doSomething,100 );
        return;
    }
```

一般来说，如果想将代码中那些产生值的地方（如表达式）赋值为`undefined`，就使用`void`运算符。也许这并不十分常见，但还是很有用的。

####特殊数字

`number`类型中有几个特殊的值，我们将在这里详细介绍。

#####不是数字的数字

如果数学运算中的操作数不是`number`类型（或者不能被解析为常规的十进制或十六进制`number`），那么运算将无法返回一个合法的`number`，此时返回值为`NaN`。

`NaN`即“不是一个数字（not a number）”，这个名字容易引起误导，后面我们会讲到。将它理解为“无效数值”，“失败数值”，或者“坏数值”可能更准确些。

例如：

```
    var a = 2 / "foo";      // NaN

    typeof a === "number";  // true
```

这说明“不是数字的数字”的类型仍然是`number`。真是很绕啊！

`NaN`是一个“警戒值”（sentinel value，具有特殊意义的常规值），用来表示`number`类型中的错误状态，意思是“试图执行一个数学运算但是没有成功，这是操作失败返回的`number`”。

有人也许会认为如果要检查变量的值是否为`NaN`，可以直接和`NaN`进行比较，就象比较`null`和`undefined`那样。这是错误的。

```
    var a = 2 / "foo";
   
    a == NaN;   // false
    a === NaN;  // false
```

`NaN`这个值很特殊，它永远不会和它自身相等。它是唯一一个非自反（reflexive，即`x === x`不成立）的值。因此`NaN != NaN`为`true`，很奇怪吧。

既然我们无法对`NaN`进行比较（永远返回false），那么应该怎样来判断它呢？

```
    var a = 2 / "foo";
   
    isNaN( a ); // true
```

很简单，我们使用内建的全局工具函数`isNaN(..)`来判断一个值是否是`NaN`。

实际并没有这么简单。`isNaN(..)`有一个严重的缺陷。它的检查方式过于死板，即“检查传递进来的参数是否不是`NaN`，也不是`number`”。但是这样做结果并不十分准确：

```
    var a = 2 / "foo";
    var b = "foo";
    
    a; // NaN
    b; "foo"
    
    window.isNaN( a ); // true
    window.isNaN( b ); // true--ouch!
```

很明显"foo"*不是一个数字*，但是它也不是`NaN`。这个bug自JS问世以来就一直存在，至今超过19年了。

从ES6开始我们可以使用工具函数`Number.isNaN(..)`。对ES6之前的浏览器的polyfill可以是下面这样：

```
    if (!Number.isNaN) {
        Number.isNaN = function(n) {
            return (
                typeof n === "number" &&
                window.isNaN( n )
            ); 
        };
    }
    
    var a = 2 / "foo";
    var b = "foo";
    
    Number.isNaN( a ); // true
    Number.isNaN( b ); // false--phew!
```

实际上还有一个更简单的方法，即利用`NaN`不等于自身这个奇怪的特性。`NaN`是JavaScript中*唯一*一个不等于自身的值。

因此我们可以这样：

```
    if (!Number.isNaN) {
        Number.isNaN = function(n) {
            return n !== n;
        };
    }
```

虽然奇怪，但是有效。

很多JS程序中或许都存在`NaN`方面的问题。所以我们应该尽量使用`Number.isNaN(..)`这样可靠的方法，无论是系统内置的还是polyfill的。

如果你在代码中使用了`isNaN(..)`函数，意味着你的程序*迟早会有bug*。

#####无穷数（infinities）

熟悉传统编译型语言的开发人员可能都遇到过编译错误（compiler error）或者运行时错误（runtime exception），例如“除以0”：

```
    var a = 1 / 0;
```

然而在JS中，上例的结果为`Infinity`（即`Number.POSITIVE_INFINITY`）。同理：

```
    var a = 1 / 0;  // Infinity
    var b = -1 / 0; // -Infinity
```

如果除法运算中有一个操作数为负，则结果为`-Infinity`（即`Number.NEGATIVE_INFINITY`）。

JS遵循有限数字表示标准（即之前介绍过的IEEE 754浮点数），所以和纯粹的数学运算不同，JS的运算结果有可能溢出，此时结果为`Infinity`或者`-Infinity`。

例如：

```
    var a = Number.MAX_VALUE;   // 1.7976931348623157e+308
    a + a;                      // Infinity
    a + Math.pow( 2, 970 );     // Infinity
    a + Math.pow( 2, 969 );     // 1.7976931348623157e+308
```

规范规定，如果数学运算（如加法）的结果超出处理范围，则由IEEE 754规范中的“就近取整（round-to-nearest）”模式来决定最后的结果。例如：相对于`Infinity`，`Number.MAX_VALUE + Math.pow(2, 969)`与`Number.MAX_VALUE`更为接近，因此它被“向下取整（round down）”，而`Number.MAX_VALUE + Math.pow(2, 970）`与`Infinity`更为接近，所以它被“向上取整（round up）”。

这个问题想多了容易头疼，我们还是就此打住吧。

计算结果一旦溢出为`无穷数`就无法再产生有穷数结果。说得好听一点就是，你可以从有穷走向无穷，但无法从无穷回到有穷。

有人也许会问：“那么无穷除以无穷会得到什么结果呢？”。我们的第一反应可能会是“1“或者”无穷“，可惜都不对。因为从数学运算和JavaScript语言的角度来说，`Infinity / Infinity`是一个未定义操作。JS中它的结果是`NaN`。

那么有穷数正数除以`Infinity`呢？很简单，结果是`0`。有穷负数除以`Infinity`呢？这里卖个关子，我们后面介绍。

#####零值

这部分内容对于习惯数学思维的读者可能会带来困惑，JavaScript中有一个常规的`0`（也叫做`+0`）和一个`-0`。在解释为什么会有`-0`之前，我们先来看看JS对它是如何来处理的。

`-0`除了可以用作常量以外，也可以成为一些数学运算的返回值。例如：

```
    var a = 0 / -3; // -0
    var b = 0 * -3; // -0
```

加法和减法运算不会产生负零（negative zero）结果。

负零在开发调试控制台中通常显示为`-0`，不过一些老版本的浏览器会显示`0`。

规范规定负零转换为字符串“`0`”：

```
    var a = 0 / -3;
    
    // (some browser) consoles at least get it right
    a;                          // -0
    
    // but the spec insists on lying to you!
    a.toString();               // "0"
    a + "";                     // "0"
    String( a );                // "0"

    // strangely, even JSON gets in on the deception
    JSON.stringify( a );   // "0"
```

有意思的是如果反过来将其从`string`转换为`number`，结果都是准确的：

```
    +"-0";              // -0
    Number( "-0" );     // -0
    JSON.parse( "-0" ); // -0
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;"><b>JSON.stringify(-0)</b>返回<b>“0”</b>，而<b>JSON.parse("-0")</b>返回<b>-0</b>。</td>
    </tr>
</table>

负零转换为字符串的结果令人费解，它的比较操作也如此：

```
    var a = 0;
    var b = 0 / -3;

    a == b;     // true
    -0 == 0;    // true

    a === b;    // true
    -0 === 0;   // true
    
    0 > -0;     // false 
    a > b;      // false
```

要区分`-0`和`0`，不能依赖开发调试窗口的显示结果，需要做一些特殊处理：

```
    function isNegZero(n) {
        n = Number( n );
        return (n === 0) && (1 / n === -Infinity);
    }

    isNegZero( -0 );        // true
    isNegZero( 0 / -3 );    // true
    isNegZero( 0 );         // false
```

除了理论上的考量外，我们为什么需要负零呢？

有些应用程序中的数据需要用级数形式来表示（比如动画帧的移动速度），`number`的符号位（sign）用来表示另外的信息（比如移动的方向）。这时如果一个包含`0`值的变量丢失了它的符号位，就会丢失其中包含的方向信息。所以保留`0`值的符号位可以防止这类情况发生。

#####特殊等式

如前所述，`NaN`和`-0`在进行相等比较时表现有些特别。由于`NaN`和自身不相等，所以我们必须使用ES6中的`Number.isNaN(..)`（或者polyfill）。而`-0`等于`0`（对于`===`也是如此，见`第四章`），因此我们必须使用`isNegZero(..)`这样的工具函数。

ES6中新加入了一个工具方法`Object.is(..)`来判断两个值是否绝对相等，可以处理上述所有的特殊情况：

```
    var a = 2 / "foo";
    var b = -3 * 0;

    Object.is( a, NaN );    // true
    Object.is( b, -0 );     // true

    Object.is( b, 0 );      // false
```

对于ES6之前的版本，`Object.is(..)`有一个简单的polyfill：

```
    if (!Object.is) {
        Object.is = function(v1, v2) {
            // test for `-0`
            if (v1 === 0 && v2 === 0) {
                return 1 / v1 === 1 / v2;
            }
            // test for `NaN`
            if (v1 !== v1) {
                return v2 !== v2;
            }
            // everything else
            return v1 === v2;
        };
    }
```

能使用`==`和`===`（见`第四章`）时就尽量不要使用`Object.is(..)`，因为前者效率更高、更通用。`Object.is(..)`主要用来处理那些特殊的相等比较。

###值和引用

在很多编程语言中，赋值和参数传递可以通过值拷贝或者引用拷贝来完成，取决于使用的语法。

例如，在C++中如果要向函数传递一个`number`，它的值在函数中会被更改，可以这样声明参数`int& myNum`，向该函数传递变量`x`时，`myNum`即为指向`x`的引用。引用是一种特殊的指针，即指向变量的指针（*别名*）。如果不将参数声明为引用，则参数值*总是*通过值拷贝的方式传递，即使复杂的对象值也是如此。

JavaScript中没有指针，引用的工作机制也不尽相同。JS中的变量不能是指向另一个变量的引用。

JS中的引用指向的是（共享）值，如果某个值有10个不同的引用，这些引用指向的是同一个（共享）值，*它们相互之间没有任何引用／指向关系*。

JavaScript在语法上对值和引用的赋值／传递不做区分，*仅通过值的类型来判断*。

让我们来看一个例子：

```
    var a = 2;
    var b = a; // `b` is always a copy of the value in `a`
    b++;
    a; // 2
    b; // 3

    var c = [1,2,3];
    var d = c; // `d` is a reference to the shared `[1,2,3]` value
    d.push( 4 );
    c; // [1,2,3,4]
    d; // [1,2,3,4]
```

简单值（simple values，即标量基本类型值，scalar primitives）*总是*通过值拷贝的方式来赋值／传递，包括：`null`，`undefined`，`string`，`number`，`boolean`，和ES6中的`symbol`。

复合值（compound values）－`object`（包括`array`和所有的封装对象，见`第三章`）和`function`，*总是*通过引用拷贝的方式来赋值／传递。

前面示例代码中的`2`是一个标量基本类型值，所以变量`a`持有的是该值的一个拷贝，`b`持有该值的另一个拷贝。`b`中的值更改时`a`中的值保持不变。

`c`和`d`则是分别指向同一个复合值`[1,2,3]`的两个引用。请注意，`c`和`d`仅仅是指向值`[1,2,3]`，并非持有。所以通过它们更改的是同一个共享值（如调用`.push(4)`），随后它们都指向更改后的新值`[1,2,3,4]`。

由于引用指向的是值本身而非变量，所以一个引用无法更改另一个引用的指向。

```
    var a = [1,2,3];
    var b = a;
    a; // [1,2,3]
    b; // [1,2,3]
    
    // later
    b = [4,5,6];
    a; // [1,2,3]
    b; // [4,5,6]
```

`b=[4,5,6]`并不影响`a`指向的值`[1,2,3]`。除非`b`不是指向`array`的引用，而是指向`a`的指针，但在JS中不存在这种情况！

围绕函数参数经常产生这样的困惑：

```
    function foo(x) {
        x.push( 4 );
        x; // [1,2,3,4]
    
        // later
        x = [4,5,6];
        x.push( 7 );
        x; // [4,5,6,7]
    }

    var a = [1,2,3];
    
    foo( a );

     a; // [1,2,3,4]  not  [4,5,6,7]
```

我们将`a`传递给函数的时候，实际是将`a`的一个复本赋值给`x`，而`a`仍然指向`array``[1,2,3]`。在函数中我们可以通过引用`x`来更改该`array`的值（`push(4)`，更改后的新值为`[1,2,3,4]`）。但赋值语句`x = [4,5,6]`并不影响`a`指向的值，所以`a`仍然指向更改后的新值`[1,2,3,4]`。

我们不能通过引用`x`来更改引用`a`的指向，只能更改`a`和`x`共同指向的值。

如果要将`a`指向的值更改为`[4,5,6,7]`，我们必须更改`x`指向的`array`的内容，而不是为`x`赋值一个新的`array`。

```
    function foo(x) {
        x.push( 4 );
        x; // [1,2,3,4]

        // later
        x.length = 0; // empty existing array in-place
        x.push( 4, 5, 6, 7 );
        x; // [4,5,6,7]
    }
    
    var a = [1,2,3];

    foo( a );
    
    a; // [4,5,6,7] not [1,2,3,4]
```

`x.length = 0`和`x.push(4,5,6,7)`并没有创建一个新的`array`，而是更改了当前的`array`。于是`a`指向的值变成了`[4,5,6,7]`。

请记住：我们无法自行决定使用值拷贝还是使用引用，一切由值的类型决定。

如果要通过值拷贝的方式来传递复合值（compound value，比如`array`），就需要为值创建一个拷贝，这样传递的就不再是原始值了。例如：

```
    foo( a.slice() );
```

`slice(..)`不带参数会返回当前`array`的一个浅拷贝（shallow copy）。由于传递给函数的是指向该拷贝的引用，所以`foo(..)`中的操作不会影响`a`指向的`array`。

相反，如果要将标量基本类型值传递到函数内并进行更改，就需要将该值封装到一个复合值（`object`，`array`，等）中，然后通过引用拷贝（reference-copy）的方式传递。

```
    function foo(wrapper) {
        wrapper.a = 42;
    }

    var obj = { 
        a: 2
    };

    foo( obj );

    obj.a; // 42
```

这里`obj`是一个封装了标量基本类型值`a`的封装对象（wrapper）。`obj`引用的一个拷贝作为参数`wrapper`被传递到`foo(..)`中。这样我们就可以通过`wrapper`来访问该共享对象并更改其属性。函数执行结束后`obj.a`将变为`42`。

如果需要传递指向标量基本类型值的引用，比如`2`，则可以将其封装到对应的`number`封装对象中（见`第三章`）。

虽然这里传递的是一个指向`number`对象的引用拷贝，但和预想的不同，我们并不能通过它来更改其中的基本类型值：

```
    function foo(x) {
        x = x + 1;
        x; // 3 
    }
    
    var a = 2;
    var b = new Number( a ); // or equivalently `Object(a)`
    
    foo( b );
    console.log( b ); // 2, not 3
```

因为标量基本类型值是不可更改的（`string`和`布尔`也是如此）。如果一个`number`对象的标量基本类型值是`2`，那么该值就不能被更改，除非创建一个包含新值的`number`对象。

当执行`x = x + 1;`时，`x`中的标量基本类型值`2`被从`number`对象中拆封（unboxed，或者提取，extracted）出来，`x`神不知鬼不觉地从引用变成了`number`对象，它的值为`2 + 1`等于`3`。然而函数外的`b`仍然指向原来那个值为`2`的`number`对象。

我们还可以向`number`对象添加属性（只要不更改其内部的基本类型值就行），通过它们间接地进行数据交换。

不过此法不太常见，或许大多数人并不认为这是一个好方法。

相对而言，前面的示例代码中介绍的用`obj`作为封装对象的方法可能更好一些。这并不是说封装对象没有什么用，只是多数时候我们应该优先考虑使用标量基本类型。

引用的功能很强大，但是常常产生出人意料的结果。赋值／参数传递是通过引用还是值拷贝完全由值的类型来决定，所以我们使用哪种类型间接决定了赋值／参数传递的方式。

###回顾

JavaScript中的`array`是通过数字索引的一组任意类型的值，`string`和`array`类似，但是它们的行为特征不同，在将`string`作为`array`处理时需要特别小心。JavaScript中的`number`包括“整型”和“浮点型”。

基本类型中定义了几个特殊值。

`null`类型只有一个值`null`，`undefined`类型也只有一个值`undefined`。所有变量在赋值之前的默认值都是`undefined`。`void`运算符返回`undefined`。

`number`类型有几个特殊值，包括：`NaN`（意指“Not a Number”，更确切地说是“invalid number”），`+Infinity`，`-Infinity`，和`-0`。

简单标量基本类型值（`string`，`number`等）通过值拷贝来赋值／传递，复合值（`object`等）通过引用拷贝来赋值／传递。这里的引用和其它语言中的引用／指针不同，它们不能指向别的引用／指针，只能指向值。

------

##第三章 原生函数

`第一章`和`第二章`提到过一些JavaScript的内建函数，如：`String`和`Number`，它们通常被称为“原生函数（natives）”。本章我们将对它们做详细介绍。

常用的原生函数有：

- String() 
- Number() 
- Boolean()
- Array()
- Object()
- Function()
- RegExp()
- Date()
- Error()
- Symbol()－ES6中新增!

它们实际上就是内建函数。

如果我们熟悉Java语言就会发现，JavaScript中的`String()`和Java中的字符串构造函数`String(..)`非常相似：

```
    var s = new String( "Hello World!" );

    console.log( s.toString() ); // "Hello World!"
```

原生函数可以被当做构造函数来使用。但是它们创建出来的对象可能会和我们预想的有出入：

```
    var a = new String( "abc" );
    
    typeof a;                            // "object" ... not "String"
    
    a instanceof String;                 // true
    
    Object.prototype.toString.call( a ); // "[object String]"
```

通过构造函数（如`new String("abc")`）创建出来的是封装了基本类型值（如`"abc"`）的封装对象。

请注意`typeof`在这里返回的是`object`类型的子类型（subtypes）。

可以使用下面的代码来查看封装对象：

```
    console.log( a );
```

由于不同的浏览器处理对象序列化（serialization）的方式各有不同，所以上例的输出结果也不尽相同。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">在本书写作时，Chrome的最新版本是这样显示的：<a>String {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}</b>。但老版本这样显示：<a>String {0: "a", 1: "b", 2: "c"}</a>。最新版本的Firefox这样显示：<a>String ["a","b","c"]</a>，但老版本这样显示：<a>"abc"</a>，并且可以点击打开对象查看器。这些输出结果随着浏览器的演进不断变化。</td>
    </tr>
</table>

再次强调，`new String("abc")`创建的是字符串`"abc"`的封装对象，而非基本类型值`"abc"`。

###内部属性[[Class]]

`typeof`返回值为`"object"`的对象（如`array`）包含一个内部属性`[[Class]]`（我们可以把它看作是一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般是通过`Object.prototype.toString(..)`来访问。例如：

```
    Object.prototype.toString.call( [1,2,3] );
    // "[object Array]"

    Object.prototype.toString.call( /regex-literal/i );
    // "[object RegExp]"
```

上例中的数组的内部`[[Class]]`属性值是`"Array"`，正则表达式的值是`"RegExp"`。通常内部`[[Class]]`属性是与创建值使用的内建原生构造函数对应（见下），但也并非总是如此。

那么基本类型值呢？我们先来看看`null`和`undefined`：

```
    Object.prototype.toString.call( null );
    // "[object Null]"
    
    Object.prototype.toString.call( undefined );
    // "[object Undefined]"
```

虽然`Null()`和`Undefined()`原生构造函数并不存在，但是内部`[[Class]]`属性值仍然是`"Null"`和`"Undefined"`。

对于其他基本类型值来说情况又有所不同，如：`string`，`number`，和`boolean`，通常称为“包装（boxing）”（参见`第42页的“封装对象包装”`）：

```
    Object.prototype.toString.call( "abc" );
    // "[object String]"
    
    Object.prototype.toString.call( 42 );
    // "[object Number]"
    
    Object.prototype.toString.call( true );
    // "[object Boolean]"
```

上例中的基本类型值自动被包装（boxed）为对应的封装对象，所以它们的内部`[[Class]]`属性值分别为`"String"`，`"Number"`，和`"Boolean"`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从ES5到ES6，<a>toString()</a>和<a>[[Class]]</a>发生了一些变化，我们将会在本系列的<i>《ES6 &amp; Beyond》</i>一书中详细介绍。</td>
    </tr>
</table>

###封装对象包装

封装对象（object wrappers）扮演着十分重要的角色。因为基本类型值没有`.length`和`.toString()`这样的属性和方法，需要通过封装对象才能访问，此时JS会自动为基本类型值*包装*（box或者wrap）一个封装对象：

```
    var a = "abc";
    
    a.length; // 3
    a.toUpperCase(); // "ABC"
```

如果我们需要经常用到`string`中的属性和方法，比如在`for`循环中使用`i < a.length`，从一开始就创建一个封装对象可能更好些，这样JS引擎就不必每次自动创建封装对象了。

但实际上这并不是一个好办法。因为浏览器早就为`.length`这样的常见情况做了性能优化，试图通过直接使用封装对象的方式来“提前优化（preoptimize）”代码*反而会降低执行效率*。

通常我们不用直接使用封装对象。最好是让JS引擎自己决定什么时候使用。换言之就是应该优先考虑使用`"abc"`和`42`这样的基本类型值，而非`new String("abc")`和`new Number(42)`。

###封装对象释疑

使用封装对象时需要特别注意一些地方。

例如`Boolean`：

```
    var a = new Boolean( false );
    
    if (!a) {
        console.log( "Oops" ); // never returns
    }
```

这里的问题在于我们为`false`值创建了一个封装对象，但对象本身是真值（“truthy”，即总是返回`true`，见`第四章`），所以使用封装对象和使用`false`值的结果大相径庭。

如果想要自行封装基本类型值，可以使用`Object(..)`函数（不带`new`）：

```
    var a = "abc";
    var b = new String( a );
    var c = Object( a );

    typeof a; // "string"
    typeof b; // "object"
    typeof c; // "object"
    
    b instanceof String; // true
    c instanceof String; // true

    Object.prototype.toString.call( b ); // "[object String]"
    Object.prototype.toString.call( c ); // "[object String]"
```

重要的话说再说一遍，通常不推荐直接使用封装对象（如上例中的`b`和`c`），不过它们在某些情况下可能会派上用场。

###拆封

如果想要得到封装对象中的基本类型值，可以使用`valueOf()`函数：

```
    var a = new String( "abc" );
    var b = new Number( 42 );
    var c = new Boolean( true );

    a.valueOf(); // "abc"
    b.valueOf(); // 42
    c.valueOf(); // true
```

在需要用到封装对象中的基本类型值时会发生隐式（implicitly）拆封（unboxing）。这个过程（`强制类型转换，coercion`）我们将在`第四章`详细介绍。

```
    var a = new String( "abc" );
    var b = a + ""; // `b` has the unboxed primitive value "abc"
    
    typeof a;       // "object"
    typeof b;       // "string"
```

###使用原生函数作为构造函数

对于`array`，`object`，`function`，和`regular-expression（正则表达式）`来说，我们一般倾向通过常量的方式来创建值，实际上使用常量和使用构造函数的效果是一样的（创建的值都是通过封装对象来包装）。

前面讲过我们应该尽量避免使用这些构造函数，除非确实有必要，因为它们时常会产生意想不到的结果。

####Array(..)

```
    var a = new Array( 1, 2, 3 );
    a; // [1, 2, 3]

    var b = [1, 2, 3];
    b; // [1, 2, 3]
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">构造函数<b>Array(..)</b>不要求必须带<b>new</b>关键字。没有时它会被自动加上。因此<b>Array(1,2,3)</b>和<b>new Array(1,2,3)</b>的效果是一样的。</td>
    </tr>
</table>

`array`构造函数只带一个`number`参数时，该参数会被作为数组的预设长度（length），而非数组中的一个元素。

这实在不是一个明智之举，容易让人犯错。

更要命的是，`array`并没有预设长度这个概念。这样创建出来的只是一个空数组（empty array），只不过其`length`属性被设置成了指定的值。

一个数组中没有任何单元，但是它的`length`属性却显示单元的数量，这样的数据结构很奇特，会导致一些怪异的行为。这一切源于那些已被废止的旧特性（如“类数组对象”`arguments`）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">我们将至少包含一个“空单元（empty slot）”的<b>数组</b>称为“稀疏数组（sparse array）”。</td>
    </tr>
</table>

对于这种情况不同浏览器的开发调试控制台的显示结果也各异，让问题更复杂化。

例如：

```
    var a = new Array( 3 );
    
    a.length; // 3
    a;
```

`a`在Chrome中显示为`[ undefined x 3 ]`（本书写作时），意指其有三个值为`undefined`的单元，实际上并没有（“空单元 empty slots”这个叫法并不准确）。

运行下面的代码可以看出它们的差别：

```
    var a = new Array( 3 );
    var b = [ undefined, undefined, undefined ];
    var c = [];
    c.length = 3;
    
    a; 
    b; 
    c;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">我们可以创建包含空单元的数组，如上例中的<b>c</b>。如果将<b>length</b>属性设置为超过实际单元数的值，就会隐式地制造出空单元。实际上还可以通过<b>delete b[1]</b>在数组<b>b</b>的中制造出一个空单元。</td>
    </tr>
</table>

`b`在Chrome的当前版本中显示为`[ undefined, undefined, undefined ]`，而`a`和`c`则显示为`[ undefined x 3 ]`。是不是很晕？

更加糟糕的是在本书写作时，`a`和`c`在Firefox中显示为`[ , , , ]`。有没有发现什么问题？三个逗号代表了四个空单元，而非我们所想的三个。

为什么Firefox会在输出结果后面多加一个`,`！？因为从ES5开始允许在列表（数组值、属性列表等）的末尾加上一个逗号（在处理中会被忽略不计）。所以如果在代码或者调试控制台中输入`[ , , , ]`，实际得到的会是`[ , , ]`（包含三个空单元的数组）。

读到这里你或许已是一头雾水，没关系，你不是一个人在战斗！

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">对于这类情况Firefox已改为显示<b>[ <3 empty slots> ]</b>，比显示<b>[ , , , ]</b>好得多。</td>
    </tr>
</table>

不仅控制台的输出结果让人费解，更糟糕的还在后面。上例中的`a`和`b`在有些情况下表现相同，有些情况下却不同：

```
    a.join( "-" ); // "--"
    b.join( "-" ); // "--"

    a.map(function(v,i){ return i; }); // [ undefined x 3 ]
    b.map(function(v,i){ return i; }); // [ 0, 1, 2 ]
```

晕。

`a.map(..)`之所以执行失败，是因为数组中并没有任何单元，所以`map(..)`无从遍历。而`join(..)`却不一样，它的具体实现可参考下面的代码：

```
    function fakeJoin(arr,connector) {
        var str = "";
        for (var i = 0; i < arr.length; i++) {
            if (i > 0) {
                str += connector;
            }
            if (arr[i] !== undefined) {
                str += arr[i];
            } 
        }
        return str; 
    }
    
    var a = new Array( 3 );
    fakeJoin( a, "-" ); // "--"
```

可以看到，`join(..)`首先假定数组不为空，然后通过`length`属性值来遍历其中的元素。而`map(..)`并不做这样的假定，所以它对“空单元”数组的处理结果出乎意料，容易导致执行失败。

我们可以这样来创建包含`undefined`单元（而非“空单元”）的数组：

```
    var a = Array.apply( null, { length: 3 } );
    a; // [ undefined, undefined, undefined ]
```

不太好理解？下面我们详细解释一下。

`apply(..)`是一个工具函数，适用于所有函数对象，它以一种特殊的方式来调用传递给它的函数。

第一个参数是`this`对象（在本系列的<i>《this & Object Prototypes》</i>一书中有介绍），这里我们不用管它，将它设为`null`。第二个参数必须是一个`array`（或者*类似*数组的值，也叫做“类数组对象，array-like object”）。该“数组”中的值作为被调用函数的参数。

因此`Array.apply(..)`调用的是`Array(..)`函数，并且将`{ length: 3 }`中的值作为函数的参数。

我们可以想象`apply(..)`内部有一个`for`循环（和前面的`join(..)`类似），从`0`开始循环到`length`（本例中为`3`，即循环到`2`，不包括`3`）。

假如在`apply(..)`中数组对象参数名为`arr`，那么`for`循环会通过`arr[0]`，`arr[1]`，`arr[2]`来遍历该数组。由于`{ length: 3 }`中并不存在这些属性，所以返回值为`undefined`。

换句话说，我们实际上调用的是`Array(undefined, undefined, undefined)`，所以最后的结果是单元值为`undefined`的数组，而非空单元数组。

虽然使用`Array.apply( null ,{ length: 3 } )`来创建单元值为`undefined`的数组显得有些奇怪和繁琐，但是远比用`Array(3)`更好、更可靠。

总之就是一句话：*永远*不要创建和使用空单元数组。

###Object(..)，Function(..)，和RegExp(..)

`Object(..)`／`Function(..)`／`RegExp(..)`这些构造函数除非确实有必要，否则尽量不要使用：

```
    var c = new Object();
    c.foo = "bar";
    c; // { foo: "bar" }

    var d = { foo: "bar" };
    d; // { foo: "bar" }
    
    var e = new Function( "a", "return a * 2;" );
    var f = function(a) { return a * 2; }
    function g(a) { return a * 2; }
    
    var h = new RegExp( "^a*b+", "g" );
    var i = /^a*b+/g;
```

实际操作中我们并没有必要使用`new Object()`来创建对象，这样就无法象常量形式（literal 
form）那样一次设定多个属性，而必须逐一设定。

构造函数`Function`在少数情况下很有用，比如需要动态定义函数参数和函数体的时候。不要把`Function(..)`当做`eval(..)`的替代品来使用。我们基本上不会用这种方式来定义函数。

强烈建议使用常量形式（如：`/^a*b+/g`）来定义正则表达式，这样不仅语法简单，执行效率也更高，因为JS引擎在代码执行前会对它们进行预编译和缓存。与前面的构造函数不同，`RegExp(..)`还是很有用的，比如动态定义正则表达式：

```
    var name = "Kyle";
    var namePattern = new RegExp( "\\b(?:" + name + ")+\\b", "ig" );

    var matches = someText.match( namePattern );
```

上面的情况在JS中会不时出现，这时`new RegExp("pattern","flags")`就能派上用场。

###Date(..)和Error(..)

我们经常会用到`Date(..)`和`Error(..)`这两个原生构造函数，因为没有相应的常量形式可以替代它们。

创建日期对象必须使用`new Date()`。`Date(..)`构造函数可以带参数，用来指定日期和时间，不带参数的话则使用当前日期和时间。

`Date(..)`最主要的用途是获得当前Unix系统时间（从1970年1月1日开始计算，以秒为单位）。可以通过日期对象中的`getTime()`来获得该值。

从ES5开始引入了一个更简单的方法，即静态函数`Date.now()`。对ES5之前的版本我们可以使用下面的polyfill：

```
    if (!Date.now) {
        Date.now = function(){
            return (new Date()).getTime();
        };
    }
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">如果在调用<b>Date()</b>时不带<b>new</b>关键字会得到当前日期的字符串值。规范没有规定它的具体格式，但浏览器会使用类似“Fri Jul 18 2014 00:31:02 GMT-0500 (CDT)”这样的格式来显示。</td>
    </tr>
</table>

构造函数`Error(..)`（和前面的`Array()`类似）带不带`new`关键字都一样。

创建错误对象（error object）主要是为了获得当前运行堆栈的上下文信息（在大部分JS引擎中是通过只读属性`.stack`来访问）。堆栈上下文信息包括函数调用栈信息和产生错误的代码行号，以便调试（debugging）。

错误对象通常与`throw`配合使用：

```
    function foo(x) {
        if (!x) {
            throw new Error( "x wasn't provided" );
        }
    // .. }
```

错误对象一般至少会有`message`属性，有时可能还会有其他属性（它们须被当作只读属性来使用），如：`type`。除了访问`stack`属性外，最好是直接调用`toString()`方法来获得经过格式化的方便查看的错误信息（显示调用，或者通过强制类型转换隐式调用，见`第四章`）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">除了<b>Error(..)</b>外，还有针对某些特定错误类型的原生构造函数，如：<b>EvalError(..)</b>，<b>RangeError(..)</b>，<b>ReferenceError(..)</b>，<b>SyntaxError(..)</b>，<b>TypeError(..)</b>，和<b>URIError(..)</b>。但我们很少直接使用它们。这些构造函数在程序产生异常时会被自动调用（比如试图使用未声明的变量时会产生<b>ReferenceError</b>错误）。</td>
    </tr>
</table>

###Symbol(..)

ES6中新增了“符号”（Symbol）这一基本数据类型。符号是具有唯一性的特殊值（并不绝对保证唯一！），用作对象属性名不容易产生命名冲突。引入该类型主要是由于ES6中的一些特殊构造，我们也可以自定义符号。

符号可以被用作属性名，但是在代码中无法查看和访问符号的实际值，在调试控制台中也是如此。在调试控制台中符号会显示为`Symbol(Symbol.create)`这样的内容。

ES6中有一些预定义符号，它们是`Symbol`的静态属性，如：`Symbol.create`，`Symbol.iterator`等。我们可以这样来使用它们：

```
    obj[Symbol.iterator] = function(){ /*..*/ };
```

我们可以使用`Symbol(..)`原生构造函数来自定义符号。它有些特别，不能带`new`，否则会出错：

```
    var mysym = Symbol( "my own symbol" );
    mysym;              // Symbol(my own symbol)
    mysym.toString();   // "Symbol(my own symbol)"
    typeof mysym;       // "symbol"
    
    var a = { };
    a[mysym] = "foobar";
    Object.getOwnPropertySymbols( a );
    // [ Symbol(my own symbol) ]
```

符号虽然实际上并非私有（private）属性（通过`Object.getOwnPropertySymbols(..)`可以获得对象中的所有符号），但其主要还是用于私有和特殊属性。很多开发人员用它来替代那些有下划线前缀（_）的属性，下划线前缀通常用于命名私有和特殊属性。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>符号</b>并不是一种<b>对象</b>，它是一种简单标量基本类型。</td>
    </tr>
</table>

###原生原型（Native Prototypes）

原生构造函数有自己的`.prototype`对象，如：`Array.prototype`，`String.prototype`等。

这些对象中包含其对应子类型特有的行为特征。

例如，将基本类型`string`值封装（boxing）为字符串对象之后，就能访问`String.prototype`中定义的方法。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">根据文档约定，我们将<b>String.prototype.XYZ</b>简写为<b>String#XYZ</b>，对其他<b>.prototypes</b>也如此。</td>
    </tr>
</table>

`String#indexOf(..)`
    在字符串中找到指定子字符串的位置

`String#charAt(..)`
    获得字符串中指定位置上的字符

`String#substr(..)`，`String#substring(..)`，和` String#slice(..)`
    获得字符串的指定部分

`String#toUpperCase()`和`String#toLowerCase()`
    将字符串转换为大写和小写

`String#trim()`
    去掉字符串前后的空格，返回新的字符串

这些方法并不改变原字符串，而是返回一个新字符串。

所有字符串值都可以通过prototype delegation（参考本系列的*《this & Object Prototypes》*）来访问这些方法：

```
    var a = " abc ";
    
    a.indexOf( "c" ); // 3
    a.toUpperCase();  // " ABC "
    a.trim();         // "abc"
```

其他构造函数的prototype中包含它们各自类型特有的行为特征，比如：`Number#toFixed(..)`（将数字转换为指定长度的整数字符串），`Array#concat(..)`（合并数组）。所有的函数（function）都可以调用`Function.prototype`中的`apply(..)`，`call(..)`，和`bind(..)`。

但是有些原生原型并非普通的对象：

```
    typeof Function.prototype;          // "function"
    Function.prototype();               // it's an empty function!
    
    RegExp.prototype.toString();        // "/(?:)/" -- empty regex
    "abc".match( RegExp.prototype );    // [""]
```

要命的是这些原生原型甚至可以被修改（不光是添加属性）：

```
    Array.isArray( Array.prototype );   // true
    Array.prototype.push( 1, 2, 3 );    // 3
    Array.prototype;                    // [1,2,3]

    // don't leave it that way, though, or expect weirdness!
    // reset the `Array.prototype` to empty
    Array.prototype.length = 0;
```

这里`Function.prototype`是一个函数，`RegExp.prototype`是一个正则表达式，而`Array.prototype`是一个数组。很有意思是不是？

###使用原型作为默认值

`Function.prototype`是一个空函数，`RegExp.prototype`是一个“空”正则表达式（没有任何匹配），而`Array.prototype`是一个空数组，它们对于未赋值的变量来说是很好的缺省值。

例如：

```
    function isThisCool(vals,fn,rx) {
        vals = vals || Array.prototype;
        fn = fn || Function.prototype;
        rx = rx || RegExp.prototype;
        
        return rx.test(
            vals.map( fn ).join( "" )
        ); 
    }

    isThisCool();       // true
    
    isThisCool(
        ["a","b","c"],
        function(v){ return v.toUpperCase(); },
        /D/
    );                  // false
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从ES6开始我们不再需要使用<b> vals = vals || .. </b>这样的方式来设置缺省值了（见<b>第四章</b>），因为缺省值可以通过函数声明中的内置语法来设置（见<b>第五章</b>）。</td>
    </tr>
</table>

这样做有一点好处就是`.prototypes`已经创建好并且*只创建一次*。相比之下如果使用`[]`，`function(){}`，和`/(?:)/`作为缺省值，每次调用`isThisCool(..)`的时候这些缺省值都会被重新创建（具体取决于JS引擎，稍后可能被垃圾回收）。这样会造成内存和CPU资源的浪费。

还有一点需要注意，就是如果缺省值随后会被更改，就不要使用`Array.prototype`作为缺省值。上例中的`vals`是作为只读变量来使用，更改`vals`实际上是更改`Array.prototype`本身，这样会导致前面提到过的一系列问题！

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这里我们介绍了原生原型及其用途，使用时需要十分小心，特别是要对它们做更改时。详情请见<b>第167页，Appendix A一节的“Native Prototypes”</b>。</td>
    </tr>
</table>

###回顾

JavaScript为基本数据类型值提供了封装对象，也叫做原生函数（`String`，`Number`，`Boolean`等）。它们为基本数据类型值提供了其类型特有的方法和属性（`String#trim()`和`Array#concat(..)`）。

对于简单标量基本类型值，比方说`"abc"`，如果要访问它的`length`属性或者`String.prototype`方法，JS引擎会自动对该值进行封装（boxing，即用相应类型的封装对象来包装它）以实现对这些属性和方法的访问。

------

##第四章 强制类型转换

对JavaScript的类型和值有了一个更全面的了解之后，让我们来讨论一个极具争议性的主题：强制类型转换（coercion）。

`第一章`里讲过，有关强制类型转换是一个设计上的缺陷还是一个有用的特性的争论从JS诞生之日起就开始了。很多JS书籍将强制类型转换描述为怪异、危险、难懂的糟糕设计。

这里我们秉承本系列丛书的宗旨，不会因为它导致了种种问题就对其避而不谈，对于不懂的知识我们更应该迎难而上。

本章旨在全面介绍强制类型转换的优缺点（优点的确有！），让我们对它的运用有一个合理清晰的思路。

###值类型转换

将值从一种类型转换为另一种类型通常称为“类型转换”（type casting），这是指显式的情况，在隐式的情况下我们称为“强制类型转换”（coercion，具体如何转换由相关规则决定）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">JavaScript中强制类型转换总是返回标量基本类型值（见<b>第二章</b>），如：<b>string</b>，<b>number</b>，和<b>boolean</b>常量。强制类型转换不会返回<b>object</b>和<b>function</b>。在<b>第三章</b>中我们介绍过“封装”，即为标量基本类型值封装一个相应类型的对象，但这并非严格意义上的强制类型转换。</td>
    </tr>
</table>

也可以这样来区分：“类型转换”发生在静态类型语言的编译阶段（compile time），而“强制类型转换”发生在动态类型语言的运行时（runtime）。

然而在JavaScript中一般都将它们统称为*强制类型转换*，我自己则倾向于使用“隐式类型转换”（implicit coersion）和“显式类型转换”（explicit coercion）来区分。

它们之间的差别很明显：我们能够从代码中看出哪些地方是“显式类型转换”，而“隐式类型转换”则不那么明显，通常是某些操作产生的副作用。

例如：

```
    var a = 42;
    
    var b = a + "";         // implicit coercion
    
    var c = String( a );    // explicit coercion
```

针对变量`b`的强制类型转换是隐式的，由于`+`运算符的其中一个操作数是`string`，所以它是`string`拼接操作，而它的（隐式）副作用则是数字`42`被强制类型转换为相应的字符串值：`"42"`。

而`String(..)`则是显式地将`a`强制类型转换为`string`。

两者都是将数字`42`转换为字符串`"42"`。但它们各自不同的处理方式却成为了争论的焦点。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从技术角度来说，除了表面上的不同之外，它们在行为上还有一些细微的差别。我们将在下一章详细介绍，第87页<b>“Implicitly: Strings &lt;--&gt; Numbers”</b>。</td>
    </tr>
</table>

这里的“显式”和“隐式”，以及“明显的副作用”和“隐藏的副作用“都是*相对而言的*。

明白了`a + ""`是怎么回事之后，对我们来说它可能就是“显式”的。相反如果不知道`String(..)`可以用于`string`强制类型转换，对我们来说它可能就是“隐式”的。

我们是以普遍通行的标准来讨论“显式”和“隐式”，而不是以专家和JS规范的标准。如果你的理解与此有出入，还是以我们的为准。

要知道我们编写的代码大都是需要给别人看的。即便是JS高手也需要顾及其它不同水平的开发人员，考虑他们是否能读懂自己的代码，以及他们对于“显式”和“隐式”的理解是否和自己一致。

###抽象值操作

在介绍*显式*和*隐式*强制类型转换之前，我们需要掌握类型转换的基本规则（即`string`，`number`，和`boolean`之间的类型转换）。ES5规范第9节中定义了一些“抽象操作”（即“仅供内部使用的操作”）和转换规则。我们这里着重介绍`ToString`，`ToNumber`，和`ToBoolean`，附带讲一讲`ToPrimitive`。

####ToString

规范第9.8节中定义了抽象操作`ToString`，它负责处理非`string`值到`string`值的强制类型转换。

内建基本类型值有自己的字符串化操作（stringification）：`null`转换为`"null"`，`undefined`转换为`"undefined"`，`true`转换为`"true"`。`number`的字符串化则遵循通用规则，不过`第二章`中介绍过的那些极小和极大的`number`使用的是指数形式：

```
    // multiplying `1.07` by `1000`, seven times over
    var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;

    // seven times three digits => 21 digits
    a.toString(); // "1.07e21"
```

对于普通对象来说，除非特别指定，否则`toString()`（位于`Object.prototype.toString()`）返回的是其*内部*的`[[Class]]`属性值（见`第三章`），例如：`"[object Object]"`。

但是前面我们介绍过，如果对象有自定义的`toString()`方法，在将其转换为`string`时会调用此方法，用它的返回值作为结果值。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">将对象强制类型转换为<b>string</b>是通过<b>ToPrimitive</b>抽象操作来完成的（ES5规范第9.1节），在此略过，我们稍后将在<b>ToNumber</b>一节中详细介绍。</td>
    </tr>
</table>

`array`的缺省`toString()`方法经过了重新定义，它将所有单元值字符串化以后再用`","`连接起来：

```
    var a = [1,2,3];

    a.toString(); // "1,2,3"
```

`toString()`可以被人为显式调用，或者在需要将非`string`转换为`string`的时候会被自动调用。

####JSON字符串化

工具函数`JSON.stringify(..)`在将JSON对象序列化（serialize）为`string`时也用到了`ToString`。

请注意JSON字符串化并非严格意义上的强制类型转换，但因为其中也涉及到`ToString`规则，所以这里顺带介绍一下。

对于大部分简单值来说，JSON字符串化和`toString()`的效果基本相同，只不过它*返回的永远是一个`string`*：

```
    JSON.stringify( 42 );   // "42"
    JSON.stringify( "42" ); // ""42"" (a string with a
                            // quoted string value in it)
    JSON.stringify( null ); // "null"
    JSON.stringify( true ); // "true"

```

所有*安全的JSON值（JSON-safe）*都可以使用`JSON.stringify(..)`来字符串化。安全的JSON值是指能够以JSON格式呈现的值。

为了便于理解，让我们来看看什么是不安全的JSON值。`undefined`，`function`，`symbol`（ES6+），和包含循环引用（对象之间相互引用，形成一个无限循环）的`object`，这些都是不符合JSON结构标准的非法值，因为支持JSON的语言无法处理它们。

`JSON.stringify(..)`碰到`undefined`，`function`，和`symbol`会自动忽略，如果在`array`中则返回`null`（从而保证单元位置索引不变），如果是对象属性则会忽略。

例如：

```
    JSON.stringify( undefined );        // undefined
    JSON.stringify( function(){} );     // undefined
 
    JSON.stringify(
       [1,undefined,function(){},4]
    );                                  // "[1,null,null,4]"
    JSON.stringify(
       { a:2, b:function(){} }
    );                                  // "{"a":2}"
```

对含有循环引用的对象执行`JSON.stringify(..)`会报错。

如果`object`中定义了`toJSON()`方法，JSON字符串化会首先调用该方法，然后用它的返回值来做序列化（serialization）。

如果要对含有非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义`toJSON()`方法以便得到一个安全的JSON值。

例如：

```
    var o = { };

    var a = { 
        b: 42,
        c: o,
        d: function(){}
    };

    // create a circular reference inside `a`
    o.e = a;
    
    // would throw an error on the circular reference
    // JSON.stringify( a );
    
    // define a custom JSON value serialization
    a.toJSON = function() {
        // only include the `b` property for serialization
        return { b: this.b };
    };
    
    JSON.stringify( a ); // "{"b":42}"
```

很多人误以为`toJSON()`方法一定会返回经过JSON字符串化的值。其实并不然，除非确实需要对`string`做字符串化（通常不会这样！）。`toJSON()`返回的应该是一个适用的值，可以是任何类型，然后再由`JSON.stringify(..)`对其进行字符串化。

换句话说，`toJSON()`应该是“返回一个能够被字符串化的安全的JSON值”，而不是“返回一个JSON字符串”。

例如：

```
    var a = {
        val: [1,2,3],

        // probably correct!
        toJSON: function(){
            return this.val.slice( 1 );
        }
    };
    
    var b = {
        val: [1,2,3],
        // probably incorrect!
        toJSON: function(){
            return "[" +
                this.val.slice( 1 ).join() +
            "]"; 
        }
    };
    
    JSON.stringify( a ); // "[2,3]"
    
    JSON.stringify( b ); // ""[2,3]""
```

上例的第二个函数是对`toJSON`返回的`string`做字符串化，而不是`array`本身。

这里我们介绍几个不太为人知但却非常有用的功能。

我们可以向`JSON.stringify(..)`传递可选参数（optional argument）*replacer*，可以是`array`或者`function`，它通过某种过滤机制来指定哪些属性应该被处理，哪些应该被排除，然后对结果进行序列化。它可以用来自定义对象的递归序列化，和`toJSON()`类似。

如果`replacer`参数是一个`array`，那么它必须是一个`string array`，其中包含序列化要处理的对象的属性名称。`array`之外的属性则被忽略。

如果`replacer`参数是一个`function`，它会对`object`本身调用一次，然后对`object`中的每个属性调用一次，每次传递两个参数，`key`和`value`。如果要忽略某个`key`就返回`undefined`，否则返回指定的*值*。

```
    var a = { 
        b: 42,
        c: "42",
        d: [1,2,3] 
    };
    
    JSON.stringify( a, ["b","c"] ); // "{"b":42,"c":"42"}"
    
    JSON.stringify( a, function(k,v){
        if (k !== "c") return v;
    } );
    // "{"b":42,"d":[1,2,3]}"
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">参数<i>replacer</i>为<b>function</b>时，它的参数<b>k</b>在第一次调用时为<b>undefined</b>（就是对对象本身的调用）。<b>if</b>语句将属性<b>"c"</b>排除掉。由于字符串化是递归的，因此数组<b>[1,2,3]</b>中的每个元素都通过参数<b>v</b>传递给*replacer*，即<b>1，2，和3</b>，参数<b>k</b>为它们的索引值，即<b>0，1，和2</b>。</td>
    </tr>
</table>

`JSON.string`还有第三个可选参数*space*，它用来指定输出格式的缩进。*space*为正整数时是指定每一级缩进的字符数，它还可以是字符串，此时最前面的10个字符被用来作为每一级的缩进：

```
    var a = { 
        b: 42,
        c: "42",
        d: [1,2,3] 
    };
    
    JSON.stringify( a, null, 3 );
    // "{
￼   //      "b": 42,
    //      "c": "42",
    //      "d": [
    //          1, 
    //          2,
    //          3
    //      ]
    // }"

    JSON.stringify( a, null, "-----" );
    // "{
    // -----"b": 42,
    // -----"c": "42",
    // -----"d": [
    // ----------1,
    // ----------2,
    // ----------3
    // -----]
    // }"
```

重要的话说两遍，`JSON.stringify(..)`本身并不属于强制类型转换。在这里介绍是因为它涉及`ToString`强制类型转换，具体表现在以下两点：

1. 字符串化`string`，`number`，`boolean`，和`null`与`ToString`强制类型转换遵循同样的规则。

2. 如果传递给`JSON.stringify(..)`的`object`中定义了`toJSON()`方法，那么`toJSON()`方法会在字符串化前调用，以便将`object`转换为*安全的JSON值*。

####ToNumber

有些情况下需要将非`number`值当作`number`来使用，比如数学运算。为此ES5规范在第9.3节定义了抽象操作`ToNumber`。

比如，`true`转换为`1`，`false`转换为`0`。`undefined`转换为`NaN`，`null`转换为`0`。

`ToNumber`对`string`的处理基本遵循`number`常量的相关规则／语法（见`第三章`）。处理失败时返回`NaN`（处理`number`常量失败时会产生语法错误）。一个不同之处是`ToNumber`对`0`开头的十六进制数并不按十六进制处理（而是按十进制，见`第二章`）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>number</b>常量的语法规则与<b>ToNumber</b>处理<b>string</b>所遵循的规则之间差别不大，这里不做进一步介绍，可参考ES5规范第9.3.1节。</td>
    </tr>
</table>

对象（和数组）首先被转换为相应的基本类型值，如果返回的是非`number`的基本类型值，就再遵循上述规则将其强制转换为`number`。

为了将值转换为相应的基本类型值，抽象操作`ToPrimitive`（见ES5规范第9.1节）会首先（通过内部操作`DefaultValue`，见ES5规范第8.12.8节）检查该值是否有`valueOf()`方法。如果有且返回的是基本类型值，就使用该返回值进行强制类型转换。如果没有就使用`toString()`的返回值（如果有的话）来进行强制类型转换。

如果两者都不返回基本类型值则会产生`TypeError`错误。

从ES5开始，使用`Object.create(null)`创建的对象`[[Prototype]]`属性为`null`，并且没有`valueOf()`和`toString()`方法，因此无法进行强制类型转换。详情请参考本系列的*《this & Object Prototypes》*一书中`[[Prototype]]`相关部分。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">我们稍后将详细介绍<b>number</b>的强制类型转换，在下面的示例代码中我们假定函数<b>Number(..)</b>已经实现了此功能。</td>
    </tr>
</table>

例如：

```
    var a = {
        valueOf: function(){
            return "42";
        }
    };
    
    var b = {
        toString: function(){
            return "42";
        }
    };
    
    var c = [4,2];
    c.toString = function(){
        return this.join( "" ); // "42"
    };

    Number( a );            // 42
    Number( b );            // 42
    Number( c );            // 42
    Number( "" );           // 0
    Number( [] );           // 0
    Number( [ "abc" ] );    // NaN
```

####ToBoolean

下面我们介绍`boolean`，有关这个主题存在着许多困惑和误解，需要特别注意。

首先也是最重要的一点，是JS有两个关键词`true`和`false`，分别代表`boolean`类型中的真和假。我们常常误以为数值`1`和`0`分别等同于`true`和`false`。在有些语言中可能确实如此，但在JS中`boolean`和`number`不同。虽然我们可以将`1`强制类型转换为`true`（反之亦然），将`0`强制类型转换为`false`（反之亦然），但它们不是一回事。

#####假值（Falsy values）

我们再来看看其它的值是如何被强制类型转换为`boolean`值的。

JavaScript中的值可以分为以下两类：

1. 可以被强制类型转换为`false`的值
2. 其他（可以被强制类型转换为`true`的值）

JS规范具体定义了一小撮可以被强制类型转换为`false`的值。

ES5规范第9.2节中定义了抽象操作`ToBoolean`，列出了`boolean`强制类型转换所有可能的结果。

以下是假值（“falsy”）：

- `undefined`
- `null`
- `false`
- `+0`，`-0`和`NaN`
- `""`

假值的`boolean`强制类型转换结果为`false`。

从逻辑上说，假值列表以外的值则会被转换为`true`，我们称为真值（“truthy”）。但JS规范对此并没有明确定义，只是给出了一些例子，例如明确规定所有的`object`都是真值，我们可以这样来理解：*假值列表以外的值都是真值*。

#####假值对象（Falsy objects）

这个标题似乎有点自相矛盾。前面讲过规范规定所有的`object`都是真值，怎么还会有假值对象呢？

有人可能会以为假值对象就是包装假值的封装对象（如：`""`，`0`，和`false`，见`第三章`），实际不然。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这只是规范给我们开的一个小玩笑。</td>
    </tr>
</table>

例如：

```
    var a = new Boolean( false );
    var b = new Number( 0 );
    var c = new String( "" );
```

它们都是封装了假值的对象（见`第三章`）。那它们是`true`还是`false`呢？答案很简单：

```
    var d = Boolean( a && b && c );
    
    d; // true
```

`d`的值为`true`，所以`a，b，c`都是`true`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">请注意Boolean(..)对<b>a &amp;&amp; b &amp;&amp; c</b>进行了封装，你可能会问为什么要这样。这里我们暂且记下，稍后会作说明。你可以试试不用Boolean(..)，看看<b>d = a &amp;&amp; b &amp;&amp; c</b>的结果是什么。</td>
    </tr>
</table>

如果“假值对象（falsy objects）”并非封装假值的对象，那究竟又是什么玩意？

有趣的是虽然JS代码中会出现`假值对象`，但是它实际上并不属于JavaScript语言的范畴。

在一些特定情况下，浏览器会自己创建一些*外来（exotic）*值，即“假值对象”。

“假值对象”看起来和普通对象并无二致（比如都包含属性），但`boolean`强制类型转换结果为`false`。

最常见的例子是`document.all`，它是一个类数组（array-like）对象，包含了页面上所有的元素，由*DOM*提供给JS程序使用（而非由JS引擎提供）。它曾经是一个真正意义上的对象，`boolean`强制类型转换结果为`true`，不过现在它是一个“假值对象”。

`document.all`并非标准用法，并且很早就被废止了。

有人也许会问：“既然这样，那浏览器能否将它彻底去除？”，想法是好的，只是很多JS程序仍然在使用它。

那为什么要让它成为假值呢？因为我们经常将`document.all`强制类型转换为`boolean`（比如在`if`语句中）来检测浏览器是否是老版本的IE。IE自诞生以来就一（cong）直 （wei）遵循浏览器标准，比其他浏览器更有（keng）力（die）地推动了Web的发展。

那些`if(document.all) { /* it's IE */ }`依然存在于许多程序中，并且可能会一直存在下去，对IE用户而言并非好的体验。

虽然我们无法彻底抛弃`document.all`，但为了让新版本更符合标准，IE并不打算继续支持`if (document.all) { .. }`。

“那我们应该怎么办呢？”，“也许我们可以修改JS的类型机制，将`document.all`作为假值处理！”。这并不是一个好主意。大多数JS开发人员对这个坑并不了解，不过更糟糕的是对其置若罔闻。

#####真值

真值就是假值列表之外的值。

例如：

```
    var a = "false";
    var b = "0";
    var c = "''";

    var d = Boolean( a && b && c );
    
    d;
```

这里`d`应该是`true`还是`false`呢？

答案是`true`。上例的`string`看起来象是`假值`，但所有`string`都是`真值`。`""`除外，它是`假值`列表中唯一的`string`。

再如：

```
    var a = [];             // empty array--truthy or falsy?
    var b = {};             // empty object--truthy or falsy?
    var c = function(){};   // empty function--truthy or falsy?

    var d = Boolean( a && b && c );
    
    d;
```

`d`依然是`true`。还是同样的道理，`[]`，`{}`，和`function(){}`都不在`假值`列表中，因此它们都是`真值`。

换句话说`真值`列表可以无限长，因而无法对其进行明确的定义，所以我们只能定义一个`假值`列表作为参照。

你可以花五分钟时间将`假值`列表写出来贴在显示器上，或者记在脑子里，这样遇到真／假值的时候就可以轻松做出判断。

真／假值的重点在于理解`boolean`强制类型转换（显式和隐式），之后我们就可以深入讨论强制类型转换的实例了。

####显式强制类型转换（Explicit Coercion）

*显式*强制类型转换是明显的类型转换，很多类型转换都属于此类。

编码时我们应该尽量将类型转换表达清楚，以免给别的开发人员留坑。代码越清晰可读性越高。

*显式强制类型转换*的好处毋庸置疑，它与我们所熟悉的静态语言的类型转换差不多，所以对它应该不存在什么非议。我们后面会再讨论这个话题。

#####字符串和数字之间的显式转换

让我们从最常见的`string`和`number`之间的强制类型转换开始。

`string`和`number`之间的转换使用的是`String(..)`和`Number(..)`这两个内建函数（称为“原生构造函数”，见`第三章`），注意它们前面不带`new`关键字，因此并不创建封装对象。

下面是两者之间的显式强制类型转换：

```
    var a = 42;
    var b = String( a );
    
    var c = "3.14";
    var d = Number( c );
    
    b; // "42"
    d; // 3.14
```

`String(..)`遵循前面介绍的`ToString`相关规则，将值转换为`string`基本类型。`Number(..)`遵循前面介绍的`ToNumber`相关规则，将值转换为`number`基本类型。

它们和静态语言的类型转换很相似，一看便知，所以将其归为*显式*强制类型转换。

例如在C/C++中我们可以使用`(int)x`或`int(x)`将`x`转换为整数。大多数人倾向后者，因为它看起来更象一个函数调用。JavaScript中的`Number(x)`与此非常类似，至于它是否真是一个函数并不重要。

除了`String(..)`和`Number(..)`外，还有其他方法可以实现`string`和`number`之间的“显式”类型转换：

```
    var a = 42;
    var b = a.toString();
    
    var c = "3.14";
    var d = +c;

    b; // "42"
    d; // 3.14
```

调用`a.toString()`的意图非常明显（“toString”意指“to a string”），不过这里涉及一些隐蔽的隐式转换。因为`toString()`对`42`这样的基本类型值不适用，所以JS引擎会自动为`42`创建一个封装对象（见`第三章`），然后在该对象上调用`toString()`。这里的显式转换中含有隐式转换。

上例中`+c`是`+`运算符的*一元（unary）*形式（即只有一个操作数）。`+`运算符显式地将`c`转换为`number`，而不是数学加法运算（也不是字符串拼接操作－－见下）。

那`+c`是不是显式强制类型转换呢？这取决于我们自己的经验和理解。如果我们已经明白一元运算符`+`会将操作数显式强制类型转换为`number`，那它就是显式的。如果我们不知道，那它就是让人费解的、有隐藏副作用的隐式强制类型转换。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">JS开源社区普遍认为一元运算<b>+</b>是<i>显式</i>强制类型转换。</td>
    </tr>
</table>

`+c`这样的用法很普遍，但有时候下也让人挠头。例如：

```
    var c = "3.14";
    var d = 5+ +c;

    d; // 8.14
```

一元运算符`-`和`+`类似，不过它还会将数字的符号位进行反转（flip）。不能用两个`-（--）`来撤销反转，因为`--`会被当作递减运算符来处理。应该采用`- -"3.14"`的方式，在中间加一个空格，这样结果才是`3.14`。

下面是一个让人抓狂的例子：

```
    1 + - + + + - + 1;  // 2
```

尽量不要把一元运算符`+`（和`-`）和其他运算符放在一起使用。上面的例子运行起来没问题，但并不是一个好方法。另外`d = +c`（和`d =+ c`）也很容易与`d += c`搞混，它们之间的区别大了去了。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">还有一个极易搞混的情况是一元运算符挨着<b>++</b>和<b>--</b>。例如<b>a +++b</b>，<b>a + ++b</b>，和<b>a + + +b</b>。有关<b>++</b>请参见<b>第125页“表达式的副作用”</b>。</td>
    </tr>
</table>

#####日期显式转换为数字

一元运算符`+`的另一个常见用法是将`Date`对象强制类型转换为`number`，其结果值是Unix时间戳，以微秒为单位（从1970年1月1日00:00:00 UTC起到现在的时间）：

```
    var d = new Date( "Mon, 18 Aug 2014 08:53:06 CDT" );

    +d; // 1408369986000
```

我们常用以下方式来获得当前的时间戳，例如：

```
    var timestamp = +new Date();
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">JavaScript中有一个特殊语法，即构造函数没有参数时可以不用带<b>()</b>。所以我们有时会碰到<b> var timestamp = +new Date; </b>这样的写法。这样做是否能提高代码可读性还存在争议，因为其只适用于<b> new fn() </b>，对一般的函数调用<b> fn() </b>并不适用。</td>
    </tr>
</table>

将`Date`对象转换为时间戳并非只有强制类型转换这一种方法，其它更显式的方法或许还更好一些：

```
    var timestamp = new Date().getTime();
    // var timestamp = (new Date()).getTime();
    // var timestamp = (new Date).getTime();
```

不过*最好*还是使用ES5中新加入的静态方法`Date.now()`：

```
    var timestamp = Date.now();
```

为老版本浏览器polyfill `Date.now()`也很简单：

```
    if (!Date.now) {
        Date.now = function() {
            return +new Date();
        };
    }
```

建议不要对`Date`类型使用强制类型转换，而应该用`Date.now()`来获得当前时间戳，用`new Date(..).getTime()`来获得指定时间的时间戳。

#####奇特的运算符~

`~`运算符（即字位操作“非”）也涉及强制类型转换，它即让人费解又常被人忽视，甚至熟悉它的开发人员也常对其敬而远之。秉承本书的一贯宗旨，让我们来深入探讨一下`~`有哪些用处。

在`“32位有符号整数”第23页`中我们介绍过字位运算符只适用于32位整数，即运算符会强制操作数使用32位格式。这一切都是通过抽象操作`ToInt32`来实现的（ES5规范第9.5节）。

`ToInt32`首先进行`ToNumber`强制类型转换，例如`"123"`会先被转换为`123`，然后再执行`ToInt32`。

虽然严格说来并非强制类型转换（因为返回值类型并没有发生变化），但字位运算符（比如`|`和`~`）和某些特殊`number`一起使用时会产生类似强制类型转换的效果，返回值为另一个`number`。

先来看看`|`运算符（字位操作“或”）的空操作（no-op）`0 | x`，此时仅执行`ToInt32`转换（在`第二章`介绍过）：

```
    0 | -0;         // 0
    0 | NaN;        // 0
    0 | Infinity;   // 0
    0 | -Infinity;  // 0
```

以上这些特殊数字无法以32位格式呈现（因为它们来自64位IEEE 754标准，见`第二章`），因此`ToInt32`对它们返回`0`。

至于`0 | ___`是*显式*还是*隐式*还存在争议。从规范的角度来说它无疑是*显式*的，但如果对字位运算符没有这样深入的理解，它可能就是*隐式*的。为了保证前后一致，这里我们将其视为*显式*。

再回到`~`。它首先将值“强制类型转换”为`32位数字`，然后执行字位操作“非”（对每一个字位进行反转）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这和<b>!</b>很相像，不仅将值强制类型转换为<b>boolean</b>，还对其做字位反转（见第83页的<b>“显式类型转换为Boolean”</b>）。</td>
    </tr>
</table>

字位反转这个主题太晦涩，JS开发人员一般也很少需要处理到字位级别。

`~`的另一定义源自早先的计算机科学和离散数学：`~`得到二的补码。这样解释就清楚多了！

`~x`和`-(x+1)`大致相同。虽然奇怪但比较容易理解：

```
    ~42;    // -(42+1) ==> -43
```

或许有人还是没有完全弄明白`~`是怎么回事，为什么我们会把它放在强制类型转换一章中，原因如下。

以`-(x+1)`为例。唯一能得到结果`0`（严格来说是`-0`）的`x`值是`-1`。

然而这与我们讨论的内容有什么关系呢？

`-1`通常称为“哨位值（sentinel value）”，指的是那些在各自类型中（这里是`number`）被赋予了特殊含义的值。在C语言中我们用`-1`来代表函数执行失败，用大于等于`0`的值来代表函数执行成功。

JavaScript中`string`的`indexOf(..)`方法也遵循此惯例，其在字符串中搜索指定的子字符串，如果找到则返回子字符串的位置（从0开始），否则返回`-1`。

`indexOf(..)`不仅用于获取子字符串的位置，还被用来检查字符串中是否包含指定的子字符串，相当于一个`boolean`判断。例如：

```
    var a = "Hello World";
    
    if (a.indexOf( "lo" ) >= 0) {   // true
        // found it!
    }
    if (a.indexOf( "lo" ) != -1) {  // true
        // found it }
    if (a.indexOf( "ol" ) < 0) {    // true
        // not found!
    }
    if (a.indexOf( "ol" ) == -1) {  // true
        // not found!
    }
```

`>= 0`和`== -1`这样的写法不是很好，属于“抽象渗漏（leaky abstraction）”，意思是在代码中暴露了底层的实现细节，这里是指用`-1`作为失败返回值，这些细节应该被隐藏。

现在我们终于明白`~`的用处了！`~`和`indexOf()`一起可以将结果“强制类型转换”（实际上只是转换）为真／假值：

```
    var a = "Hello World";
    
    ~a.indexOf( "lo" );         // -4 <-- truthy!
    
    if (~a.indexOf( "lo" )) {   // true
        // found it!
    }
    
    ~a.indexOf( "ol" );         // 0  <-- falsy!
    !~a.indexOf( "ol" );        // true
    
    if (!~a.indexOf( "ol" )) {  // true
        // not found!
    }
```

如果`indexOf(..)`返回`-1`，`~`将其转换为`假值0`，其他情况一律转换为`真值`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>-(x+1)</b>似乎意味着<b>~-1</b>的结果是<b>-0</b>，然而实际上结果是<b>0</b>，因为其是字位操作而非数学运算。</td>
    </tr>
</table>

从技术角度来说，`if (~a.indexOf(..))`仍然是对`indexOf(..)`的返回结果进行*隐式*强制类型转换，`0`转换为`false`，其他情况则为`true`。但我感觉`~`更象*显式*强制类型转换，前提是我对它有充分的理解。

个人认为`~`比`>= 0`和`== -1`更简洁。

#####字位截除

有些开发人员使用`~~`来截除（truncate）`number`值的小数部分，以为这和`Math.floor(..)`的效果一样，实际上并非如此。

`~~`中的第一个`~`执行`ToInt32`并反转字位，然后第二个`~`再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是`ToInt32`的结果。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>~~</b>和<b>!!</b>很相似，我们将在<b>第83页的“显式转换为Boolean”</b>一节中介绍。</td>
    </tr>
</table>

对`~~`我们要特别小心。首先它仅适用于32位数字，更重要的是它对负数的处理与`Math.floor(..)`不同。

```
    Math.floor( -49.6 );    // -50
    ~~-49.6;                // -49
```

抛开它们之间的差异不谈，`~~x`能将值截除为一个32位整数。`x | 0`同样也可以，而且还显得更*简洁*。

出于运算符优先级（详见`第五章`）的考虑，我们更倾向于使用`~~x`：

```
    ~~1E20 / 10;        // 166199296
    1E20 | 0 / 10;      // 1661992960
    (1E20 | 0) / 10;    // 166199296
```

建议在自己充分掌握以及别人充分理解的前题下再使用`~`和`~~`进行“强制类型转换”。

#####显式解析数字字符串

解析`string`中的`number`类似于将`string`强制类型转换为`number`，返回的也是`number`。但它们之间仍有一些显著的差别。

例如：

```
    var a = "42";
    var b = "42px";

    Number( a );    // 42
    parseInt( a );  // 42
    
    Number( b );    // NaN
    parseInt( b );  // 42
```

对`string`中的`number`进行解析时*允许*`string`中含有非`number`字符，按从左到右的顺序，如果遇到非`number`字符则解析停止。然而`string`到`number`的强制类型转换*不允许*非`number`字符，否则会失败并返回`NaN`。

两者之间并非相互替代的关系。它们虽然相似，但用途不同。如果`string`右边的非`number`字符无关紧要，就可以使用解析。而`string`到`number`的强制类型转换要求`string`中所有的字符都是数字，象"42px"这样的`string`是不行的。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">解析字符串中的浮点数可以用<b>parseFloat(..)</b>函数。
        </td>
    </tr>
</table>

不要忘了`parseInt(..)`针对的是`string`值。向`parseInt(..)`传递`number`和其他类型的参数是没有意义的，比如：`true`，`function(){...}`，和`[1,2,3]`。

非`string`参数会首先被强制类型转换为`string`（见`第59页上的“ToString”`），依赖这类*隐式*强制类型转换并非上策，应该避免向`parseInt(..)`传递非`string`参数。

ES5之前`parseInt(..)`有一个导致了很多bug的坑。如果没有第二个参数来指定转换的基数（又称为radix），`parseInt(..)`会根据`string`的第一个字符来自行决定基数。

如果第一个字符是`x`或`X`，则转换为十六进制`number`。如果第一个字符是`0`，则转换为八进制`number`。

以'x'和'X'开头的十六进制相对来说还不是很容易搞错，八进制则不然。例如：

```
    var hour = parseInt( selectedHour.value );
    var minute = parseInt( selectedMinute.value );
    
    console.log(
       "The time you selected was: " + hour + ":" + minute
);
```

上面的代码看似没有问题。但是当小时数为`08`、分钟数为`09`时上例的结果为`0:0`，因为`8`和`9`都不是有效的八进制数。

解决办法很简单，*将第二个参数设置为10*即可：

```
    var hour = parseInt( selectedHour.value, 10 );
    var minute = parseInt( selectedMiniute.value, 10 );
```

从ES5开始`parseInt(..)`默认转换为十进制数，除非特别指定。如果代码需要在ES5之前的环境中运行，还是要记得将第二个参数设置为`10`。

#####解析非字符串

曾经有人发帖吐槽过`parseInt(..)`的一个坑：

```
    parseInt( 1/0, 19 ); // 18
```

我们想当然地认为（实际上是完全错误的）“如果第一个参数值为`Infinity`，解析结果也应该是`Infinity`”，返回`18`也太无厘头了。

抛开这个纯属虚构的例子不谈，我们来看看JS是否真有这么搞。 

首先一个错误是向`parseInt(..)`传递非`string`，这完全是在自找麻烦。这种情况下JS会将参数强制类型转换为它能够处理的`string`。

有人可能会觉得这毫无道理，`parseInt(..)`应该拒绝接受非`string`参数。这样的话它是否应该抛出一个错误？这是Java的做法。一想到JS代码中到处是抛出的错误，要在每个地方加上`try..catch`，我整个人都不好了。

那是不是应该返回`NaN`？也许吧，但是下面的情况又怎么办呢：

```
    parseInt( new String( "42") );
```

是否应该运行失败？因为它的参数也是一个非`string`。如果我们认为应该将该`String`封装对象拆封（unbox）为`"42"`，那么将非`string`参数`42`先转换为`"42"`，再解析回`42`也是可以的了？

这种半*显式*
、半*隐式*的强制类型转换很多时候非常有用。例如：

```
    var a = {
        num: 21,
        toString: function() { return String( this.num * 2 ); }
    };

    parseInt( a ); // 42
```

`parseInt(..)`先将参数强制类型转换为`string`再进行解析，这样做合情合理。传递垃圾参数得到垃圾结果，这并不是函数本身的问题。

`Infinity`（`1/0`的结果）怎么来处理最合理呢？有两个选择：`"Infinity"`和`"∞"`，JS选择了`"Infinity"`。

JS中所有的值都有一个缺省的`string`呈现，这样挺好，能够方便我们调试。

再来看看基数19？这显然是个玩笑话，我们在实际的JS代码中不会用到基数19。玩笑与否我们先不管，它的有效数字字符范围是`0-9`和`a-i`（区分大小写）。

回到`parseInt(1/0, 19)`。它实际上是执行`parseInt("Infinity", 19)`。第一个字符是"I"，以19为基数时值为`18`。第二个字符`"n"`不是一个有效的数字字符，解析到此为止，和`"42px"`中的`"p"`一样。

最后的结果是`18`，而非`Infinity`或者抛出错误。所以理解其中的工作原理对于我们学习JS是*非常重要*的。

下面是`parseInt(..)`其他一些看似奇怪实则不然的例子：

```
    parseInt( 0.000008 );       // 0   ("0" from "0.000008")
    parseInt( 0.0000008 );      // 8   ("8" from "8e-7")
    parseInt( false, 16 );      // 250 ("fa" from "false")
    parseInt( parseInt, 16 );   // 15  ("f" from "function..")
    
    parseInt( "0x10" );         // 16
    parseInt( "103", 2 );       // 2
```

实际上`parseInt(..)`的行为极具一致性和可预测性。使用得当的话都不会有问题。由于使用不当而产生一些莫名其妙的结果并非JavaScript本身的问题。

#####显式转换为Boolean

现在我们来看看从非`boolean`强制类型转换为`boolean`的情况。

与前面的`String(..)`和`Number(..)`一样，`Boolean(..)`（不带`new`）是一种显式的`ToBoolean`强制类型转换：

```
    var a = "0";
    var b = [];
    var c = {};

    var d = "";
    var e = 0;
    var f = null;
    var g;
    
    Boolean( a ); // true
    Boolean( b ); // true
    Boolean( c ); // true
    
    Boolean( d ); // false
    Boolean( e ); // false
    Boolean( f ); // false
    Boolean( g ); // false
```

虽然`Boolean(..)`是显式的，但并不常用。

和`+`（前面讲过）类似，一元运算符`!`显式地将值强制类型转换为`boolean`。*问题*是它同时还将真值反转为假值（或者相反）。所以将值显式地强制类型转换为`boolean`最常见的方法是使用`!!`，因为第二个`!`会将结果反转回原值：

```
    var a = "0";
    var b = [];
    var c = {};

    var d = "";
    var e = 0;
    var f = null;
    var g;

    !!a; // true
    !!b; // true
    !!c; // true

    !!d; // false
    !!e; // false
    !!f; // false
    !!g; // false
```

在`boolean`上下文，如`if(..)..`中，如果没有`Boolean(..)`和`!!`，上述的`ToBoolean`转换会*隐式*地进行。为了让代码更加清晰，建议使用`Boolean(..)`和`!!`来进行显式转换。

显式`ToBoolean`的另外一个用途，是在JSON序列化过程中将值强制类型转换为`true`或`false`：

```
    var a = [ 1,
            function(){ /*..*/ },
            2,
            function(){ /*..*/ }
    ];

    JSON.stringify( a ); // "[1,null,2,null]"

    JSON.stringify( a, function(key,val){
        if (typeof val == "function") {
            // force `ToBoolean` coercion of the function
            return !!val;
        }
        else {
            return val;
    } } );
    // "[1,true,2,true]"
```

下面的语法对于熟悉Java的人并不陌生：

```
    var a = 42;

    var b = a ? true : false;
```

三元运算符`? :`判断`a`是否为真，如果是则将变量b赋值`true`，否则赋值`false`。

表面上这是一个*显式*的`ToBoolean`强制类型转换，因为返回结果是`true`或者`false`。

然而其中包含*隐式*强制类型转换，因为`a`要首先被强制类型转换为`boolean`才能进行判断。这种情况称为“显式的隐式”，有害无益，要彻底杜绝。

建议使用`Boolean(a)`和`!!a`来进行显式强制类型转换。

####隐式强制类型转换

*隐式*强制类型转换（implicit coercion）指的是那些隐蔽的类型转换，产生的副作用（side effects）也不是很明显。换而言之，任何你觉得不明显的类型转换都是*隐式*类型转换。

*显式*强制类型转换旨在让代码更加清晰易读，而*隐式*强制类型转换则相反，会让代码晦涩难懂。

对强制类型转换的诟病大多是针对*隐式*强制类型转换。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><i>《JavaScript: The Good Parts》</i>的作者Douglas Crockford在许多场合和文章中都主张尽量不要使用强制类型转换。他认为<i>隐式</i>强制类型转换非常糟糕。然而看看他的代码我们就会发现他也大量使用了<i>隐式</i>和<i>显式</i>强制类型转换。他的不满大部分是针对<b>==</b>运算符，但在本章中你会发现其只是强制类型转换的冰山一角。</td>
    </tr>
</table>

问题是隐式强制类型转换真是如此不堪吗？它是不是JavaScript语言的设计缺陷？我们是否应该对其退避三舍？

大多数人或许会毫不犹豫地回答“是！”。

其实不然，请容我细细道来。

让我们从另一个角度来看看*隐式*强制类型转换究竟为何物、应该如何运用，而非仅将其视为“显式强制类型转换的对立面”，因为这样理解太过狭隘，并且忽略了它们之间一个重要而细微的差别。

我理解的*隐式*强制类型转换的目是减少冗余，让代码更简洁。

#####隐式简化

我们先来看看下面这个例子，它不是JavaScript代码，而是强类型语言伪代码（pseudo code）：

```
    SomeType x = SomeType( AnotherType( y ) )
```

变量`y`的值被转换为`SomeType`类型。问题是语言本身不允许直接将`y`转换为`SomeType`类型。于是我们需要一个中间步骤，先将`y`转换为`AnotherType`类型，然后再从`AnotherType`转换为`SomeType`。

如果语言本身允许这样：

```
    SomeType x = SomeType( y )
```

省去了中间步骤以后，类型转换是不是变得更简洁了。因为这些不必要的中间步骤可以也应该被隐藏。

也许有人会说在某些情况下这些中间步骤还是必要的。但是我认为通过语言本身或者定制方法来抽象和隐藏一些琐碎的细节，让代码更简洁易读，才是简化（simplification）的真正意义所在。

当然这些中间步骤仍然会在幕后某处发生。但是如果在代码中隐藏了这些细节，我们就可以专注于问题本身，这里是将变量`y`转换为`SomeType`类型。

虽然这个例子与JS的*隐式*强制类型转换并非完全是一码事，但这里我想表达的意思是，*隐式*强制类型转换同样可以用来提高代码可读性。

但凡事无绝对，*隐式*强制类型转换也会带来一些不好的东西，有时甚至超过它带来的好处。因此我们更应该学习如何避免这些不好的东西。

许多开发人员认为如果某个机制能够带来好处*A*但是同时又有坏处*Z*，为保险起见就干脆整个放弃。

我反对这种“因噎废食”的做法。不要因为我们看到的都是负面影响而想当然地认为*隐式*强制类型转换一无是处。它也有好的方面，希望越来越多的人能够发现并接受它。

#####字符串和数字之间的隐式转换

前面我们介绍了`string`和`number`之间的*显式*强制类型转换。现在说一说它们之间的*隐式*强制类型转换。我们先来看一些会导致*隐式*强制类型转换的操作。

通过重载（overloading），`+`运算符即能用于`number`加法，也能用于`string`拼接。那么JS如何知道我们要执行哪种操作呢？例如：

```
    var a = "42";
    var b = "0";

    var c = 42;
    var d = 0;
    
    a + b; // "420"
    c + d; // 42
```

为什么会得到`"420"`和`42`两个不同的结果？常见的误解是，因为某个或者两个操作数都是`string`，所以`+`进行的是`string`拼接。这样理解部分正确，实际情况要复杂得多。

例如：

```
    var a = [1,2];
    var b = [3,4];

    a + b; // "1,23,4"
```

`a`和`b`都不是`string`，但是它们都被强制转换为`string`然后进行拼接。这是为什么呢？

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">下面两段内容来自规范，如果太难理解可以跳过。</td>
    </tr>
</table>

根据ES5规范第11.6.1节，如果某个操作数为`string`，或者能够通过以下步骤得到`string`值的话，`+`将进行拼接操作。如果`+`的其中一个操作数为`object`（包括`array`），则首先对该操作数调用`ToPrimitive`抽象操作（第9.1节），该抽象操作接着调用`[[DefaultValue]]`（第8.12.8节），以`number`作为上下文。

如果我们多加留意会发现这和`ToNumber`抽象操作处理`object`的方式一样（见`第65页“ToNumber”`）。因为`array`的`valueOf()`操作无法产生简单基本类型值，所以它转而调用`toString()`来得到`string`值。因此上例中的两个数组变成了`"1,2"`和`"3,4"`。`+`将这两个`string`拼接起来返回：`"1,23,4"`。

简单说就是如果`+`的其中一个操作数是`string`（或者通过以上步骤可以得到`string`值），则执行`string`拼接。否则执行`number`加法。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">一个常被人们提到的坑是<b>[] + {}</b>和<b>{} + []</b>，它们的结果不同，分别是"[object Object]"和0。我们将在<b>第134页的“代码块”一节</b>详细介绍。</td>
    </tr>
</table>

这意味着我们可以通过和空`string ""`的`+`操作来将`number`转换为`string`：

```
    var a = 42;
    var b = a + "";
    
    b; // "42"
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;"><b>+</b>作为数字加法操作是可互换的，即<b>2 + 3</b>等同于<b>3 + 2</b>。作为字符串拼接操作则不行，但对于空字符串""来说，<b>a + ""</b>和<b>"" + a</b>的结果是一样的。</td>
    </tr>
</table>

`a + ""`这样的*隐式*转换极为常见。有意思的是许多批评*隐式*强制类型转换的人也这样做。

这很能说明问题，无论怎样为人诟病，*隐式强制类型转换*仍然有它的用武之地。

比较`a + ""`（隐式）和之前介绍过的`String(a)`（显式），两者之间有一个细微的差别需要注意。根据`ToPrimitive`抽象操作的工作原理，`a + ""`会对`a`调用`valueOf()`方法，然后返回值通过`ToString`抽象操作转换为`string`。而`String(a)`则是直接调用`ToString()`。

它们最终返回的都是`string`，但如果`a`不是`number`基本类型而是`object`，就有可能得到其它结果！

例如：

```
    var a = {
        valueOf: function() { return 42; },
        toString: function() { return 4; }
    };
    
    a + ""; // "42"
    
    String( a );    // "4"
```

如果代码中不存在匪夷所思的数据结构和操作，一般是不太可能碰到这个问题的，但是如果我们要为某些对象自定义`valueOf()`和`toString()`方法，就需要特别小心，因为这会影响到强制类型转换的结果。

再来看看反过来从`string`强制类型转换为`number`情况。

```
    var a = "3.14";
    var b = a - 0;
    
    b; // 3.14
```

`-`是数字减法运算符，因此`a - 0`会将`a`强制类型转换为`number`。也可以用`a * 1`和`a / 1`，因为这两个运算符也只适用于数字，不过这两种用法不太常见。

对`object`执行`-`操作和`+`类似：

```
    var a = [3];
    var b = [1];
    
    a - b; // 2
```

为了执行减法运算符`-`，`a`和`b`都需要转换为`number`，首先转换为`string`（通过`toString()`），然后再转换为`number`。

`string`和`number`之间的*隐式*强制类型转换真如大家所说的那样糟糕吗？我不这样认为。

`b = String(a)`（*显式*）和`b = a + ""`（*隐式*）各有各的好处，`b = a + ""`更常见一些。所以就算备受争议，*隐式*强制类型转换仍然有它存在的意义。

#####布尔值到数字的隐式强制类型转换

将复杂的`boolean`逻辑转换为数字加法时，*隐式*强制类型转换相当管用。这种情况并不多见，属于特殊情况的特殊处理。

例如：

```
    function onlyOne(a,b,c) {
        return !!((a && !b && !c) ||
            (!a && b && !c) || (!a && !b && c));
    }
    
    var a = true;
    var b = false;
    
    onlyOne( a, b, b ); // true
    onlyOne( b, a, b ); // true
    
    onlyOne( a, b, a ); // false
```

如果其中有且仅有一个参数为`true`（或者真值），函数`onlyOne(..)`返回`true`。它在条件判断中使用了*隐式*强制类型转换，其他地方则是*显式*的，包括最后的返回值。

但是如果有四个、五个、甚至二十个参数，上面的代码就很难处理了。

这时就可以使用从`boolean`到`number`（`0或1`）的强制类型转换：

```
    function onlyOne() {
        var sum = 0;
        for (var i=0; i < arguments.length; i++) {
            // skip falsy values. same as treating
            // them as 0's, but avoids NaN's.
            if (arguments[i]) {
                sum += arguments[i];
            }
        }
        return sum == 1;
    }
   
    var a = true;
    var b = false;
   
    onlyOne( b, a );                // true
    onlyOne( b, a, b, b, b );       // true
   
    onlyOne( b, b );                // false
    onlyOne( b, a, b, b, b, a );    // false
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">在<b>onlyOne(..)</b>中，除了使用loop循环，也可以直接使用ES5规范中的reduce(..)函数。</td>
    </tr>
</table>

我们通过`sum += arguments[i]`中的*隐式*强制类型转换，将真值（true/truthy）的转换结果`1`进行累加。如果有且仅有一个参数为`true`，累加结果为`1`，否则结果不为`1`，`sum == 1`条件不成立。

同样的功能也可以通过*显式*强制类型转换来实现：

```
    function onlyOne() {
        var sum = 0;
        for (var i=0; i < arguments.length; i++) {
            sum += Number( !!arguments[i] );
        }
        return sum === 1;
    }
```

`!!arguments[i]`首先将参数转换为`true`或`false`。因此非`boolean`参数也不会出问题，如：`onlyOne("42", 0)`（否则会发生`string`拼接，这样结果就不对了）。

参数转换为`boolean`后，再通过`Number(..)`*显式*强制类型转换为`0`或`1`。

这里使用*显式*强制类型转换会不会更好一些？注释说这样确实能够避免`NaN`带来的问题。但这最终取决于我们自身的需要。我个人觉得前者，即*隐式*强制类型转换，更为简洁（前提是我们不会传递`undefined`和`NaN`这样的值），而*显式*强制类型转换则会带来一些代码冗余。

总之如本书一贯强调的那样，一切都取决于我们自己的判断和权衡。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">无论是<i>隐式</i>还是<i>显式</i>，我们都能通过修改<b>onlyTwo(..)</b>或者<b>onlyFive(..)</b>来处理更复杂的情况，只需要将最后的条件判断从<b>1</b>改为<b>2</b>或者<b>5</b>。这比加入一大堆<b>&amp;&amp;</b>和<b>||</b>表达式要简洁的多。所以强制类型转换在这里还是很有帮助的。</td>
    </tr>
</table>

#####到布尔值的隐式强制类型转换

现在我们来看看到`boolean`的*隐式*强制类型转换，它最常见也最容易弄错。

请记住这里涉及*隐式*强制类型转换。`number`和`string`操作中的强制类型转换十分显而易见。

涉及`boolean`*隐式*强制类型转换的情况有：

1. `if (..)`语句中的条件判断表达式
2. `for ( .. ; .. ; .. )`语句中的条件判断表达式（第二个）
3. `while (..)`和`do..while(..)`循环中的条件判断表达式
4. `? :`中的条件判断表达式
5. 逻辑运算符`||`（逻辑或）和`&&`（逻辑与）左边的操作数（作为条件判断表达式）。

以上情况中的非`boolean`值会被*隐式*强制类型转换为`boolean`，遵循本章之前介绍过的`ToBoolean`抽象操作规则。

例如：

```
    var a = 42;
    var b = "abc";
    var c;
    var d = null;
    
    if (a) {
        console.log( "yep" );   // yep
    }

    while (c) {
        console.log( "nope, never runs" );
    }

    c = d ? a : b; 
    c;                          // "abc"
    
    if ((a && d) || c) {
        console.log( "yep" );   // yep
    }
```

上例中，非`boolean`值会被*隐式*强制类型转换为`boolean`值以便执行条件判断。

#####||和&&

`||`（逻辑或）和`&&`（逻辑与）运算符对你应该并不陌生，或许你会以为它们在JavaScript中的表现和其它语言差不多。

然而这里有一个十分重要却不太为人所知的细微差别。

实际上我不太愿意把它们叫做“逻辑运算符”，因为这不能完全体现它们的功能。更准确（也更冗长）的叫法应该是“选择器运算符（selector operators）”，或者“操作数选择器运算符（operand selector operators）”。

因为和其他语言不同，它们在JavaScript中的返回值并非`boolean`。

它们返回两个操作数中的一个（且仅一个）。即选择两个操作数中的一个，然后返回它的值。

引述ES5规范第11.11节：

*&&和||运算符的返回值并不一定是`boolean`类型，而是两个操作数其中一个的值。*

例如：

```
    var a = 42;
    var b = "abc";
    var c = null;

    a || b;     // 42 
    a && b;     // "abc"
    
    c || b;     // "abc" 
    c && b;     // null
```

这是怎么回事？在C和PHP中它们的结果是`true`或`false`，在JS（以及Python和Ruby）中的结果却是操作数的值。

`||`和`&&`首先会对*第一个操作数*（`a`和`c`）进行`boolean`条件判断。如果不是`boolean`值（如上例）则执行`ToBoolean`强制类型转换以便执行条件判断。

对于`||`来说，如果条件判断结果为`true`则返回第一个操作数（`a`和`c`）的值。如果为`false`则返回第二个操作数（`b`）的值。

相反对于`&&`，如果条件判断结果为`true`则返回第二个操作数（`b`）的值。如果为`false`则返回第一个操作数（`a`和`c`）的值。

`||`和`&&`返回它们的其中一个操作数的值，而非条件判断的结果（其中可能涉及强制类型转换）。在`c && b`中`c`为`null`，是个假值，因而`&&`表达式的返回结果是`null`（即`c`的值），而不是条件判断的结果`false`。

现在你明白为什么把它们叫做“操作数选择器”了吧？

从另一个角度来理解：

```
    a || b;
    // 大致相当于(roughly equivalent to):
    a ? a : b;

    a && b;
    // 大致相当于(roughly equivalent to):
    a ? b : a;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">之所以说大致相当（roughly equivalent）是因为返回结果相同，但是它们之间存在一个细微的差别。在<b>a ? a : b</b>中，如果<b>a</b>是一个更为复杂的表达式（比如有副作用的函数调用等），则它有可能被执行两次（如果第一次结果为真）。相反在<b>a || b</b>中<b>a</b>只执行一次，其结果用于条件判断及返回值（如果适用的话）。<b>a &amp;&amp; b</b>和<b>a ? b : a</b>的情况也一样。</td>
    </tr>
</table>

下面是`||`一个十分常见的用法，也许你已经用过但并未完全理解：

```
    function foo(a,b) {
        a = a || "hello";
        b = b || "world";
     
        console.log( a + " " + b );
    }

    foo();                  // "hello world"
    foo( "yeah", "yeah!" ); // "yeah yeah!"
```

`a = a || "hello"`（又叫做C#“空合并运算符，null coallescing operator”的JavaScript版本）检查变量`a`，如果它未赋值（或者为假值），就赋予它一个缺省值（`"hello"`）。

但这里需要注意！

```
    foo( "That's it!", "" ); // "That's it! world" <-- Oops!
```

第二个参数`""`是一个`假值`（`falsy value`，见`第67页的“ToBoolean”`），因此`b = b || "world"`条件不成立，返回缺省值`"world"`。

这种用法极为常见，但是不能有`假值`，除非加入更多条件判断，或者转而使用`? :`三元表达式。

通过这种方式来设置`缺省值`很方便，甚至那些公开诟病JavaScript强制类型转换的人也在用。

再来看看`&&`。

有一种方法对于开发人员不太常见，但JS代码压缩工具经常使用。即如果第一个操作数为真值，则`&&`运算符“选择”第二个操作数作为返回值，这也叫做“守护运算符（guard operator）”（见`第五章``第140页的“短路（Short Circuited）”`）－－前面的表达式为后面的表达式“把关”：

```
    function foo() {
        console.log( a );
    }
    
    var a = 42;
    
    a && foo(); // 42
```

`foo()`只有在条件判断`a`通过时才会被调用。如果条件判断未通过，`a && foo()`就会悄然终止（也叫做“短路，short circuiting”），`foo()`不会被调用。

这样的用法对于开发人员不太常见，通常是用`if (a) { foo(); }`。但是JS代码压缩工具用的是`a && foo()`，因为更简洁。以后看到这样的代码我们就能知其所以然了。

`||`和`&&`有它们各自的用武之地，前提是我们理解且愿意在代码中使用*隐式*强制类型转换。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>a = b || "something"</b>和<b>a &amp;&amp; b()</b>使用到了“短路”机制，我们将在<b>第五章第140页的“短路”</b>一节中详细介绍。</td>
    </tr>
</table>

有人可能会问，如果返回的不是`true`和`false`，为什么`a && (b || c)`这样的表达式在`if`和`for`中没有出现问题。

问题或许不在于此，而在于他们不知道那些条件判断表达式最后还会执行`boolean`*隐式*强制类型转换。

例如：

```
    var a = 42;
    var b = null;
    var c = "foo";
    
    if (a && (b || c)) {
        console.log( "yep" );
    }
```

结果不出预料，除了一个细节，实际上`a && (b || c)`的结果是`"foo"`而非`true`，然后再由`if`将`foo`强制类型转换为`boolean`，所以最后结果为`true`。

现在明白了吧，这里发生了*隐式*强制类型转换。如果要避免*隐式*强制类型转换就得这样：

```
    if (!!a && (!!b || !!c)) {
        console.log( "yep" );
    }
```

#####Symbol强制类型转换

目前为止我们并没有发现*显式*和*隐式*强制类型转换产生的结果有明显不同，它们之间的差异仅仅体现在代码可读性方面。

但ES6中引入的symbol在强制类型转换时很容易出错，需要在这里介绍一下。ES6允许从`symbol`到`string`的*显式*强制类型转换，但相应的*隐式*强制类型转换则会产生`错误`，具体的原因不在本书讨论范围之内。

例如：

```
    var s1 = Symbol( "cool" );
    String( s1 );     // "Symbol(cool)"
   
    var s2 = Symbol( "not cool" );
    s2 + "";      // TypeError
```

`Symbol`不能被强制类型转换为`number`（`显式`和`隐式`都会产生`错误`），但可以被强制类型转换为`boolean`（`显式`和`隐式`结果都是`true`）。

由于规则缺乏一致性，我们需要对ES6中`symbol`的强制类型转换多加小心。

好消息是鉴于其用途（见`第三章`），我们不太可能经常碰到`symbol`强制类型转换。

####宽松相等和严格相等

宽松相等（loose equals）运算符`==`和严格相等（strict equals）运算符`===`都用来判断两个值是否“相等”，但是它们之间有一个非常重要的区别，特别是在判断条件上。

一个常见的误区是：“`==`检查值是否相等，`===`检查值和类型是否相等”。听起来蛮有道理，但是不太准确。很多JavaScript书籍和博客也是这样解释的，很遗憾他们都搞错了。

正确的解释是：“在相等比较中，`==`允许强制类型转换，而`===`不允许”。

#####相等比较操作的性能

我们来看一看两种解释的区别。

根据第一种解释（不准确的），`===`似乎比`==`做的事情更多一些，因为还需要检查值的类型。第二种解释中，`==`的工作量更大，因为如果值的类型不同还需要进行强制类型转换。

有人认为`==`比`===`更慢，实际上虽然强制类型转换的确需要花多点时间，但差别仅是微秒级（百万分之一秒）。

如果进行比较的两个值类型相同，则`==`和`===`使用相同的算法，所以除了JS引擎实现上的微小差别之外，它们之间并没有不同。

如果两个值类型不同，我们要考虑不是性能，而是有无进行强制类型转换的必要。

如果有必要就用`==`，没有就用`===`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>==</b>和<b>===</b>都会检查操作数的类型。区别在于操作数类型不同时它们的处理方式不同。</td>
    </tr>
</table>

#####抽象相等

ES5规范第11.9.3节的“抽象相等比较算法”定义了`==`运算符的工作机制。该算法既全面又简单，涵盖了所有可能出现的类型组合，以及每种组合的强制类型转换方式。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">这些“抽象相等（abstract equality）”规则正是<i>隐式</i>强制类型转换被诟病的原因。开发人员觉得它们过于晦涩，难以掌握和运用，并且弊（导致bug）大于利（提高代码可读性）。这种观点我不敢苟同，因为我的读者都是优秀的开发人员，整天与算法和代码打交道，“抽象相等”只是小菜一碟。不过我还是推荐大家去看一看ES5规范第11.9.3节，到时你会惊讶地发现这些规则是多么有道理。</td>
    </tr>
</table>

其中第一段（11.9.3.1）中规定如果两个值类型相同，就只比较它们的值是否相等。例如，`42`等于`42`，`"abc"`等于`"abc"`。

有几个非常规的情况需要注意：

- `NaN`不等于`NaN`（见`第二章`）。
- `+0`等于`-0`（见`第二章`）。 

11.9.3.1最后一段中定义了`object`（包括`function`和`array`）的宽松相等`==`。两个对象指向*同一个值*时视为相等。这里不涉及强制类型转换。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">严格相等<b>===</b>的定义和11.9.3.1一样，包括对象的相等比较。很少有人知道在比较两个对象的时候，<b>==</b>和<b>===</b>的工作原理是一样的。</td>
    </tr>
</table>

11.9.3中还规定，使用`==`来比较两个不同类型的值时会发生*隐式*强制类型转换，需要将两者其中之一或者全部转换为相同类型后再进行相等比较。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">宽松不相等（loose not-equality）<b>!=</b>的定义和我们设想的一样，即<b>==</b>的相反值。<b>!==</b>也同理。</td>
    </tr>
</table>

#####字符串和数字之间的相等比较

为了举例说明`==`，我们先来看看本章前面的有关`string`和`number`的例子：

```
    var a = 42;
    var b = "42";

    a === b;    // false
    a == b;     // true
```

不出我们所料，`a === b`为`false`，因为其中没有强制类型转换，`42`和`"42"`不相等。

而`a == b`是宽松相等，即如果两个值的类型不同，则对其中之一或全部进行强制类型转换。

这里的强制类型转换是怎样进行的呢？是`a`从`42`转换为`string`，还是`b`从`"42"`转换为`number`？

ES5规范11.9.3.4-5中是这样定义的：

```
1. 如果Type(x)是数字，Type(y)是字符串，则返回 x == ToNumber(y) 的结果。
2. 如果Type(x)是字符串，Type(y)是数字，则返回 ToNumber(x) == y 的结果。
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">规范中使用<b>Number</b>和<b>String</b>代表数字和字符串类型，而本书使用的是<b>number</b>和<b>string</b>。切勿将规范中的<b>Number</b>和原生函数<b>Number()</b>搞混。本书中类型名的首字符大写和小写是一回事。</td>
    </tr>
</table>

根据规范`"42"`应该被强制类型转换为`number`以便进行相等比较。相关规则，特别是`ToNumber`抽象操作的规则，我们前面已经介绍过。本例中两个值相等，均为`42`。

#####其他类型和布尔类型之间的相等比较

`==`最容易出错的地方之一是`true`和`false`与其他类型之间的相等比较。

例如：

```
    var a = "42";
    var b = true;

    a == b; // false
```

这是怎么回事？我们都知道`"42"`是一个真值（见本章前面的介绍）。为什么`==`的结果不是`true`呢？原因很简单但又不好理解，很容易让人掉坑里，很多JS开发人员并未对此引起足够的重视。

规范11.9.3.6-7是这样说的：

```
1. 如果Type(x)是布尔类型，则返回 ToNumber(x) == y 的结果。
2. 如果Type(y)是布尔类型，则返回 x == ToNumber(y) 的结果。
```

仔细看一下这个例子。首先：

```
    var x = true;
    var y = "42";

    x == y; // false
```

`Type(x)`是布尔类型，所以`ToNumber(x)`将`true`强制类型转换为`1`，变成`1 == "42"`，二者的类型仍然不同，根据规则`"42"`被强制类型转换为`42`，最后变成`1 == 42`，结果为`false`。

反过来也一样：

```
    var x = "42";
    var y = false;

    x == y; // false
```

`Type(y)`是布尔类型，所以`ToNumber(y)`将`false`强制类型转换为`0`，然后`"42" == 0`再变成`42 == 0`，结果为`false`。

也就是说字符串`"42"`既不等于`true`，也不等于`false`。一个值怎么可以既非真值也非假值，这也太奇怪了吧？

提这样的问题本身就是错误的，实际情况并非如此。

`"42"`的确是一个真值，但`"42" == true`并非`boolean`值的比较和强制类型转换。`"42"`没有转换为`boolean`（`true`），而是`true`转换为`1`，`"42"`转换为`42`。

这里并不涉及`ToBoolean`，所以`"42"`是真值还是假值与`==`本身没有关系！

重点是要搞清楚`==`对不同的类型组合怎样处理。`==`两边的`boolean`值会被强制类型转换为`number`。

很奇怪不是吗？我个人建议无论什么情况，永远不要使用`== true`和`== false`。

请注意这里说的只是`==`，`=== true`和`=== false`不允许强制类型转换，所以并不涉及`ToNumber`转换。

例如：

```
    var a = "42";
    
    // bad (will fail!):
    if (a == true) {
        // .. 
    }
    
    // also bad (will fail!):
    if (a === true) {
        // .. 
    }
    
    // good enough (works implicitly):
    if (a) {
        // ..
    }
  
    // better (works explicitly):
    if (!!a) {
        // .. 
    }
    
    // also great (works explicitly):
    if (Boolean( a )) {
        // .. 
    }
```

如果不用`== true`和`== false`（也叫做`boolean`值的宽松相等）就不用担心这些坑了。

#####null和undefined之间的相等比较

`null`和`undefined`之间的`==`也涉及*隐式*强制类型转换。ES5规范11.9.3.2-3规定：

```
1. 如果x为null，y为undefined，则结果为true。
2. 如果x为undefined，y为null，则结果为true。
```

在`==`中`null`和`undefined`相等（它们也与其自身相等），除此之外的其他值都不存在这种情况。

这意味着`null`和`undefined`在宽松相等`==`中是一回事，相互间可以进行*隐式*强制类型转换：

```
    var a = null;
    var b;

    a == b;     // true
    a == null;  // true
    b == null;  // true
    
    a == false; // false
    b == false; // false
    a == "";    // false
    b == "";    // false
    a == 0;     // false
    b == 0;     // false
```

`null`和`undefined`之间的强制类型转换是安全和可预测的，上例中除`null`和`undefined`以外的其他值均无法得到假阳（false positive）结果。建议通过这种方式将`null`和`undefined`作为等同值来处理。

例如：

```
    var a = doSomething();
    
    if (a == null) {
        // ..
    }
```

条件判断`a == null`仅在`doSomething()`返回非`null`和`undefined`时才成立，除此之外的其他值都不成立，包括`0`，`false`和`""`这样的假值。

下面是*显式*的做法，其中不涉及强制类型转换，我个人感觉更繁琐一些（大概执行效率也更低一些）：

```
    var a = doSomething();

    if (a === undefined || a === null) {
        // ..
    }
```

在我看来，`a == null`这样的*隐式*强制类型转换在保证安全性的同时还能提高代码可读性。

#####对象和非对象之间的相等比较

关于对象（`object`／`function`／`array`）和标量基本类型（`string`／`number`／`boolean`）之间的相等比较，ES5规范11.9.3.8-9做如下规定：

```
1. 如果Type(x)是字符串或数字，Type(y)是对象，则返回x == ToPrimitive(y)的结果。
2. 如果Type(x)是对象，Type(y)是字符串或数字，则返回ToPromitive(x) == y的结果。
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这里只提到了字符串和数字，没有<b>布尔值</b>。原因是我们之前介绍过11.9.3.6-7中规定了<b>布尔值</b>会先被强制类型转换为数字。</td>
    </tr>
</table>

例如：

```
    var a = 42;
    var b = [ 42 ];
    
    a == b; // true
```

`[ 42 ]`首先调用`ToPromitive`抽象操作（见`第59页“抽象值操作”`），返回`"42"`，变成`"42" == 42`，然后又变成`42 == 42`，最后相等。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">之前介绍过的<b>ToPromitive</b>抽象操作的所有特性（如：<b>toString()</b>，<b>valueOf()</b>）在这里都适用。在数据结构很复杂需要自行定义<b>valueOf()</b>以便返回一个简单值进行相等比较的时候很有帮助。</td>
    </tr>
</table>

我们在`第三章`介绍了“拆封（unboxing）”，即打开封装对象（如：`new String("abc"）`），返回其中的基本数据类型值（`"abc"`）。`==`中的`ToPromitive`强制类型转换也是如此：

```
    var a = "abc";
    var b = Object( a );    // same as `new String( a )`

    a === b;                // false
    a == b;                 // true
```

`a == b`结果为`true`，因为`b`通过`ToPromitive`进行强制类型转换（也称为“拆封”，英文为unboxed或者unwrapped），并返回标量基本类型值`"abc"`，与变量`a`的值相等。

有一些值不在此列，原因是`==`中其它更优先的规则。例如：

```
    var a = null;
    var b = Object( a );    // same as `Object()`
    a == b;                 // false

    var c = undefined;      
    var d = Object( c );    // same as `Object()`
    c == d;                 // false
    
    var e = NaN;            
    var f = Object( e );    // same as `new Number( e )`
    e == f;                 // false
```

因为没有对应的封装对象（object wrapper），所以`null`和`undefined`不能够被封装（boxed），`Object(null)`和`Object()`均返回一个常规对象。

`NaN`能够被封装为数字封装对象，但拆封后的`NaN == NaN`返回`false`，因为`NaN`不等于`NaN`（见`第二章`）。

####边缘情况

我们已经全面介绍了`==`中的*隐式*强制类型转换（常规和非常规的情况），现在来看一下那些需要特别注意和避免的边缘情况。

首先来看看更改内置原生原型（built-in native prototypes）会导致哪些奇怪的结果：

```
    Number.prototype.valueOf = function() {
        return 3;
    };

    new Number( 2 ) == 3;   // true
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;"><b>2 == 3</b>不会有这种问题，因为<b>2</b>和<b>3</b>都是数字基本类型值，不会调用<b>Number.prototype.valueOf()</b>方法。而<b>Number(2)</b>涉及<b>ToPrimitive</b>强制类型转换，因此会调用<b>valueOf()</b>。</td>
    </tr>
</table>

让人头大。这也是强制类型转换和`==`被诟病的原因之一。但这并非JavaScript本身的问题，而是我们自身的问题。不要觉得“编程语言应该防止开发人员犯错”。

还有更诡异的情况：

```
    if (a == 2 && a == 3) {
        // ..
    }
```

你也许觉得这种情况不可能，因为`a`不可能同时等于`2`和`3`。但“同时”一词并不准确，因为`a == 2`在`a == 3`之前执行。

如果让`a.valueOf()`每次调用都产生副作用，比如第一次返回`2`，第二次返回`3`，就会出现这样的情况。实现起来很简单：

```
    var i = 2;
    
    Number.prototype.valueOf = function() {
        return i++;
    };
   
    var a = new Number( 42 );
    
    if (a == 2 && a == 3) {
        console.log( "Yep, this happened." );
    }
```

再次强调千万不要这样做，也不要因此归咎于强制类型转换。对一种机制的滥用并不能成为诟病它的借口。我们应该正确合理地运用强制类型转换，避免这些极端的情况。

#####假值的相等比较

`==`中的*隐式*强制类型转换最为人诟病的地方是假值的相等比较。

下面分别列出了常规和非常规的情况：

```
    "0" == null;        // false
    "0" == undefined;   // false
    "0" == false;       // true -- 晕！
    "0" == NaN;         // false
    "0" == 0;           // true
    "0" == "";          // false

    false == null;      // false
    false == undefined; // false
    false == NaN;       // false
    false == 0;         // true -- 晕！
    false == "";        // true -- 晕！
    false == [];        // true -- 晕！
    false == {};        // false

    "" == null;         // false
    "" == undefined;    // false
    "" == NaN;          // false
    "" == 0;            // true -- 晕！
    "" == [];           // true -- 晕！
    "" == {};           // false

    0 == null;          // false
    0 == undefined;     // false
    0 == NaN;           // false
    0 == [];            // true -- 晕！
    0 == {};            // false
```

以上二十四种情况中有十七种比较好理解。比如我们都知道`""`和`NaN`不相等，`"0"`和'0'相等。

然而有七种情况加了注释“晕！”，因为它们属于假阳（false positive）的情况，里面坑很多。`""`和`0`明显是两个不同的值，它们之间的强制类型转换很容易搞错。请注意这里不存在假阴（false negatives）的情况。

#####极端情况

这还不算完，还有更极端的例子：

```
    [] == ![]   // true
```

事情变得越来越疯狂了。这看起来象是真值和假值之间的相等比较，结果不应该是`true`，因为一个值不可能同时既是真值也是假值！

事实并非如此。让我们来看看`!`运算符都做了些什么？根据`ToBoolean`规则，它会进行`boolean`显式强制类型转换（同时反转奇偶校验位）。所以`[] == ![]`变成了`[] == false`。前面我们介绍过，`false == []`，所以最后的结果并不出人意料。

再来看看其他情况：

```
    2 == [2];       // true
    "" == [null];   // true
```

介绍`ToNumber`时我们讲过，`==`右边的值`[2]`和`[null]`会进行`ToPrimitive`强制类型转换，以便能够和左边的基本类型值（`2`和`""`）进行比较。因为`array`的`valueOf()`返回`array`本身，所以强制类型转换将对`array`进行字符串化（stringifying）。

第一行中`[2]`会转换为`"2"`，然后通过`ToNumber`转换为`2`。第二行中`[null]`会直接转换为`""`。

最后的结果是`2 == 2`和`"" == ""`就不难理解了。

如果还是觉得头大，那么你的不解可能并非由于强制类型转换，而是`ToPrimitive`将`array`转换为`string`这一过程。你很可能没有想到`[2].toString()`返回的是`"2"`，`[null].toString()`返回的是`""`。

但是如果不这样处理的话又能怎样呢？我实在想不出其他更好的办法。或许应该将`[2]`转换为`"[2]"`，但这样的话在别的地方又显得很奇怪。

有人也许会觉得既然`String(null)`返回`"null"`，所以`String([null])`也应该返回`"null"`。想法确实有道理，这就是问题所在。

*隐式*强制类型转换本身不是问题的根源，因为`[null]`在*显式*强制类型转换中也是转换为`""`。问题在于将`array`转换为`string`是否合理，具体该如何处理。所以实际上这是`String([..])`规则的问题。或许`array`根本就不应该被转换为`string`？但这样一来又会导致很多其它问题。

还有一个常被提到的坑：

```
    0 == "\n";  // true
```

前面介绍过，`""`，`"\n"`（或者`" "`等其他空格组合）等空字符串被`ToNumber`强制类型转换为`0`。这样处理总没有问题了吧，不然你要咋整？

或许可以将空字符串和空格转换为`NaN`，这样`" " == NaN`就为`false`了，然而这并没有从根本上解决问题。

`0 == "\n"`导致程序出错的几率小之又小，不太容易碰到。

类型转换*总*会出现一些特殊情况，并非只有强制类型转换，任何编程语言都是如此。问题出在我们的臆断（有时也许碰巧对了！？），但这并不能成为诟病强制类型转换机制的理由。

上述七种情况基本涵盖了所有我们可能遇到的坑（除修改`valueOf()`和`toStrign()`的情况以外）。

与前面二十四种情况列表相对应的是下面这个列表：

```
    42 == "43";         // false
    "foo" == 42;        // false
    "true" == true;     // false
   
    42 == "42";         // true
    "foo" == [ "foo" ]; // true    
```

这些是非假值的常规情况（实际上还可以加上无穷大数字的相等比较），其中涉及的强制类型转换是安全、合理和好懂的。

#####完整性检查

我们深入介绍了*隐式*强制类型转换中的一些特殊情况。也难怪大多数开发人员都觉得太晦涩，唯恐避之不及。

现在我们回过头来做一下完整性检查（sanity check）。

前面列出了相等比较中的强制类型转换的7个坑，但另外还有至少十七种情况是绝对安全和容易理解的。

因为7棵歪脖树而放弃整片森林似乎有点因噎废食了。明智的做法是扬长避短。

再来看看那些*短*的地方：

```
    "0" == false;   // true -- 晕！
    false == 0;     // true -- 晕！
    false == "";    // true -- 晕！
    false == [];    // true -- 晕！
    "" == 0;        // true -- 晕！
    "" == [];       // true -- 晕！
    0 == [];        // true -- 晕！
```

其中有四种情况涉及`== false`，之前我们说过应该避免，这并不难掌握。

现在剩下三种：

```
    "" == 0;        // true -- 晕！
    "" == [];       // true -- 晕！
    0 == [];        // true -- 晕！
```

正常情况下我们应该不会这样写代码吧。

我想你应该不太可能会用`== []`来做条件判断，而是用`== ""`或者`== 0`，如：

```
    function doSomething(a) {
        if (a == "") {
            // .. 
        }
    }
```

如果不小心碰到`doSomething(0)`和`doSomething([])`这样的情况，结果会让你很惊讶。又如：

```
    function doSomething(a,b) {
        if (a == b) {
            // .. 
        }
    }
```

`doSomething("",0)`和`doSomething([],"")`也会产生意料之外的结果。

这些特殊情况会导致种种问题，需要我们多加小心，好在它们并不是十分常见。

#####安全地运用隐式强制类型转换

关键是我们要对`==`两边的值认真推敲。以下两个原则可以有效地避免错误：

- 如果两边的值中有`true`或者`false`，不要使用`==`。
- 如果两边的值中有`[]`，`""`或者`0`时，尽量不要使用`==`。

这时候最好用`===`，可以避免产生意外的强制类型转换。这两个原则可以让我们避开几乎所有强制类型转换的坑。

这时候的强制类型转换越显式越好，可以避免很多麻烦。

所以`==`和`===`选择哪一个取决于是否允许在相等比较中发生强制类型转换。

强制类型转换在很多地方非常有用，能够让相等比较更简洁（比如`null`和`undefined`）。

*隐式*强制类型转换在少数情况下的确很危险，这时为了安全起见就要使用`===`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">有一种情况下的强制类型转换是绝对安全的，那就是<b>typeof</b>操作。<b>typeof</b>总是返回七个字符串之一（见<b>第一章</b>），其中没有空字符串。所以在类型检查过程中不会发生隐式强制类型转换。<b>typeof x == "function"</b>是100%安全的，和<b>typeof x === "function"</b>一样。事实上两者在规范中是一回事。所以即不要盲从代码工具每一处都用<b>===</b>，更不要不管不问。我们要对自己的代码质量负责。</td>
    </tr>
</table>

*隐式*强制类型转换真的那么不堪吗？某些情况下是，但总的来说并不是。

做为一个成熟负责的开发人员，我们应该学会安全有效地运用强制类型转换（*显式*和*隐式*），并对周围的小伙伴言传身教。

Alex Dorey（GitHub用户名@dorey）在GitHub上制作了一张图表，列出了各种相等比较的情况，如`图4-1`。

![](figures/Figure4-1.png)

*图4-1. JavaScript中的相等比较*

####抽象关系比较

`a < b`中涉及的*隐式*强制类型转换不太引人注意，不过还是很有必要深入了解一下。

ES5规范11.8.5节定义了“抽象关系比较（Abstract Relational Comparison）”，分两部分：比较双方都是`string`（后半部分）的情况和其他的情况（前半部分）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">该算法仅针对<b>a &lt; b</b>，<b>a > b</b>会被处理为<b>b &lt; a</b>。</td>
    </tr>
</table>

比较双方首先调用`ToPrimitive`，如果结果出现非`string`则根据`ToNumber`规则将双方强制类型转换为`number`来进行比较。

例如：

```
    var a = [ 42 ];
    var b = [ "43" ];

    a < b;  // true
    b < a;  // false
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">前面介绍过的<b>-0</b>和<b>NaN</b>的相关规则在这里也适用。</td>
    </tr>
</table>

如果比较双方都是`string`则按字母顺序（natural alphabetic）来比较：

```
    var a = [ "42" ];
    var b = [ "043" ];
    
    a < b; // false
```

`a`和`b`并没有被转换为`number`，因为`ToPrimitive`返回的是`string`，所以这里比较的是`"42"`和`"043"`两个字符串，它们分别以`"4"`和`"0"`开头。因为`"0"`在字母顺序上小于`"4"`，所以最后结果为`false`。

同理：

```
    var a = [ 4, 2 ];
    var b = [ 0, 4, 3 ];
    
    a < b; // false
```

`a`转换为`"4, 2"`，`b`转换为`"0, 4, 3"`，也是按字母顺序进行比较。

再比如：

```
    var a = { b: 42 };
    var b = { b: 43 };
    
    a < b; // ??
```

结果还是`false`，因为`a`是`[object Object]`，`b`也是`[object Object]`，所以按照字母顺序`a < b`并不成立。

下面的例子就有些奇怪了：

```
    var a = { b: 42 };
    var b = { b: 43 };

    a < b;  // false
    a == b; // false
    a > b;  // false
    
    a <= b; // true
    a >= b; // true
```

为什么`a == b`的结果不是`true`？它们的`string`值相同（为`"[object Object]"`），按道理应该相等才对？实际上不是。你可以回忆一下前面介绍过的`object`的相等比较。

但是如果`a < b`和`a == b`的结果是`false`，为什么`a <= b`和`a >= b`的结果会是`true`呢？

因为根据规范`a <= b`被处理为`b < a`，然后将结果反转。因为`b < a`的结果是`false`，所以`a <= b`的结果是`true`。

这可能与我们设想的大相径庭，即`<=`应该是“小于或者等于”。实际上JS中`<=`是“不大于”的意思（即`!(a > b)`，处理为`!(b < a)`）。同理`a >= b`处理为`b <= a`。

相等比较有严格相等，而关系比较没有“严格关系比较（strict relational comparison）”。也就是说如果要避免`a < b`中发生*隐式*强制类型转换，我们只能确保`a`和`b`有相同的类型，除此之外别无他法。

与`==`和`===`的完整性检查一样，我们应该在必要和安全的情况下使用强制类型转换，如：`42 < "43"`。换句话说就是为了保证安全，应该对关系比较中的值进行*显式强制类型转换*：

```
    var a = [ 42 ];
    var b = "043";

    a < b;                      // false -- string comparison!
    Number( a ) < Number( b );  // true -- number comparison!
```

###回顾

本章中我们介绍了JavaScript的数据类型之间的转换，即`强制类型转换`，包括*显式*和*隐式*。

强制类型转换常常为人诟病，但实际上很多时候它们是非常有用的。作为一个有责任感的JS开发人员，我们有必要深入了解强制类型转换，这样就能取其精华，去其糟粕。

*显式*强制类型转换明确告诉我们哪里发生了类型转换，它的好处是有助于提高代码的可读性和可维护性。

*隐式*强制类型转换则没有那么明显，是其它操作的副作用。感觉上好象是*显式*强制类型转换的反面，实际上*隐式*强制类型转换也有助于提高代码的可读性。

处理强制类型转换时要十分小心，特别是*隐式*强制类型转换。我们在编码的时候要知其然，还要知其所以然，并努力让代码清晰易读。

------

##第五章 语法

语法（grammar）是本书要讨论的最后一个重点。或许你觉得自己已经会用JS编程了，但是JS语法中仍然有许多容易引起误解的地方，本章将对它们做深入的介绍。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">相比“词法（syntax）”，“语法（grammar）”对读者来说可能更陌生一些。很多时候它们是同一个意思，都是对语言<i>规则</i>的定义。虽然也有一些细微差别，但是在这里可以忽略不计。JavaScript语法定义了各种词法规则（syntax rules，如：运算符和关键词等等）怎样在一起构成可运行的程序代码。换句话说，只看词法不看语法将会漏掉很多重点。所以本章我们介绍的是语法（grammar），虽然与开发人员直接打交道的是词法（syntax）。</td>
    </tr>
</table>

###语句和表达式

开发人员常常将“语句（statement）”和“表达式（expression）”看作一回事，但在这里我们要将它们区分开来，因为在JS中它们之间有一些重要的差别。

读者应该对英语中的术语更熟悉，这里我们就借用它们来说明问题。

“句子（sentence）”是完整表达某个意思的一组词，由一个或多个“短语（phrase）”组成，它们之间由标点符号和连接词（“and”和“or”等）连接起来。短语可以包含更小的短语。有些短语是不完整的，本身不表达什么意思，有些短语则相对完整，并且能够独立表达某个意思。这些规则就是英语的*语法（grammar）*。

JavaScript的语法也是这样。语句相当于句子，表达式相当于短语，运算符则相当于标点符号和连接词。

JS中的表达式可以返回一个结果值。例如：

```
    var a = 3 * 6;
    var b = a;
    b;
```

上例中，`3 * 6`是一个表达式（结果为`18`）。第二行的`a`也是一个表达式，第三行的`b`也是。表达式`a`和`b`的结果值都是`18`。

这三行代码都是包含表达式的语句。`var = 3 * 6`和`var b = a`叫做“声明语句（declaration statement）”，因为它们声明了变量（也可以赋值）。`a = 3 * 6`和`b = a`（不带`var`）叫做赋值表达式。

第三行代码只有一个表达式`b`，同时它也是一个语句（虽然没有太大意义！）。这样的情况通常叫做“表达式语句（expression statement）”。

###语句的结果值

很多人不知道语句都有一个结果值（statement completion value，`undefined`也是一个结果值）。

获得结果值最直接的方法是在浏览器开发控制台中输入语句，默认情况下控制台会显示执行的最后一条语句的结果值。

以赋值表达式`b = a`为例，其结果值是赋给`b`的值（`18`），但规范定义`var`的结果值是`undefined`。如果在控制台中输入`var a = 42`会看到结果值为`undefined`，而非`42`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从技术角度来解释更复杂一些。ES5规范12.2节“变量语句”中的<b>变量声明（VariableDeclaration）</b>算法实际上有一个返回值（是一个包含所声明变量名称的字符串，很奇特吧！？），但是这个值被<b>变量语句（VariableStatement）</b>算法屏蔽掉了（<b>for..in</b>循环除外），最后返回结果为空（即<b>undefined</b>）。</td>
    </tr>
</table>

如果你用开发控制台调试过代码（或者JavaScript REPL－－read／evaluate／print／loop工具），应该会看到很多语句的返回值显示为`undefined`，只是你可能没有探究过其中的原因。其实控制台中显示的就是语句的结果值。

但在代码中是没有办法获得这个结果值的，具体办法比较复杂，我们先要搞清楚为什么要获得语句的结果值。

先来看看其他语句的结果值。比如代码块`{ .. }`的结果值是其最后一个语句／表达式的结果。

例如：

```
    var b;
    
    if (true) {
        b = 4 + 38;
    }
```

在控制台／REPL中输入以上代码应该会显示`42`，即最后一个语句／表达式`b = 4 + 38`的结果值。

换句话说就是代码块的结果值就如同一个*隐式的return*返回最后一个语句的结果值。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">与此类似，CoffeeScript中的函数也会隐式地返回最后一个语句的结果值。</td>
    </tr>
</table>

但下面这样的代码将无法运行：

```
    var a, b;
    
    a = if (true) {
        b = 4 + 38;
    };
```

因为语法不允许我们获得语句的结果值并将其赋值给另一个变量（至少目前还不行！）。

那应该怎样获得语句的结果值呢？

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">下面的代码仅为演示，不要在实际开发中这样做！</td>
    </tr>
</table>

我们可以使用万恶的`eval(..)`（又读作“evil”）来获得结果值：

```
    var a, b;

    a = eval( "if (true) { b = 4 + 38; }" );

    a;  // 42
```

这是个很不好的方法，但是能够让我们获得语句的结果值。

ES7规范有一项提案“do表达式（do expression）”，类似下面这样：

```
    var a, b;
    
    a = do {
        if (true) {
            b = 4 + 38; 
        }
    };

    a; // 42
```

上例中`do表达式`执行一个代码块（包含一个或多个语句），并且返回其中最后一个语句的结果值，然后赋值给变量`a`。

目的是把语句当作表达式来处理，语句中可以包含其他语句，不需要将语句封装为函数再调用`return`来返回值。

虽然目前还不是很重要，但随着JS语言的演进，语句的结果值可能会扮演越来越重要的角色，希望`do { .. }`表达式的引入能够减少我们对`eval(..)`这类方法的使用。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">重要的话再说一遍：不要使用eval(..)。详情见<b>《Scope &amp; Closures》</b>。</td>
    </tr>
</table>

###表达式的副作用

大部分表达式没有副作用。例如：

```
    var a = 2;
    var b = a + 3;
```

表达式`a + 3`本身没有副作用（比如改变`a`的值）。它的结果值为`5`，通过`b = a + 3`赋值给变量`b`。

最为常见的有副作用（也可能没有）的表达式是函数调用：

```
    function foo() {
        a = a + 1;
    }
    
    var a = 1;
    foo();      // 结果值: `undefined`, 副作用: `a`的值被改变
```

其它一些表达式也有副作用，比如：

```
    var a = 42;
    var b = a++;
```

`a++`做两件事，首先返回变量`a`的当前值`42`（再将该值赋给`b`），然后将`a`的值加一：

```
    var a = 42;
    var b = a++;

    a;  // 43
    b;  // 42
```

很多人会误以为变量`b`和`a`的值都是`43`，这是因为没有弄明白`++`运算符的副作用何时产生。

递增运算符`++`和递减运算符`--`都是一元运算符（unary operator，见`第四章`），它们可以出现在操作数的前面和后面：

```
    var a = 42;
    
    a++;    // 42
    a;      // 43
    
    ++a;    // 44
    a;      // 44
```

`++`在前面时，如：`++a`，它的副作用（将`a`递增）产生在表达式返回结果值之前，而`a++`的副作用产生在之后。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>++a++</b>会产生<b>ReferenceError</b>错误，因为运算符需要将产生的副作用赋值给一个变量。以<b>++a++</b>为例，它首先执行<b>a++</b>（根据运算符优先级，见下），返回<b>42</b>，然后执行<b>++42</b>，这时会产生<b>ReferenceError</b>错误，因为<b>++</b>无法在<b>42</b>这样的值上直接产生副作用。</td>
    </tr>
</table>

常有人误以为可以用括号`( )`将`a++`的副作用封装起来，例如：

```
    var a = 42;
    var b = (a++);

    a;  // 43
    b;  // 42
```

可惜不行，`( )`本身并不是一个封装表达式，不会在表达式`a++`产生副作用之后执行。即便可以，`a++`首先返回`42`，除非有表达式在`++`之后再次对`a`进行运算，否则还是不会得到`43`，`b`的值也不会是`43`。

不过有一个办法，可以用`,`（语句系列逗号运算符，statement-series comma operator）。它可以将多个独立的表达式语句串联成一个语句：

```
    var a = 42, b;
    b = ( a++, a );
    
    a;  // 43
    b;  // 43
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">由于运算符优先级的原因，<b>a++, a</b>需要放到<b>( .. )</b>中，本章后面将会介绍。</td>
    </tr>
</table>

`a++, a`中的第二个表达式`a`在`a++`之后执行，结果为`43`，并被赋值给`b`。

另一个例子是`delete`。我们在`第二章`中介绍过，`delete`用来删除`object`中的属性和`array`中的单元。通常它是以独立语句的形式出现：

```
    var obj = {
        a: 42
    };
    
    obj.a;          // 42
    delete obj.a;   // true
    obj.a;          // undefined
```

如果操作成功`delete`返回`true`，否则返回`false`。副作用是属性被从`object`中删除（或者单元从`array`中删除）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">操作成功是指对于那些不存在的以及存在且可配置（configurable，见本系列的《this &amp; Object Prototypes》第三章）的属性，delete返回true，否则返回false或者产生错误。</td>
    </tr>
</table>

最后一个有意思的例子是`=`赋值运算符。

例如：

```
    var a;
    
    a = 42;     // 42
    a;          // 42
```

`a = 42`中的`=`看上去没有副作用，实际上它的结果值是`42`，副作用是将`42`赋值给`a`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">组合赋值运算符，如<b>+=</b>和<b>-=</b>等，也同理。例如，<b>a = b += 2</b>先执行<b>b += 2</b>（即<b>b = b + 2</b>），然后结果值再被赋给<b>a</b>。</td>
    </tr>
</table>

在多个赋值语句串联（链式赋值，chained assignments）的时候，赋值表达式（和语句）的结果值就能派上用场，比如：

```
    var a, b, c;

    a = b = c = 42;
```

这里`c = 42`的结果值为`42`（副作用是`c`被赋值`42`），然后`b = 42`的结果值为`42`（副作用是`b`被赋值`42`），最后是`a = 42`（副作用是`a`被赋值`42`）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">链式赋值常常被误用，例如：<b>var a = b = 42</b>，这看起来和前面的例子差不多，实则不然。如果变量<b>b</b>没有在代码作用域中正式声明过，如：<b>（var b）</b>，则<b>var a = b = 42</b>不会对变量<b>b</b>进行声明。这在严格模式（strict mode）中会产生错误或者是无意中创建了一个全局变量（见本系列的<b>《Scope &amp; Closures》</b>一书）。</td>
    </tr>
</table>

另一个需要注意的地方是，很多开发人员喜欢这样：

```
    function vowels(str) {
        var matches;

        if (str) {
            // pull out all the vowels
            matches = str.match( /[aeiou]/g );

            if (matches) {
                return matches;
            } 
        }
    }
    
    vowels( "Hello World" ); // ["e","o","o"]
```

然而我们也可以通过赋值语句的副作用将两个`if`语句合二为一：

```
    function vowels(str) {
        var matches;

        // pull out all the vowels
        if (str && (matches = str.match( /[aeiou]/g ))) {
            return matches;
        }
    }

    vowels( "Hello World" ); // ["e","o","o"]
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">将<b>matches = str.match..</b>放到<b>( .. )</b>中是必要的。原因在<b>第137页“运算符优先级”</b>一节中会介绍。</td>
    </tr>
</table>

我偏向更简短的后者，因为它体现了两个条件的关联性。不过这只是个人偏好，无关对错。

###上下文规则

JavaScript语法规则有时对于同样的语法在不同的情况下有不同的解释。如果孤立地来理解这些规则会很吃力。

在这里我们不一一列举，只介绍一些常见情况。

####大括号

我们在下面两种情况下会用到大括号`{ .. }`（随着JS的演进会出现更多这样的情况）。

#####对象常量

用大括号定义`object`常量（object literals）：

```
    // assume there's a `bar()` function defined

    var a = {
        foo: bar()
    };
```

因为`{ .. }`被赋值给`a`，所以它是一个`object`常量。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>a</b>是赋值的目标，称为“左值”（l-value）。<b>{ .. }</b>是所赋的值（即本例中赋给变量<b>a</b>的值），称为“右值”（r-value）。</td>
    </tr>
</table>

#####标签

如果将上例中的`var a =`去掉会发生什么情况呢？

```
    // assume there's a `bar()` function defined
    {
        foo: bar()
    }
```

许多开发人员认为此处的`{ .. }`只是一个孤立的`object`常量，并没有被赋值。实际上完全不是这样。

`{ .. }`在这里只是一个普通的代码块。这在JavaScript中并不多见（在其他语言中则常见得多！），但在语法上是完全合法的，特别是和`let`（块作用域声明）一起使用时非常有帮助（见本系列的*《Scope & Closures》*一书）。

`{ .. }`的作用和`for`／`while`循环、`if`条件语句中的代码块基本相同。

但是foo: bar()`这样奇怪的语法怎么也是合法的呢？

这里涉及到JavaScript中一个不太为人知的特性（也不建议使用），叫“标签语句（labeled statements）”。`foo`是语句`bar()`的标签（后面没有`;`，请参见本章`第146页`上的`“自动分号”`）。

如果JavaScript有`goto`语句，理论上我们可以使用`goto foo`跳转到`foo`处执行。`goto`被普遍认为是一种十分糟糕的编码方式，它会让代码变得难以理解（也叫做“spaghetti code”），好在JavaScript不支持`goto`。

不过JS通过标签跳转（labeled jumps）能够实现一定程度上的`goto`。`continue`和`break`都可以带一个标签，因此能够象`goto`那样进行跳转。例如：

```
    // `foo` labeled-loop
    foo: for (var i=0; i<4; i++) {
        for (var j=0; j<4; j++) {
            // whenever the loops meet, continue outer loop
            if (j == i) {
                // jump to the next iteration of
                // the `foo` labeled-loop
                continue foo;
            }
            
            // skip odd multiples
            if ((j * i) % 2 == 1) {
                // normal (nonlabeled) `continue` of inner loop
                continue; 
            }
            
            console.log( i, j );
        }
    }
    // 1 0
    // 2 0
    // 2 1
    // 3 0
    // 3 2
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>contine foo</b>并不是指“跳转到标签<i>foo</i>所在的位置继续执行”，而是“执行标签为<i>foo</i>循环的下一轮循环”。所以这里的<b>foo</b>并非<b>goto</b>。</td>
    </tr>
</table>

我们可以看到`continue`跳过了循环`3 1`，`continue foo`（带标签的循环跳转，labeled-loop jump）跳过了`1 1`和`2 2`。

带标签的循环跳转用处更大的地方，是和`break __`一起可以实现从内层循环跳转到外层循环。没有它们的话实现起来有时会非常麻烦：

```
    // `foo` labeled-loop
    foo: for (var i=0; i<4; i++) {
        for (var j=0; j<4; j++) {
            if ((i * j) >= 3) {
                console.log( "stopping!", i, j );
                break foo; 
            }
            
            console.log( i, j );
        }
    }
    // 0 0
    // 0 1
    // 0 2
    // 0 3
    // 1 0
    // 1 1
    // 1 2
    // stopping! 1 3
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>break foo</b>的意思不是“跳转到标签<i>foo</i>所在位置继续执行”，而是“跳出标签<i>foo</i>所在的循环／代码块，继续执行后面的代码”。因此它并非传统意义上的<b>goto</b>。</td>
    </tr>
</table>

上例中如果用不带标签的`break`的话可能需要用到一两个函数调用和共享作用域的变量等，这样代码会更难懂，此时带标签的`break`或许是更好的选择。

标签也能用于非循环代码块，但只有`break`才可以。我们可以对带标签的代码块使用`break ___`，但是不能对带标签的非循环代码块使用`continue ___`，也不能对不带标签的代码块使用`break`：

```
    // `bar` labeled-block
    function foo() {
        bar: {
                console.log( "Hello" );
                break bar;
                console.log( "never runs" );
        }
        console.log( "World" );
    }

    foo();
    // Hello
    // World
```

带标签的循环／代码块十分少见，也不建议使用，比如循环跳转也可以通过函数调用来实现。不过在某些情况下它们也能派上用场，这时请务必把注释写清楚！

JSON被普遍认为是JS语言的一个子集，`{"a":42}`这样的JSON字符串会被当作合法的JS代码（请注意JSON属性名必须使用双引号！）。实际并非如此！如果你在控制台输入`{"a":42}`会报错。

这是因为标签不允许使用双引号，所以`"a"`并不是一个合法的标签，因此后面不能带`:`。

JSON的确是JS语法的一个子集，但是JSON本身并不是合法的JS语法。

这里存在一个十分普遍的误区，即如果通过`<script src=..>`标签加载JS文件，其中只包含JSON数据（比如某个API返回的结果），它就会被当作合法的JavaScript代码来解析，只不过没有办法被访问到（inaccessible）。JSON-P（通过把JSON数据封装为方法调用来解决这个问题，比如象`foo({"a":42})`）这样将JSON数据传递给函数）。

`{"a":42}`作为JSON值没有任何问题，但是在作为代码执行时会产生错误，因为它会被当作一个带有非法标签的语句块来执行。`foo({"a":42})`就没有问题，因为`{"a":42}`在这里是一个传递给`foo(..)`的`object`常量。因此准确地说是*JSON-P能将JSON转换为合法的JS语法*。

#####代码块

另一个常被提到的坑（涉及到强制类型转换，见`第四章`）是：

```
    [] + {}; // "[object Object]"
    {} + []; // 0
```

看似`+`运算符根据第一个操作数（`[]`或`{}`）的不同产生不同的结果。实际上不是！

第一行中的`{}`被当作一个值（空`object`）来处理。在`第四章`我们讲过，`[]`会被强制类型转换为`""`，`{}`会被强制类型转换为`"[object Object]"`。

但在第二行中，`{}`被当作一个独立的空代码块（不做任何事情）。代码块结尾不需要分号，所以这里语法没有问题。最后`+ []`将`[]`*显式强制类型转换*为`number`值`0`。

#####对象解构

从ES6开始，`{ .. }`也可用于“解构赋值（destructuring assignments）”（详情见本系列的*《ES6 & Beyond》一书*），特别是`object`的解构。例如：

```
    function getData() {
        // ..
        return {
            a: 42,
            b: "foo" 
        };
    }
    
    var { a, b } = getData();

    console.log( a, b ); // 42 "foo"
```

`{ a , b } = ..`即ES6中的解构赋值，功能相当于下面的代码：

```
    var res = getData();
    var a = res.a;
    var b = res.b;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>{ a, b }</b>实际上是<b>{ a: a, b: b }</b>的简化版本，两种写法都可以，只是<b>{ a, b }</b>更简洁。</td>
    </tr>
</table>

我们还可以使用`{ .. }`对函数的命名参数（named function arguments）做对象解构（object destructuring），方便从对象属性隐式地赋值：

```
    function foo({ a, b, c }) {
        // no need for:
        // var a = obj.a, b = obj.b, c = obj.c
        console.log( a, b, c );
    }

    foo( {
        c: [1,2,3],
        a: 42,
        b: "foo"
    } );    // 42 "foo" [1, 2, 3]
```

`{ .. }`在不同上下文中（context）的作用不同，这也是词法（syntax）和语法（grammar）的区别。掌握这些细节对我们了解JS引擎怎样解析代码很重要。

#####else if和可选代码块

很多人误以为JavaScript中有`else if`，因为我们可以这样来写代码：

```
    if (a) { 
        // ..
    }
    else if (b) {
        // .. 
    }
    else { 
        // ..
    }
```

这里涉及到一个不太为人所知的语法规则：JavaScript中没有`else if`，但如果`if`和`else`只包含单条语句，则代码块的`{ }`可以被省略。你一定见过这样的代码：

```
    if (a) doSomething( a );
```

很多JS代码检查工具建议对单条语句也应该加上`{ }`，如：

```
    if (a) { doSomething( a ); }
```

`else`也是如此，所以我们经常用到的`else if`*实际*上是这样的：

```
    if (a) { 
        // ..
    } 
    else {
        if (b) { 
            // ..
        } 
        else {
            // .. 
        }
    }
```

`if (b) { .. } else { .. }`实际上是前面那个`else`之后的一个单独语句，所以带不带`{ }`都行。换句话说就是`else if`不符合前面说的编码规范，`else`后面实际上是一个单独的`if`语句而已。

`else if`很常见，能够为我们省去一层代码缩进，所以很受欢迎。但这只是我们自己的发明创造，千万不要想当然地认为这些都是JS语法的一部分。

###运算符优先级

我们在`第四章`讲过，JavaScript中的`&&`和`||`返回它其中一个操作数的值，而不是`true`或`false`。这对于一个运算符两个操作数的情况比较好理解：

```
    var a = 42;
    var b = "foo";

    a && b; // "foo"
    a || b; // 42
```

如果是两个运算符三个操作数呢？

```
    var a = 42;
    var b = "foo";
    var c = [1,2,3];

    a && b || c; // ???
    a || b && c; // ???
```

我们需要了解超过一个运算符时表达式的执行顺序规则。

这些规则称为“运算符优先级（operator precedence）”。

估计大多数读者都觉得自己对运算符优先级已经了解得差不多了。现在我们就来做个测试，或许会有新的收获。

回顾前面的例子：

```
    var a = 42, b;
    b = ( a++, a );
    
    a;  // 43
    b;  // 43
```

如果去掉`( )`会出现什么情况呢？

```
    var a = 42, b;
    b = a++, a;

    a;  // 43
    b;  // 42
```

为什么`b`的值会不一样？

因为`,`运算符的优先级比`=`低。所以`b = a++, a`其实是`(b = a++), a`。前面说过`a++`有*后续副作用（after side effects）*，所以`b`的值是`++`对`a`做递增之前的值`42`。

这只是一个简单的例子。在使用`,`来连接一系列语句的时候，请务必记住它的优先级最低，其他操作数的优先级都比它高。

回顾前面的一个例子：

```
    if (str && (matches = str.match( /[aeiou]/g ))) {
        // ..
    }
```

这里对赋值语句使用`( )`是必要的，因为`&&`的优先级高于`=`，如果没有`( )`对其中的表达式进行绑定（bind），代码就会执行为`(str && matches) = str.match..`。这样会出错，因为`(str && matches)`的结果并不是一个变量，而是一个`undefined`值，它不能够出现在`=`的左边！

事情还没有完，再来看一个更复杂的例子（本章的下面几节都会用到）：

```
    var a = 42;
    var b = "foo";
    var c = false;

    var d = a && b || c ? c || b ? a : c && b : a;
    
    d;      // ??
```

看起来很恐怖，应该没有人会这样来写代码，不过这只是用来举例说明多个运算符串联时可能出现的一些常见问题。

上例的结果是`42`。当然我们运行一下代码就能够知道答案，但是弄明白其中的来龙去脉会更有趣。

首先要搞清楚`(a && b || c)`执行的是`(a && b) || c`还是`a && (b || c)`？它们之间有什么区别？

```
    (false && true) || true;    // true
    false && (true || true);    // false
```

事实证明它们是有区别的，`false && true || true`的执行顺序如下：

```
    false && true || true;      // true
    (false && true) || true;    // true
```

`&&`首先被执行，然后是`||`。

那执行顺序是否就一定是从左到右呢？将运算符颠倒一下看看：

```
    true || false && false;     // true

    (true || false) && false;   // false
    true || (false && false);   // true
```

事实证明`&&`先于`||`执行。原因是*运算符优先级*。

每门语言都有自己的运算符优先级。遗憾的是对JS的运算符优先级有深入了解的人不多。

如果明白其中的原由，上面的例子就是小菜一碟。但估计很多读者看到这几个例子时还是需要琢磨一番。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">遗憾的是JS规范对运算符优先级并没有一个集中的介绍。我们需要从语法规则中间逐一了解。所以我们在这里列出一些常见和有用的优先级规则。完整列表请参见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN</a>上的“优先级列表”。</td>
    </tr>
</table>

####短路

`第四章`的注解中提到过`&&`和`||`的“短路（short circuiting）”特性。这里我们对它做一个详细的介绍。

对于`&&`和`||`来说，如果能够从左边的操作数得出结果，就可以忽略右边的操作数。我们称之为“短路（short circuited）”（即执行最短路径）。

以`a && b`为例，如果`a`是一个假值，足以决定`&&`的结果，所以没有必要再判断`b`的值。同样对于`a || b`，如果`a`是一个真值，也足以决定`||`的结果，所以没有必要再判断`b`的值。

短路很好用，也很常用，如：

```
    function doSomething(opts) {
        if (opts && opts.cool) {
            // .. 
        }
    }
```

`opts && opts.cool`中的`opts`条件判断如同一层安全保护措施，因为如果`opts`未赋值（或者不是一个`object`），表达式`opts.cool`会出错。此时利用`短路`特性，`opts`条件判断未通过，所以`opts.cool`不会执行，也就不会产生错误！

`||`也同理：

```
    function doSomething(opts) {
        if (opts.cache || primeCache()) {
            // .. 
        }
    }
```

这里我们先判断`opts.cache`是否存在，如果是则无需调用`primeCache()`，这样可以避免执行不必要的代码。

####更紧密的绑定

让我们回顾下前面那个复杂的例子，即有很多运算符串联在一起。请特别注意`? :`三元运算符，它的优先级比`&&`和`||`高还是低，是这样？

```
    a && b || c ? c || b ? a : c && b : a
```

或是这样？

```
    a && b || (c ? c || (b ? a : c) && b : a)
```

还是这样？

```
    (a && b || c) ? (c || b) ? a : (c && b) : a
```

答案是第二种情况。

因为`&&`的优先级高于`||`，`||`的优先级又高于`? :`。

所以表达式`(a && b || c)`先于包含它的`? :`执行。另一种常见的说法，是`&&`和`||`比`? :`的结合性更强（bind more tightly）。如果反过来`c ? c...`的结合性更强，则它会首先执行（即` a && b || (c ? c..)`）。

#####关联性

运算符`&&`和`||`先执行，然后是`? :`。如果多个相同优先级的运算符同时出现呢？它们是否是按从左到右或者从右到左的顺序执行？

通常运算符不是从左到右关联（left-associative）就是从右到左关联（right-associative），取决于组合（grouping）是从左开始还是从右开始。

请注意关联性*不同*于从左到右和从右到左的执行顺序。

但是执行顺序和它又有什么关系呢？这是因为表达式会有副作用，比如函数调用：

```
    var a = foo() && bar();
```

这里`foo()`首先执行，然后根据它的返回结果，`bar()`有可能接着执行。所以如果`bar()`在`foo()`之前执行情况会完全不同。

这只是从左到右的情况（JavaScript的默认顺序！），与`&&`的关联性无关。因为上例中只有一个`&&`，所以不涉及组合，也不涉及关联性。

`a && b && c`这样的表达式就涉及到隐式组合，即`a && b`或者`b && c`会首先执行。

从技术角度来说，因为`&&`是左关联（`||`也是），所以`a && b && c`会被处理为`(a && b) && c`。然而右关联如`a && (b && c)`结果也一样。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">设想如果<b>&amp;&amp;</b>是右关联，它会被处理为<b>a &amp;&amp; (b &amp;&amp;c)</b>。但这并不代表<b>c</b>会在<b>b</b>之前执行。右关联的意思不是从右到左执行，而是从右到左进行<i>组合（grouping）</i>。任何时候执行顺序都是a，b，然后c，从左到右。</td>
    </tr>
</table>

所以`&&`和`||`是不是左关联这个问题本身并不重要，只要我们对它们有一个准确的定义。

但情况并非总是这样。有一些运算符左关联和右关联的表现截然不同。

比如运算符`? :`（即三元运算符或者条件运算符）：

```
    a ? b : c ? d : e;
```

`? :`是右关联的，它的组合顺序是下面哪一种呢？

```
• a ? b : (c ? d : e)

• (a ? b : c) ? d : e
```

答案是`a ? b : (c ? d : e)`。和`&&`和`||`的情况不同，右关联在这里会影响到返回结果，因为`(a ? b : c) ? d : e`对某些值（并非所有）的处理方式会有不同。

举个例子：

```
    true ? false : true ? true : true;      // false

    true ? false : (true ? true : true);    // false
    (true ? false : true) ? true : true;    // true
```

有些值的差别更加微妙，即使它们返回的结果相同。例如：

```
    true ? false : true ? true : false;     // false
    
    true ? false : (true ? true : false);   // false
    (true ? false : true) ? true : false;   // false
```

这里得到的结果相同，运算符组合看似没起什么作用。然而实际情况是这样的：

```
    var a = true, b = false, c = true, d = true, e = false;

    a ? b : (c ? d : e); // false, evaluates only `a` and `b`
    (a ? b : c) ? d : e; // false, evaluates `a`, `b` AND `e`
```

我们证实了`? :`的确是右关联，它串联的方式会影响返回结果。

右关联的另一个例子是`=`运算符。本章前面我们介绍过一个串联赋值的例子：

```
    var a, b, c;

    a = b = c = 42;
```

`a = b = c = 42`首先执行赋值表达式`c = 42`，然后是`b = ..`，最后是`a = ..`。其中原因就是右关联，实际上它是被处理为：`a = (b = (c = 42))`。

还记得本章前面那个复杂的赋值表达式吗？

```
    var a = 42;
    var b = "foo";
    var c = false;

    var d = a && b || c ? c || b ? a : c && b : a;
    
    d;      // 42
```

理解了运算符的优先级和关联性之后，现在我们可以根据组合规则将上面冗长的代码分解如下：

```
    ((a && b) || c) ? ((c || b) ? a : (c && b)) : a
```

或者通过缩进显式让其更容易理解：

```
    (
        (a && b)
            || 
        c
    )
        ?
    (
        (c || b)
            ? 
        a
            :
        (c && b)
    ) 
        :
    a
```

我们来逐个执行：

- (a && b) 结果为`"foo"`。
- `"foo" || c`结果为`"foo"`。
- 第一个`?`中，`"foo"`为真值。
- `(c || b)`结果为`"foo"`。
- 第二个`?`中，`"foo"`为真值。
- `a`的值为`42`。

最后结果是`42`。整个过程并不难，是吧？

#####释疑

现在你应该对运算符优先级（和关联性）有了一个深入的了解，也可以读懂多个运算符串联的代码了。

不过仍然有一个重要的问题：我们在编码时是否只需要遵守和理解运算符优先级和关联性的规则即可？是否该在必要时使用`( )`来自行控制运算符的结合和执行顺序？

换句话说，尽管这些规则可以通过学习来掌握，但其中也有很多坑，我们是否应避免单纯依赖这些优先级和关联性规则？如果答案是肯定的，我们是否应该使用`( )`来自行控制，而非依赖规则本身？

和`第四章`中的*隐式*强制类型转换一样，这是个很主观的话题。对于这两者大多数开发人员的看法都是：或者完全依赖于它们的规则来编码，或者彻底避免而使用显式和自行控制的方式。

和`第四章`不同，对这个问题我并没有一个确切的答案。我们已经介绍了它们各自的优缺点，希望能够帮助你加深理解，从而做出自己的判断。

我个人的观点是，依赖运算符优先级／关联性规则和使用`( )`自行控制运算符的结合两者都应兼顾，对`第四章`中的*隐式*强制类型转换也是如此，我们应该安全合理地运用它们，而非无节制地滥用。

不如我觉得`if (a && b && c) ..`没问题，就不需要用`if ((a && b) && c) ..`来明确关联性，因为这样过于繁琐。

然而如果需要串联两个`? :`运算符的话，我就会使用`( )`来自行控制运算符的组合，以便让代码更清晰易读。

这里我的建议和`第四章`一样：如果运算符优先级／关联性规则能够令代码更简洁，就用。如果自行加入`( )`有助于提高代码可读性，就用。

####自动分号

有时JavaScript会自动为代码行加上缺失的分号，即自动分号插入（ASI，Automatic Semicolon Insertion）。

因为如果代码缺失了必要的`;`将无法执行。这样一来语言的容错性就不是很高。ASI使得我们在某些情况下可以忽略那些（我们认为）不必要的`;`。

记住，ASI只在换行符（即line break）处起作用，不会在代码行的中间插入分号。

JS解析器在解析代码时，如果发现代码因为缺失分号可能导致错误，就会自动插入分号。并且只有代码行末尾与换行符之间除了空格和注释以外没有别的内容时，才会自动插入分号。

例如：

```
    var a = 42, b 
    c;
```

如何来解析`c`呢？假设`b`和`c`之间出现`a ,`的话（可以另起一行）,`c`会被作为`var`语句的一部分来处理。否则JS判断`b`之后应该出现`;`。因此`c;`被当作一个单独的表达式语句来处理。

又比如：

```
    var a = 42, b = "foo";
    
    a
    b // "foo"
```

这样的代码也没问题，不会产生错误，因为ASI也适用于表达式语句。

ASI在一些特定情况下很有用，比如：

```
    var a = 42;

    do {
            // ..
    } while (a) // <-- ; expected here!
    a;
```

语法规定`do..while`后必须带`;`，`while`和`for`则不需要。大部分人不记得这一点，此时ASI就会自动加上分号。

本章前面介绍过，语句代码块结尾不用带`;`，所以不需要ASI：

```
    var a = 42;
    
    while (a) {
        // ..
    } // <-- no ; expected here
    a;
```

其它涉及到ASI的地方是`break`，`continue`，`return`和`yield`（ES6）等关键字：

```
    function foo(a) {
        if (!a) return
        a *= 2;
        // .. 
    }
```

由于ASI会在`return`后自动加上`;`，所以这里的`return`语句并不包括第二行的`a *= 2`。当然`return`语句的跨度可以是很多行，但是其后必须有换行符以外的代码：

```
    function foo(a) {
        return (
            a * 2 + 3 / 12 
        );
    }
```

同样的规则对`break`，`continue`，和`yield`也适用。

####纠错

JS社区中最具争议的主题之一（除了tab和空格之争以外），是我们是该完全依赖ASI，还是尽量避免。

分号在大多数情况下（不是所有）并不是必须的，但是`for( .. ) ..`循环头部的两个分号是必须的。

正方认为ASI机制很有用，能够为我们省掉那些不必要的`;`（必要的情况不多），从而令代码更简洁。我们通常认为是ASI让很多`;`成为可选，所以只要代码没问题有没有`;`都一样。

反方则认为这里面有太多坑，特别是对于缺乏经验的初学者来说，自动插入`;`会无意中改变代码的逻辑。还有一些开发人员认为忽略分号本身就是错误的，他们倾向使用linter等工具来发现这些错误，而不是依赖于JS引擎。

我的理解是这样的，如果我们仔细阅读规范就会发现ASI实际上是一个“纠错（error correction）”机制。这里的错误是*解析器错误（parser error）*。换句话说就是让解析器容错性更高。

哪些情况下需要容错呢？在我看来解析器报错只有一个原因，就是代码有问题。ASI纠错过程中，只有一种情况下会遇到解析器报错，就是代码中缺少了那些必要的分号。

我的理解是，在代码中省略那些“不必要的分号”意味着“这些代码解析器无法解析，但是仍然可以运行”。

如果仅仅是为了省去一些键盘输入和追求“更美观的代码”，这样做显得有些得不偿失。

并且我也不觉得这和空格与tab之争是一回事，后者仅涉及代码的美观，前者则关系到是否应该遵循语法规则来编码，还是游离于规则之外。

换个角度来看，ASI实际上是将换行符视作有意义的“空格”。空格在其他语言如Python中是有意义的。但为JavaScript中的换行符赋予意义是否合适？

我的看法是应该在所有需要的地方加上分号，将对ASI的依赖降到最低限度。

我并不是一个人在战斗。早在2012年，JavaScript的创造者Brendan Eich这样说过：

*ASI是一个语法纠错机制。如果我们在编码中将换行符当作有意义的字符来对待，会遇到很多问题。我希望在1999年5月的那十天里（ECMAScript规范制定的时间），我能够让换行符承载更多的意义。切不要认为ASI真的会将换行符当作有意义的字符。*

####错误

JavaScript不仅有各种不同类型的运行时错误（`TypeError`，`ReferenceError`，`SyntaxError`等），它的语法规则也定义了一些编译时错误。

代码中某些特定的情况会被处理为“前期错误（early errors）”（编译时）。那些明显的语法错误就是前期错误的一种（如：`a = ,`），还有就是一些语法正确但规则不允许的情况。

代码执行之前，这些错误是无法用`try...catch;`来捕获的，因此它们会导致解析（parsing）／编译（compilation）错误。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">规范对于浏览器（和开发工具）怎样报错没有明确规定。因此下面的例子在不同的浏览器中的处理方式会有不同，包括错误类型和错误信息的显示。</td>
    </tr>
</table>

一个简单的例子是正则表达式常量中的语法。这里JS语法没有问题，但非法的正则表达式也会产生前期错误：

```
    var a = /+foo/;     // Error!
```

赋值对象必须是一个标识符（identifier，或者ES6中的解构表达式destructuring expression），因此下面的`42`是非法的，会报错：

```
    var a;
    42 = a;     // Error!
```

ES5规范的`严格（strict）`模式定义了更多的前期错误。比如在`严格`模式中，函数的参数不能重名：

```
    function foo(a,b,a) { }                 // just fine
    function bar(a,b,a) { "use strict"; }   // Error!
```

另一个`严格`模式前期错误是对象常量包含多个同名属性：

```
    (function(){
        "use strict";
        
        var a = { 
            b: 42,
            b: 43
        };          // Error!
    })();
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从语义角度来说，这些错误并非<i>词法错误（syntax errors）</i>，而是<i>语法错误（grammar errors）</i>－－因为它们在词法上是正确的。但是由于不存在<b>GrammarError</b>类型，一些浏览器也用<b>SyntaxError</b>来代替。</td>
    </tr>
</table>

####提早使用变量

ES6规范中有一个新概念叫做TDZ（Temporal Dead Zone，名字十分的不明觉厉）。

TDZ是指代码中的变量由于还没有初始化，所以在某些情况下不能使用。

最直观的例子是ES6规范中的`let`块作用域：

```
    {
        a = 2;      // ReferenceError!
        let a; 
    }
```

`a = 2`试图在`let a`初始化`a`之前使用该变量（作用域在`{ .. }`内），这是在`a`的TDZ内，会产生错误。

有意思的是对未声明（undeclared）的变量使用`typeof`却不会产生错误（参见`第一章`）：

```
{
    typeof a;   // undefined
    typeof b;   // ReferenceError! (TDZ)
    let b;
}
```

###函数参数

另一个违反TDZ规则的例子，是ES6中的参数缺省值（参见本系列的*ES6 & Beyond*）：

```
    var b = 3;

    function foo( a = 42, b = a + b + 5 ) {
        // ..
    }
```

`b = a + b + 5`试图在参数`b`的TDZ中访问`b`（并非函数外的那个`b`），因此会出错。然而访问`a`却没有问题，因为其刚好越过了参数`a`的TDZ。

在ES6中，如果某个参数被省略或者值为`undefined`，则使用它的缺省值：

```
    function foo( a = 42, b = a + 1 ) {
        console.log( a, b );
    }

    foo();              // 42 43
    foo( undefined );   // 42 43
    foo( 5 );           // 5 6
    foo( void 0, 7 );   // 42 7
    foo( null );        // null 1
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">在表达式<b>a + 1</b>中<b>null</b>被强制类型转换为<b>0</b>。详情请参见<b>第四章</b>。</td>
    </tr>
</table>

这里省略掉参数和传递`undefined`值效果是一样的。然而它们之间的区别还是可以通过某些形式体现出来：

```
    function foo( a = 42, b = a + 1 ) {
        console.log(
            arguments.length, a, b,
            arguments[0], arguments[1]
        );
    ￼}

    foo();                  // 0 42 43 undefined undefined
    foo( 10 );              // 1 10 11 10 undefined
    foo( 10, undefined );   // 2 10 11 10 undefined
    foo( 10, null );        // 2 10 null 10 null
```

虽然参数`a`和`b`都有缺省值，但是如果没有向函数传递参数则`arguments`为空。

相反如果向函数传递`undefined`值，则`arguments`数组中会对应出现一个单元，其值为`undefined`而非缺省值。

ES6的参数缺省值会导致`arguments`数组和命名参数变量之间出现偏差，同样的情况也会出现在ES5中：

```
    function foo(a) {
        a = 42;
        console.log( arguments[0] );
    }

    foo( 2 );   // 42 (linked)
    foo();      // undefined (not linked)
```

如果向函数传递参数，`arguments`数组中的对应单元会和命名参数建立关联（linkage）以获得相同的值。如果不传递参数就不会建立关联。

但是在`严格`模式中并没有建立关联这一说：

```
    function foo(a) {
        "use strict";
        a = 42;
        console.log( arguments[0] );
    }

    foo( 2 );   // 2 (not linked)
    foo();      // undefined (not linked)
```

所以依赖这种关联并不好，实际上它来自于JavaScript语言引擎的底层实现，语言本身并无此特性。

虽然并非一无是处，但`arguments`数组已经被废止（特别是ES6引入剩余参数`...`（rest parameters）之后，参见本系列的*《ES6 & Beyond》*）。

在ES6之前，获得传递给函数的所有参数的唯一途径就是`arguments`数组，它非常有用。我们还可以将命名参数和`arguments`数组混用，只要遵守一个原则就不会有问题，即*永远不要同时访问命名参数和其对应的`arguments`数组单元*。这样就能确保不会出现关联泄露（leaky linkage）：

```
   function foo(a) {
        console.log( a + arguments[1] ); // safe!
    }

    foo( 10, 32 );  // 42
```

####try..finally

我们对`try..catch`可能已经非常熟悉了。但你是否知道`try`可以与`catch`和`finally`其中之一配对使用，必要时两者也可以同时出现？

`finally`中的代码总是会在`try`（和`catch`，如果存在的话）之后执行。也可以将`finally`中的代码看作一个回调函数，无论出现什么情况最后一定会被调用。

`try`中如果包含`return`语句会出现什么情况呢？很显然`return`会产生一个返回值，那么调用该函数并获得这个返回值的代码是在`finally`之前执行还是之后呢？

```
    function foo() {
            try {
                return 42;
            } 
            finally {
                console.log( "Hello" );
            }

            console.log( "never runs" );
    }

    console.log( foo() );
    // Hello
    // 42
```

首先执行`return 42`，它将`foo()`函数的返回值设置为`42`。此时`try`执行完毕，`finally`接着执行。最后`foo()`函数执行完毕，它的返回值由`console.log(..)`显示。

`try`中的`throw`也是如此：

```
    function foo() {
        try {
            throw 42; 
        }
        finally {
            console.log( "Hello" );
        }

      console.log( "never runs" );
    }

    console.log( foo() );
    // Hello
    // Uncaught Exception: 42
```

如果`finally`中抛出一个异常（无论有意还是无意），函数就会在此处终结。如果`try`中已经有`return`设置了一个返回值，则该值会被丢弃：

```
    function foo() {
        try {
            return 42;
        } 
        finally {
            throw "Oops!";
        }

        console.log( "never runs" );
    }
    
    console.log( foo() );
    // Uncaught Exception: Oops!
```

`continue`和`break`也是如此：

```
    for (var i=0; i<10; i++) {
        try {
            continue; 
        }
        finally {
            console.log( i );
        }
    }
    // 0 1 2 3 4 5 6 7 8 9
```

`continue`使得`console.log(i)`在每次循环之后，`i++`之前执行，所以结果是`0..9`而非`1..10`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">ES6中新增了<b>yield</b>（参见本系列的<i>《Async &amp; Performance》</i>），可以将其视为<b>return</b>的中间版本。然而与<b>return</b>不同的是，yield在generator（ES6的另一个新特性）恢复时才告结束，这意味着<b>try { .. yield .. }</b>并未结束，因此对应的<b>finally</b>不会在<b>yield</b>之后立即执行，这一点和<b>return</b>不同。</td>
    </tr>
</table>

`finally`中的`return`将会覆盖`try`和`catch`中的`return`的返回值：

```
    function foo() {
        try {
            return 42;
        } 
        finally {
            // no `return ..` here, so no override
        } 
    }
    
    function bar() {
        try {
            return 42;
        }
        finally {
            // override previous `return 42`
            return; 
        }
    }

    function baz() {
        try {
            return 42;
        } 
        finally {
            // override previous `return 42`
            return "Hello";
        }
    }

    foo();  // 42
    bar();  // undefined
    baz();  // Hello
```

通常来说，在函数中省略`return`与`return;`和`return undefined;`结果是一样的，但是在`finally`中省略`return`则会返回前面的`return`值。

我们还可以将`finally`和带标签的`break`混合使用（参见`第131页的“标签”`）：

```
    function foo() {
        bar: {
            try {
                return 42;
            } 
            finally {
                // break out of `bar` labeled block
                break bar;
            }
        }
        
        console.log( "Crazy" );
        
        return "Hello";
    }

    console.log( foo() );
    // Crazy
    // Hello
```

千万不要这样做。用`finally`加`break`来跳过`return`会让代码变得非常难以理解。即便加上注释也很难解释清楚。

####switch

我们来简单介绍一下`switch`，可以把它看作`if..else if..else..`的简化语法：

```
    switch (a) {
        case 2:
            // do something
            break;
        case 42:
            // do another thing
            break;
        default:
            // fallback to here
    }
```

这里`a`与`case`表达式中的值逐一进行比较（本例中仅是简单的值表达式）。如果找到匹配的值就执行对应`case`中的代码，直到`break`或是`switch`代码块结束。

看起来没有什么特别，但`switch`也有几处不太为人知的坑。

首先`a`和`each`是通过`===`（见`第四章`）来进行相等比较。多数情况下`switch`中的`case`都是使用简单的值，所以这样并没有问题。

然而有时我们可能需要通过强制类型转换来进行相等比较（即`==`，见`第四章`），这时就要在`switch`中做一些特殊处理：

```
    var a = "42";

    switch (true) {
        case a == 10:
            console.log( "10 or '10'" );
            break;
        case a == 42;
            console.log( "42 or '42`" );
            break;
        default:
            // never gets here
    }
    // 42 or '42'
```

除了简单值之外，`case`中还可以出现各种表达式，它会将表达式的结果值和`true`进行比较。因为`a == 42`的结果为`true`，所以条件成立。

尽管可以使用`==`，但`switch`中`true`和`true`之间仍然是严格相等比较。即如果`case`表达式的结果为真值，但不是严格意义上的`true`（见`第四章`），则条件不成立。所以如果在这里使用`||`和`&&`“逻辑运算符”就很容易掉坑里：

```
    var a = "hello world";
    var b = 10;

    switch (true) {
        case (a || b == 10):
            // never gets here
            break;
        default:
            console.log( "Oops" );
    }
    // Oops
```

因为`(a || b == 10)`的结果是`"hello world"`而非`true`，所以严格相等比较不成立。这种情况下我们可以强制表达式返回`true`或`false`，如：`case !!(a || b == 10):`（见`第四章`）。

最后要说明`default`是可选的，并非必需（虽然惯例是如此）。有关`break`的规则对`default`仍然适用：

```
    var a = 10;

    switch (a) {
            case 1:
            case 2:
                    // never gets here
            default:
                    console.log( "default" );
            case 3:
                    console.log( "3" );
                    break;
            case 4:
                    console.log( "4" );
    }
    // default
    // 3
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">之前我们介绍过，case从句中的break也能够带标签。</td>
    </tr>
</table>

上例中的代码是这样执行的，首先遍历并找到所有匹配的`case`，如果没有匹配则执行`default`中的代码。因为其中没有`break`，所以继续执行已经遍历过的`case 3`代码块，直到`break`为止。

这种情况在JavaScript中是可能出现的，但是现实中一般不会发生。如果我们确实需要这样来编写代码，就应该仔细斟酌并做好注释。

###回顾

JavaScript语法规则中有许多细节需要我们花时间加以了解。长远来看这有助我们更加深入地掌握这门语言。

语句（statements）和表达式（expressions）在英语中有对应的称谓－语句就象句子（sentences），而表达式就象短语（phrases）。表达式可以是简单独立的，也可能产生副作用。

JavaScript语法规则中，单纯的语法规则之上是语义规则（也称作上下文）。例如，`{ }`在不同的情况下意义不尽相同，可以是语句块，`object`常量，解构赋值（ES6），或者命名函数参数（ES6）。

JavaScript详细定义了运算符的优先级（运算符执行的先后顺序）和关联性（表达式中的多个运算符如何组合）。一旦掌握了这些规则，我们就能够自己作出判断，是否通过它们来提高代码的易读性，或者因为它们过于晦涩而避之不及。

ASI（自动分号插入）是JS引擎中的一个代码解析纠错机制，在某些特定情况下它会在需要的地方自动插入分号来纠正解析错误。问题在于这是否意味着大多数的分号都不是必需的（因而可以被省略），或者由于省略分号而导致的错误都可以交给JS引擎来处理。

JavaScript中有很多错误类型，它们分为两大类：“早期错误”（编译时错误，无法被捕获）和“运行时错误”（可以通过`try..catch`捕获）。所有的语法错误都是早期错误，会导致程序无法运行。

函数参数和命名参数之间的关系非常微妙。尤其是`arguments`数组，由于它的抽象泄漏导致了一些坑的存在。尽量不要使用`arguments`，如果非要用的话也不要同时使用`arguments`及其对应的命名参数。

`try`（或者`try..catch`）结尾的`finally`的执行顺序的一些特点需要我们多加注意。其中有一些非常有用，但也会带来困扰，特别是和带标签的代码块配合使用时。总之使用`finally`的目的是让代码更简洁易读，而非适得其反。

`switch`相对`if..else if..`来说更简洁，但需要注意的是，我们对它的理解可能不是很透彻，如果不小心很容易掉到坑里。

------

###附录
<hr>
##混合环境JavaScript

除了我们之前介绍过的核心的语言机制，你的JS程序在实际运行中还会出现一些差异。如果JS程序仅是在引擎中运行的话，它是严格遵循规范并且可以预测的。但是JS程序几乎总是运行在宿主环境中，这使得它一定程度上变得不可预测。

例如当你的代码和其他第三方代码一起运行，或者当你的代码在不同的JS引擎上运行（并非仅仅是浏览器），在有些情况下会出现差异。

下面我们将就此做一些介绍。

###Annex B(ECMAScript)

JavaScript语言的官方名称是ECMAScript（指的是管理它的ECMA标准），这一点不太为人所知。那么“JavaScript”又是指什么呢？JavaScript是该语言的通用称谓，更确切地说，它是该规范在浏览器上的实现。

官方ECMAScript规范包括了“Annex B”，其中介绍了由于浏览器兼容性导致的与官方规范的差异。

可以这样来理解，这些差异只存在于浏览器中。如果你的代码只会在浏览器中运行，你不会发现任何差异。否则（如果代码也在node.js，Rhino等环境中运行），或者你也不确定的时候，就需要小心对待。

下面是一些主要的兼容性差异：

- 在非严格模式中允许八进制数值常量，如`0123`（十进制的`83`）。
- `window.escape(..)`和`window.unescape(..)`让你能够escape和unescape(JJ--??)带有%分隔符的十六进制字符串。例如：`window.escape("? foo=97%&bar=3%")`的结果为`"%3Ffoo%3D97%25%26bar%3D3%25"`。
- `String.prototype.substr`和`String.prototype.substring`十分相似，除了前者第二个参数是结束位置索引（非自包含），后者第二个参数是`长度`（需要包含的字符数）。

###Web ECMAScript

`Web ECMAScript规范`中介绍了官方ECMAScript规范和目前基于浏览器的JavaScript实现之间的差异。

换句话说，其中的内容对于浏览器来说是”必需的“（考虑到兼容性），但是没有包含在官方规范的”Annex B“部分（到本书写作时）：

- <!-- 和 -->是合法的单行注释符。
- `String.prototype`中返回HTML格式字符串的附加方法：`anchor(..)`，`big(..)`，`blink(..)`，`bold(..)`，`fixed(..)`，`fontcolor(..)`，`fontsize(..)`，`italics(..)`，`link(..)`，`small(..)`，`strike(..)`，和`sub(..)`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">以上的内容在实际开发中很少使用，也不推荐，我们相对更倾向使用其他的内建DOM API和自定义工具集。</td>
    </tr>
</table>

- `RegExp`扩展：`RegExp.$1 .. RegExp.$9`（匹配组）
和`RegExp.lastMatch/RegExp["$&"]`（最近匹配）。
- `Function.prototype`附加方法：`Function.prototype.arguments`（别名为`arguments`对象）和`Function.caller`（别名为`arguments.caller`）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warnning.png'></td>
        <td style="border: none;">arguments和arguments.caller均已经被废止，所以尽可能不要使用它们。也不要使用它们的别名。</td>
    </tr>
</table>

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">一些不常见和很细微的差异我们这里就不做介绍了。如有需要，详情可参考文档“Annex B”和“Web ECMAScript”。</td>
    </tr>
</table>

通常来说出现这些差异的情况很少，所以并不需要特别担心。只是在使用它们的时候要特别注意。

###宿主对象

JS中有关变量的规则定义得很清楚，但有时候也会出现例外情况，比如自动定义的变量，以及由宿主环境（浏览器等）提供给JS引擎的变量－我们称之为“宿主对象”（包括内建对象和函数）。

例如：

```
    var a = document.createElement( "div" );
    
    typeof a;                            // "object"--as expected
    Object.prototype.toString.call( a ); // "[object HTMLDivElement]"
    
    a.tagName;                           // "DIV"
```

`a`不仅仅是一个`object`，还是一个特殊的宿主对象，因为它是一个DOM元素。其内部的`[[Class]]`值（为`"HTMLDivElement"`）来自预定义的属性（通常也是不可更改的）。

另外一个难点我们之前在`第四章`中的“假值对象”部分介绍过：一些对象在强制转换为`boolean`时会意外地成为`假值`而非`真值`，这很让人挠头。

另外一些需要我们注意的宿主对象的行为差异有：

- 无法访问正常的`object`内建方法，如`toString()`
- 无法写覆盖
- 包含一些预定义的只读属性
- 包含一些无法被其他对象this重载(JJ--??)的方法
- 其他......

在我们针对运行环境编码时，宿主对象扮演着一个十分关键的角色。但是我们对它们的特性要非常注意，因为它们常常有别于普通的JS`object`。

在我们经常打交道的宿主对象中，`console`应该是比较值得一提的，它包含了许多方法（`log(..)`，`error(..)`等）。`console`对象由宿主环境提供，以便让我们能够从代码中输出各种值。

`console`在浏览器中是输出到开发工具控制台，而在node.js和其他服务器端JS环境中则是指向JavaScript环境系统进程的标准输出（`stdout`）和标准错误输出（`stderr`）。

###全局DOM变量

你可能已经知道声明一个全局变量（使用var或者不使用）的结果并非仅仅是创建了一个全局变量，并且还会在`global`对象（在浏览器中为`window`）中创建一个同名属性。

但还有一个不太为人所知的事实是，由于浏览器演进的历史遗留的关系，在创建带有`id`属性的DOM元素的时候也会创建同名的全局变量。例如：

```
     <div id="foo"></div>
```

以及：

```
    if (typeof foo == "undefined") {
        foo = 42;        // will never run
    }

    console.log( foo );  // HTML element
```

你可能已经习惯使用`typeof`或`.. in window`来检测全局变量，认为只有JS代码才会创建它们，但是如上例所示，HTML页面中的内容也会产生全局变量，如果不注意的话很容易让你的全局变量检查变得错误百出。

这是为什么我们尽量不要使用全局变量的一个原因，如果确实要用，也要确保变量名的唯一性从而避免与其他地方的变量产生冲突，包括HTML和其他第三方代码。

###原生原型

一个广为人知的JavaScript的最佳实践之一是：不要扩展原生原型。

如果你向`Array.prototype`加入了新的方法和属性，如果它们确实有用，设计和命名都很得当，最后很有可能会被加入到JS规范当中，这样一来你所做的扩展就会与之冲突。

我自己就遇到过一个这样的例子。

当时我正在为一些网站开发一个嵌入式构件，基于jQuery（基本上所有的框架都会犯这样的错误）。基本上在所有的网站上都可以运行，但是在某个网站上彻底无法运行。

在差不多一个星期的分析调试之后，我发现这个网站有一段遗留代码，象下面这样：

```
    // Netscape 4 doesn't have Array.push
    Array.prototype.push = function(item) {
        this[this.length-1] = item;
    };
```

除了注释以外（谁还会关心Netscape 4呢？），它看起来没有什么问题，是吧？

问题在于`Array.prototype.push`在随后被加入到了规范中，并且和这段代码不兼容。标准的`push(..)`可以一次加入多个值。而这段代码中的`push`方法则只会处理第一个值。

最初加入这个方法的开发人员将其命名为`push`合情合理，但是没有意识到需要处理多个值。这相当于挖了一个坑，10年之后让我掉了进去。

从这里我们得到几个教训。

首先，不要扩展原生方法，除非你确信你的代码在运行环境中不会有冲突。如果你不是100%确定而进行扩展是非常危险的。这需要你自己仔细权衡利弊。

其次，在扩展原生方法时加入判断条件（因为你可能无意中覆盖了原来的方法）。对于前面的例子，下面的处理方式更好些：

```
    if (!Array.prototype.push) {
        // Netscape 4 doesn't have Array.push
        Array.prototype.push = function(item) {
            this[this.length-1] = item;
        };
    }
```

`if`语句确保如果JS运行环境中没有`push()`方法时才将扩展加入。这应该可以解决我的问题，但是即使这样也存在着一定的隐患：

1. 如果网站代码中的`push(..)`原本就不打算处理多个值的情况，则标准的`push(..)`出台后会导致代码运行出错。

2. 如果在`if`判断前引入了其他第三方的`push(..)`方法，并且该方法的功能不同，也会导致代码运行出错。

这里显现出一个不太为JS开发人员注意的问题：在各种第三方代码混合运行的环境中是否只应该使用现有的原生方法。

答案是否定的，但是实际上不太行得通。通常你无法重新定义所有会用到的原生方法，同时确保它们的安全。即使可以也是一种浪费。

那么我们是否应该既测试原生方法是否存在，又测试它是否执行我们想要的功能？如果测试没通过怎么办，是不是代码停止执行？

```
    // don't trust Array.prototype.push
    (function(){
        if (Array.prototype.push) {
            var a = [];
            a.push(1,2);
            if (a[0] === 1 && a[1] === 2) {
                // tests passed, safe to use!
                return; 
            }
        }

        throw Error(
            "Array#push() is missing/broken!"
        ); 
    })();
```

理论上说这个方法不错，但实际上我们不可能为每个原生函数都做这样的测试。

那怎么办呢？我们是否应该逐一做测试？还是假设一切没问题，等出现问题时再做处理？

这里没有标准答案。实际上如果我们不去自己扩展原生原型的话就不会遇到这类问题。

如果你和第三方代码都遵循上面的原则，恭喜你，你是安全的。否则你对你的程序需要多加一些谨慎和小心，以防任何可能出现的这类问题。

针对各种运行环境做单元和回归测试能够早一些发现这类问题，但是却不能够杜绝之。

###Shims／Polyfills(JJ--??)

通常来说在老版本的（不符合规范的）运行环境中扩展原生方法是唯一安全的，因为环境不太可能有变化－老版本的浏览器会被支持新规范的新版本浏览器完全替代，而非在老版本上做扩展。

如果你能够预见哪些方法将来会成为新的标准，如`Array.prototype.foobar`，你完全可以放心地使用当前的扩展版本，不是吗？

```
    if (!Array.prototype.foobar) {
        // silly, silly
        Array.prototype.foobar = function() {
            this.push( "foo", "bar" );
        }; 
    }
```

如果规范中已经定义了`Array.prototype.foobar`，并且功能和上面的代码类似，那就没有什么问题，这种情况我们称为“polyfill”（或者“shim”）。

它可以有效地为那些不符合最新规范的老浏览器填补上缺失的功能。Polyfills让你能够通过可靠的代码来支持所有你想要支持的运行环境。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">ES5-Shim是一个完整的shims／polyfills集合，能够为你的项目提供ES5基本规范支持，同样地，ES6-Shim提供了对ES6的支持。虽然我们可以通过shims／polyfills来填补新的API，但是无法填补新的语法。我们可以使用Traceur这样的工具来实现新旧语法之间的转换。</td>
    </tr>
</table>

对于那些将来可能成为标准的功能，按照大部份人赞同的方式来预先实现以便和将来的标准兼容的polyfill，我们称为“prollyfill”（probably fill）。

真正的问题在于有一些标准功能没办法被完整地polyfill／prollyfill。

JS社区存在这样的争论，是否可以对一个功能做不完整的polyfill（将无法polyfill的部分文档化），或者不做则已，要做就要达到100%符合规范。

很多人可以接受一些不完整的polyfill（如`Object.create(..)`），因为缺失的那部分也不会被用到。

一些人认为在polyfill／shim中的`if`判断里需要加入一些兼容性测试，只在被测试的功能不存在或者未通过测试时才将其替换。这也是我们区别“shim“（有兼容性测试）和”polyfill“（检查功能是否存在）的方式。

最终的答案是没有正确答案。即便使用了“安全”的做法，对原生功能进行扩展也无法做到100%安全。依赖第三方代码中的原生功能也是这样，因为这些功能有可能被扩展了。

我们在处理这些情况的时候都需要格外小心，编写健壮的代码，并且写好文档。

###<script>s

绝大部分网站／Web应用程序的代码都存放在多个文件中，通常我们在网页中使用`<scriopt src=..></script>`来加载这些文件，或者使用`<script> .. </script>`来包含内联代码（inline code）。

这些文件和内联代码是相互独立的JS程序还是一个整体呢？

答案是（也许会令人惊讶）它们的运行方式更象是相互独立的JS程序，但是也并非总是如此。

它们共享`global`对象（在浏览器中则是`window`），也就是说这些文件中的代码在这个共享的命名空间中运行，并相互交互。

如果某个`script`中定义了函数`foo()`，后面的`script`代码就可以访问并调用`foo()`，就象`foo()`在它内部被声明过一样。

但是全局变量作用域的提升机制（hoisting，参见本系列的《Scope & Closures》一书）在这些边界中不适用，因此无论是`<script> .. </script>`还是`<script src=..></script>`，下面的代码都无法运行（因为`foo()`还未被声明）：

```
    <script>foo();</script>

    <script>
      function foo() { .. }
    </script>
```

但是下面的两段代码则没问题：

```
    <script>
      foo();
      function foo() { .. }
    </script>
```

和：

```
    <script>
      function foo() { .. }
    </script>

    <script>foo();</script>
```

如果`script`中的代码（无论是内联代码还是外部代码）发生错误，它会象独立的JS程序那样停止，但是后续的`script`中的代码（仍然共享`global`）依然会接着运行，不会受影响。

你可以使用代码来动态创建`script`，将其加入到页面的DOM中，效果是一样的：

```
    var greeting = "Hello World";

    var el = document.createElement( "script" );
    
    el.text = "function foo(){ alert( greeting );\
     } setTimeout( foo, 1000 );";

    document.body.appendChild( el );
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">如果你将el.src的值设置为一个文件URL的话，就可以实现通过&lt;script src=..&gt;&lt;/script&gt;动态加载外部文件。</td>
    </tr>
</table>

内联代码和外部文件中的代码之间有一个区别，在内联代码中不可以出现`</script>`字符串，一旦出现即被视为代码块结束。因此对下面这样的代码需要非常小心：

```
    <script>
      var code = "<script>alert( 'Hello World' )</script>";
    </script>
```

看起来似乎没什么问题，但是字符串常量中的`</script>`将会被当作结束标签来处理，因此会导致错误。常用的变通方法是：

```
    "</sc" + "ript>";
```

另外需要注意的是，我们是根据代码文件的字符集属性（UTF-8，ISO-8859-8等）来解析外部文件中的代码（或者缺省字符集），而内联代码则使用其所在页面文件的字符集（或者缺省字符集）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">内联代码的script标签没有charset属性。</td>
    </tr>
</table>

`script`标签一个已经被废止的用法是在内联代码中包含HTML和XHTML格式的注释，如：

```
    <script>
    <!--
    alert( "Hello" );
    //-->
    </script>
    
    <script>
    <!--//--><![CDATA[//><!--
    alert( "World" );
    //--><!]]>
    </script>
```

现在我们已经不需要这样做了，所以不要再用继续使用它们。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">&lt;--和--&gt;（HTML格式的注释）在JavaScript中被定义为合法的单行注释分隔符（var x = 2; &lt;-- 是一行合法注释 和 --&gt; 是另一行合法注释），这时由于老的技术导致（详见之前的“Web ECMAScript”），但是不要再使用它们。</td>
    </tr>
</table>

###保留字

ES5规范在7.6.1节中定义了一些“保留字”，我们不能把它们用作变量名。这些保留字有四类：“关键字”，“预留关键字”，`null`常量，和`true`／`false``boolean`常量。

象`function`和`switch`这些都是关键字。预留关键字包括`enum`等，它们中很多已经在ES6中被用到（如`class`，`extend`等）。另外还有一些在严格模式中使用的保留字，如`interface`。

一个名为“art4theSould”的StackOverflow用户将这些保留字编成了一首`有趣的小诗`：

```
    Let this long package float,
    Goto private class if short.
    While protected with debugger case, Continue volatile interface. Instanceof super synchronized throw, Extends final export throws.

    Try import double enum?
    + False, boolean, abstract function, Implements typeof transient break! Void static, default do,

    Switch int native new.
    Else, delete null public var
    In return for const, true, char ...Finally catch byte.
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这首诗中包含了ES3中的保留字（byte, long等），它们在ES5中已经不再是保留字。</td>
    </tr>
</table>

在ES5之前，保留字也不能用来作为对象常量中的属性名称或者键值，但是现在已经没有这个限制。

例如我们不允许下面的情况：

```
    var import = "42";
```

但是下面的情况是允许的：

```
    var obj = { import: "42" };
    console.log( obj.import );
```

需要注意的是，在一些版本较老的浏览器中（主要是IE）这些规则并不完全适用，有时候将保留字用作对象属性还是会出错。所以你需要在所有要支持的浏览器中仔细测试。

###实现中的限制

JavaScript规范对于函数中参数的个数，和字符串常量的长度等并没有限制，但是由于JavaScript引擎实现的各异，规范在某些地方有一些限制。

例如：

```
    function addAll() {
            var sum = 0;
            for (var i=0; i < arguments.length; i++) {
                    sum += arguments[i];
            }
            return sum;
    }
    
    var nums = [];

    for (var i=1; i < 100000; i++) {
            nums.push(i);
    }
    
    addAll( 2, 4, 6 );           // 12
    addAll.apply( null, nums );  // should be: 499950000
```

在一些JS引擎中你会得到正确答案`499950000`，而另外一些引擎（如Safari 6.x）会产生错误“RangeError: Maximum call stack size exceeded.”。

这里我们列出一些已知的限制：

- 字符串常量中允许的最大字符数（并非只是针对字符串值）
- 可以作为参数传递到函数中的数据大小（也称为stack size，以byte为单位）
- 函数声明中的参数个数
- 未经优化的调用栈的最大层数（例如递归）：即函数调用链的最大长度
- JS程序以阻赛方式在浏览器中运行的最长时间（秒）
- 变量名的最大长度

我们并不太常会碰到这些限制，但是还是必须对它们有所了解，特别是不同的JS引擎的限制各异。

###回顾

JS语言本身有一个统一的标准，在所有浏览器／引擎中的实现也是可靠的。这时好事！

但是JavaScript很少独立运行。我们的运行环境中通常还有第三方代码，代码甚至会运行在浏览器之外的引擎／环境中。

如果我们对这些问题多加注意，就能够提高代码的可靠性和健壮性。

###附录B
##致谢

我要感谢许多人，是他们的帮助让本书以及整个系列得以出版。

首先要感谢我的妻子Christen Simpson和我的两个孩子Ethan和Emily，能够容忍我整天工作在电脑前。即使不写作的时候，我的眼睛也总是盯着屏幕做一些JavaScript相关的工作。我牺牲了很多陪伴家庭的时间，因此这个系列的丛书才能够为你深入全面地介绍JavaScript。我亏欠我的家庭太多太多。

我要感谢O'Reilly的编辑Simon St.Laurent和Brian MacDonald，以及所有其他的编辑和市场工作人员。和他们在一起工作非常愉快，在本系列丛书的实验过程中接受了开源图书的写作，编辑，和制作（JJ--??）。

我要感谢所有为本系列提供建议和校正的人，包括Shelley Powers，Tim Ferro，Evan Borden，Forrest L Norvell，Jennifer Davis，Jesse Harlin等。十分感谢David Walsh为本书作序。

我要感谢JavaScript社区中的许多人，包括TC39委员会的成员们，将他们的知识与读者和我分享，以及耐心想尽地回答我无休止的提问。他们是John-David Dalton，Juriy “kangax” Zaytsev，Mathias Bynens，Rick Waldron，Axel Rauschmayer，Nicholas Zakas，Angus Croll，Jordan Harband，Reginald Braithwaite，Dave Herman，Brendan Eich，Allen Wirfs-Brock，Brad‐ ley Meck，Domenic Denicola，David Walsh，Tim Disney，Kris Kowal，Peter van der Zee，Andrea Giammarchi，Kit Cambridge等等，还有太多的人我无法一一感谢。

《你不知道的JS》系列丛书是从Kickstarter发起的，我要感谢我的近500名慷慨的支持者，没有他们的支持就没有这套系列丛书：

Jan Szpila，nokiko，Murali Krishnamoorthy，Ryan Joy，Craig Patch‐ ett，pdqtrader，Dale Fukami，ray hatfield，R0drigo Perez [Mx]，Dan Petitt，Jack Franklin，Andrew Berry，Brian Grinstead，Rob Suther‐ land，Sergi Meseguer，Phillip Gourley，Mark Watson，Jeff Carouth，Alfredo Sumaran，Martin Sachse，Marcio Barrios，Dan，Aimely‐ neM，Matt Sullivan，Delnatte Pierre-Antoine，Jake Smith，Eugen Tudorancea，Iris，David Trinh，simonstl，Ray Daly，Uros Gruber，Justin Myers，Shai Zonis，Mom & Dad，Devin Clark，Dennis Palmer，Brian Panahi Johnson，Josh Marshall，Marshall，Dennis Kerr，Matt Steele，Erik Slagter，Sacah，Justin Rainbow，Christian Nilsson，Delapouite，D.Pereira，Nicolas Hoizey，George V. Reilly，Dan Reeves，Bruno Laturner，Chad Jennings，Shane King，Jeremiah Lee Cohick，od3n，Stan Yamane，Marko Vucinic，Jim B，Stephen Collins，Ægir Þorsteinsson，Eric Pederson，Owain，Nathan Smith，Jeanetteurphy，Alexandre ELISÉ，Chris Peterson，Rik Watson，Luke Matthews，Justin Lowery，Morten Nielsen，Vernon Kesner，Chetan Shenoy，Paul Tregoing，Marc Grabanski，Dion Almaer，Andrew Sul‐ livan，Keith Elsass，Tom Burke，Brian Ashenfelter，David Stuart，Karl Swedberg，Graeme，Brandon Hays，John Christopher，Gior，manoj reddy，Chad Smith，Jared Harbour，Minoru TODA，Chris Wigley，Daniel Mee，Mike，Handyface，Alex Jahraus，Carl Furrow，Rob Foulkrod，Max Shishkin，Leigh Penny Jr.，Robert Ferguson，Mike van Hoenselaar，Hasse Schougaard，rajan venkataguru，Jeff Adams，Trae Robbins，Rolf Langenhuijzen，Jorge Antunes，Alex Koloskov，Hugh Greenish，Tim Jones，Jose Ochoa，Michael Brennan-White，Naga Harish Muvva，Barkóczi Dávid，Kitt Hods‐ den，Paul McGraw，Sascha Goldhofer，Andrew Metcalf，Markus Krogh，Michael Mathews，Matt Jared，Juanfran，Georgie Kirschner，Kenny Lee，Ted Zhang，Amit Pahwa，Inbal Sinai，Dan Raine，Schabse Laks，Michael Tervoort，Alexandre Abreu，Alan Joseph Williams，NicolasD，Cindy Wong，Reg Braithwaite，LocalPCGuy，Jon Friskics，Chris Merriman，John Pena，Jacob Katz，Sue Lock‐ wood，Magnus Johansson，Jeremy Crapsey，Grzegorz Pawłowski，nico nuzzaci，Christine Wilks，Hans Bergren，charles montgomery，Ariel בר-לבב Fogel，Ivan Kolev，Daniel Campos，Hugh Wood，Christian Bradford，Frédéric Harper，Ionuţ Dan Popa，Jeff Trimble，Rupert Wood，Trey Carrico，Pancho Lopez，Joël kuijten，Tom A Marra，Jeff Jewiss，Jacob Rios，Paolo Di Stefano，Soledad Penades，Chris Gerber，Andrey Dolganov，Wil Moore III，Thomas Marti‐ neau，Kareem，Ben Thouret，Udi Nir，Morgan Laupies，jory carson- burson，Nathan L Smith，Eric Damon Walters，Derry Lozano- Hoyland，Geoffrey Wiseman，mkeehner，KatieK，Scott MacFarlane，Brian LaShomb，Adrien Mas，christopher ross，Ian Littman，Dan Atkinson，Elliot Jobe，Nick Dozier，Peter Wooley，John Hoover，dan，Martin A. Jackson，Héctor Fernando Hurtado，andy ennamorato，Paul Seltmann，Melissa Gore，Dave Pollard，Jack Smith，Philip Da Silva，Guy Israeli，@megalithic，Damian Crawford，Felix Gliesche，April Carter Grant，Heidi，jim tierney，Andrea Giammarchi，Nico Vignola，Don Jones，Chris Hartjes，Alex Howes，john gibbon，David J. Groom，BBox，Yu Dilys Sun，Nate Steiner，Brandon Satrom，Brian Wyant，Wesley Hales，Ian Pouncey，Timothy Kevin Oxley，George Terezakis，sanjay raj，Jordan Harband，Marko McLion，Wolfgang Kaufmann，Pascal Peuckert，Dave Nugent，Markus Liebelt，Welling Guzman，Nick Cooley，Daniel Mesquita，Robert Syvarth，Chris Coyier，Rémy Bach，Adam Dougal，Alistair Duggin，David Loidolt，Ed Richer，Brian Chenault，GoldFire Studios，Carles Andrés，Carlos Cabo，Yuya Saito，roberto ricardo，Barnett Klane，Mike Moore，Kevin Marx，Justin Love，Joe Taylor，Paul Dijou，Michael Kohler，Rob Cassie，Mike Tierney，Cody Leroy Lindley，tofuji，Shimon Schwartz，Raymond，Luc De Brouwer，David Hayes，Rhys Brett- Bowen，Dmitry，Aziz Khoury，Dean，Scott Tolinski - Level Up，Clement Boirie，Djordje Lukic，Anton Kotenko，Rafael Corral，Phi‐ lip Hurwitz，Jonathan Pidgeon，Jason Campbell，Joseph C.，Swif‐ tOne，Jan Hohner，Derick Bailey，getify，Daniel Cousineau，Chris Charlton，Eric Turner，David Turner，Joël Galeran，Dharma Vaga‐ bond，adam，Dirk van Bergen，dave ♥♫★ furf，Vedran Zakanj，Ryan McAllen，Natalie Patrice Tucker，Eric J. Bivona，Adam Spoo‐ ner，Aaron Cavano，Kelly Packer，Eric J，Martin Drenovac，Emilis，Michael Pelikan，Scott F. Walter，Josh Freeman，Brandon Hudgeons，vijay chennupati，Bill Glennon，Robin R.，Troy Forster，otaku_coder，Brad，Scott，Frederick Ostrander，Adam Brill，Seb Flippence，Michael Anderson，Jacob，Adam Randlett，Standard，Joshua Clanton，Sebastian Kouba，Chris Deck，SwordFire，Hannes Papenberg，Richard Woeber，hnzz，Rob Crowther，Jedidiah Broad‐ bent，Sergey Chernyshev，Jay-Ar Jamon，Ben Combee，luciano bonachela，Mark Tomlinson，Kit Cambridge，Michael Melgares，Jacob Adams，Adrian Bruinhout，Bev Wieber，Scott Puleo，Thomas Herzog，April Leone，Daniel Mizieliński，Kees van Ginkel，Jon Abrams，Erwin Heiser，Avi Laviad，David newell，Jean-Francois Turcot，Niko Roberts，Erik Dana，Charles Neill，Aaron Holmes，Grzegorz Ziółkowski，Nathan Youngman，Timothy，Jacob Mather，Michael Allan，Mohit Seth，Ryan Ewing，Benjamin Van Treese，Marcelo Santos，Denis Wolf，Phil Keys，Chris Yung，Timo Tijhof，Martin Lekvall，Agendine，Greg Whitworth，Helen Humphrey，Dougal Campbell，Johannes Harth，Bruno Girin，Brian Hough，Darren Newton，Craig McPheat，Olivier Tille，Dennis Roethig，Mathias Bynens，Brendan Stromberger，sundeep，John Meyer，Ron Male，John F Croston III，gigante，Carl Bergenhem，B.J. May，Rebe‐ kah Tyler，Ted Foxberry，Jordan Reese，Terry Suitor，afeliz，Tom Kiefer，Darragh Duffy，Kevin Vanderbeken，Andy Pearson，Simon Mac Donald，Abid Din，Chris Joel，Tomas Theunissen，David Dick，Paul Grock，Brandon Wood，John Weis，dgrebb，Nick Jenkins，Chuck Lane，Johnny Megahan，marzsman，Tatu Tamminen，Geof‐ frey Knauth，Alexander Tarmolov，Jeremy Tymes，Chad Auld，Sean Parmelee，Rob Staenke，Dan Bender，Yannick derwa，Joshua Jones，Geert Plaisier，Tom LeZotte，Christen Simpson，Stefan Bruvik，Jus‐ tin Falcone，Carlos Santana，Michael Weiss，Pablo Villoslada，Peter deHaan，Dimitris Iliopoulos，seyDoggy，Adam Jordens，Noah Kant‐ rowitz，Amol M，Matthew Winnard，Dirk Ginader，Phinam Bui，David Rapson，Andrew Baxter，Florian Bougel，Michael George，Alban Escalier，Daniel Sellers，Sasha Rudan，John Green，Robert Kowalski，David I. Teixeira (@ditma，Charles Carpenter，Justin Yost，Sam S，Denis Ciccale，Kevin Sheurs，Yannick Croissant，Pau Fracés，Stephen McGowan，Shawn Searcy，Chris Ruppel，Kevin Lamping，Jessica Campbell，Christopher Schmitt，Sablons，Jonathan Reisdorf，Bunni Gek，Teddy Huff，Michael Mullany，Michael Fürstenberg，Carl Henderson，Rick Yoesting，Scott Nichols，Hernán Ciudad，Andrew Maier，Mike Stapp，Jesse Shawl，Sérgio Lopes，jsulak，Shawn Price，Joel Clermont，Chris Ridmann，Sean Timm，Jason Finch，Aiden Montgomery，Elijah Manor，Derek Gathright，Jesse Harlin，Dillon Curry，Courtney Myers，Diego Cadenas，Arne de Bree，João Paulo Dubas，James Taylor，Philipp Kraeutli，Mihai Păun，Sam Gharegozlou，joshjs，Matt Murchison，Eric Windham，Timo Behrmann，Andrew Hall，joshua price，Théophile Villard。

这套系列丛书的编辑和制作都是以开源的方式进行。我们要感谢GitHub让这一切成为可能！

再次对我没能提及的支持者们表示感谢。这套系列丛书是属于我们每一个人的，希望它们能够帮助更多的人更好地了解JavaScript。

###关于作者

**Kyle Simpson**是Open Web的倡导者，居住在得克萨斯的奥斯汀。他热爱JavaScript，HTML5，实时／点对点通讯，和Web性能优化。所以对这些并不感到枯燥乏味。Kyle也是一个作者，培训师，技术讲演者，和活跃的OSS社区成员。

###尾声

《类型和语法》的封面字体是Interstate，正文字体是Adobe Minion Pro，标题字体是Adobe Myriad Condensed，示例代码字体是Dalton Maag's Ubuntu Mono。