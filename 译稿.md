#你不知道的JavaScript － 类型和语法

##序

曾有人说：“JavaScript是唯一一门程序员先用后学的语言。”

每次听到这句话我都会付诸一笑，因为它对于我就是如此，不知道对其他程序员是否也一样。JavaScript，也许还有CSS和HTML，在互联网早期的大学计算机课程中并非主流的教学语言。新手程序员大多通过搜索和“查看源代码”的方式来自学这些Web的基础语言。

我仍然记得我高中时代的第一个网站项目。当时的任务是搭建一个网上商店，无论什么样的都行，因为我是詹姆斯∙邦德的粉丝，所以我决定搭建一个“黄金眼”商店。它包罗万象：背景音乐是“黄金眼”主题曲，有一个用JavaScript开发的瞄准器跟随鼠标移动，每次点击鼠标的时候会发出一声枪响。Q(JJ-??)实在应该为这个网站杰作感到骄傲。

我之所以讲到这个故事，是因为我当时使用的开发方式直到现在仍然有许多程序员在使用。我在项目中“拷贝－粘贴”了很多JavaScript代码，但根本没有理解它们是干什么的。现在流行的jQuery这样的JavaScript工具集，也在以它们各自的方式潜移默化地进一步鼓励了不深入学习JavaScript的方式。

我并不反对使用JavaScript工具集，事实上我还是MooTools JavaScript团队的成员之一。这些工具集功能如此强大的原因，恰恰是它们的开发者们从根本上了解它们，并且将其运用到了极致。了解这门语言的基本知识对我们来说仍然是非常重要的，这与掌握那些工具集一样会对我们非常有帮助。象Kyle Simpson的《你不知道的JS》系列这样的书，我们实在没有理由不学习。

《类型和语法》是该系列的第三本，它介绍了JavaScript核心基础知识，这些知识你永远不可能从“拷贝－粘贴”和JavaScript工具集中学到。前置（coercion）及其隐患、原生构造方法(JJ-??)、以及JavaScript的全部基础知识都在本书中做了详细的介绍，并配合以示例代码。同本系列的其他作品一样，Kyle的行文直中要点，没有多余的套话和修辞(JJ-??)，是我喜欢的技术书风格。

希望你们喜欢《类型和语法》这本书，并能够常读常新。

-David Walsh ([http://davidwalsh.name](http://davidwalsh.name)),
Senior Web Developer at Mozilla

------

##前言

我想你已经注意到了本书中的“JS”一词，但是它并非是用来咒骂JavaScript的简语，虽然咒骂一门语言是我们作为程序员的标志。

从互联网最早期开始，JavaScript就一直是实现内容交互体验的基本技术。虽然刚开始是用来实现鼠标移动轨迹闪烁效果，还有令人讨厌的弹出消息框。大约20年之后，JavaScript技术和功能得到了数量级的提高，没有人再怀疑它在互联网，这个世界上使用最广泛的软件系统，中的重要性和核心地位。

但是作为一门语言，它一直为人诟病，包括其历史沿革，更多是它的设计理念。它的命名，相对于其更成熟的哥哥Java，也被Brendan Eich称为“傻弟弟”。其实它的命名仅仅是政治和市场考量下的一个偶然。两个语言之间千差万别，“JavaScript”和“Java”之间如同“Carnival”（嘉年华）和“Car”之间一样毫无关联。

JavaScript在概念上和语法习惯上借鉴了许多语言，包括壮观的C风格的程序根，和相对隐晦的Scheme/Lisp风格的函数根，它能为更多的开发人员接受，包括没有编程经验的人。用JavaScript编写“Hello World”非常简单，让人很容易上手。

JavaScript或许是最容易上手和使用的语言之一，但是它的一些古怪的行为使得它不像其他语言那样容易完全掌握。使用C或者C++开发一个完整的程序需要对该语言有一个相当深入的了解。然而对于JavaScript来说，就算你使用它开发了一个完整的系统，也不见得对这门语言有什么深入理解。

这门语言中那些隐藏得很深的复杂概念，往往以一种看似简单的方式呈现，例如：将函数作为回调参数传递，使得JavaScript程序员乐于使用现成的语言机制，而不愿意去了解其中的原因。

JavaScript是一门简单易用的语言，应用广泛，同时又有着复杂和声名狼藉的语言机制，如果不用心掌握，即使经验丰富的JavaScript程序员也会对其出现理解上的偏差。

JavaScript的悖论就在于此，它的阿基里斯之踵正是我们要在本书解决的问题。因为你不需要理解就能够使用它，所以常常最终也不会去理解它。

###使命

在使用JavaScript时，每当遇到令人讶异或者抓狂的情况，你的反应如果是置之不理（这是人之常情），你很快会发现自己无法发挥这门语言的任何优势(JJ-??)。

这部分经常被称为“好的部分（The Good Parts）”，但我恳请读者朋友们不如把它视作“容易的部分”，“安全的部分”，甚至于“不完整的部分”。

《你不知道的JS》系列涉及的是另一个部分，即深入掌握JavaScript的所有知识，特别是那些重点难点。

我们让本书的内容对于JS程序员来说易于理解，而不强迫他们深入到原理。此外，在碰到疑难问题的时候我们不会避而不谈。

我不会满足于只是让代码运行而不明就里，，你也不应该仅仅满足于此。我会逐步用一些难点来挑战你，最终让你全面掌握JavaScript的威力。一旦掌握了这些知识，你将无法想象不需要技巧，框架，术语会是多么美妙的事情(JJ-??)。

本系列中的每本书全面深入地探讨了JavaScript中那些被误解，或者被低估的关键知识点。读完之后，从理论和实践上，对那些必须掌握的知识你都会有一个充分和自信的理解。

目前你对JavaScript的认识可能都来自于那些对JavaScript一知半解的人。JavaScript是一门语言，同时也是这门语言的一道影子。如果你还不真正了解它的话，读完本系列你会了解。让我们尽情地开始阅读吧。

###回顾

JavaScript是一门优秀的语言。它的各个部分学习起来都不难，但是要完全整体掌握则很难。当程序员遇到困惑时往往归咎于语言本身，而不是他们自身对语言的缺乏理解。本系列丛书旨在解决这个问题，让你能够发自内心地喜欢上这门语言。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">本书中的许多示例需要ES6这样的新一代的JavaScript引擎。一些代码可能无法在老的引擎（ES6之前）上运行。</td>
    </tr>
</table>


###书写约定

本书使用以下书写约定：

*斜体字*
表示新术语，URL，电子邮件，文件名，和文件扩展名。

等宽字
用于显示程序代码，和在段落中显示程序代码中的内容，如：变量名和函数名，数据库，数据类型，环境变量，声明语句，和关键词。

####粗体等宽字
需要用户输入的命令和其他文本。

*斜体等宽字*
需要用户提供替换值的文本，或者根据上下文计算的值。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">提示和建议</td>
    </tr>
</table>

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">注解</td>
    </tr>
</table>

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">警告和提醒</td>
    </tr>
</table>

###示例代码

本书的附带资料（如：示例代码，练习等）在[http://bit.ly/ydkjs-types-code](http://bit.ly/ydkjs-types-code)可以下载。

本书旨在帮助你解决实际问题。你可以在你的程序和文档中使用本书提供的示例代码。除非你使用了相当数量的示例代码，否则你不需要经过我们的许可。例如，你不必征得我们的同意既可在你的程序中使用几段本书的示例代码。如果你将O'Reilly出版的图书中的示例代码制作为光盘出售，则需要经过我们的许可。如果你在回答别人的问题时需要引用本书的内容和示例代码，你不需要征得我们许可。如果你的产品文档中引用了大量本书的示例代码，则需要征得我们许可。

如果你能够在使用到本书的地方注明出处，我们会非常感谢，不过这并不是强制的。注明出处通常包括书名，作者，出版方，和ISBN。例如：《你不知道的JS》，Kyle Simpson著，O'Reilly出版。Copyright 2015 Getify Solutions, Inc.,978-1-491-90419-0。

如果你觉得你的情况不属于上述两种情况，请通过[permissions@oreilly.com](permis‐ sions@oreilly.com)和我们联系。

###Safari Books Online

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/safari.png'></td>
        <td style="border: none;"><a href='http://safaribooksonline.com'>Safari Books Online</a>是及时点播式数字图书馆，为您提供来自世界顶尖科技和商业作者的专业书籍和视频<a href='https://www.safaribooksonline.com/explore'>内容</a>。</td>
    </tr>
</table>

科技工作者、软件开发人员、Web设计师和商业创新从业者都将Safari Books Online作为他们研究、攻关、学习和认证培训的一个主要资源。

Safari Books Onine为[企业](https://www.safaribooksonline.com/enterprise/)、[政府](https://www.safaribooksonline.com/government/)、[教育](https://www.safaribooksonline.com/academic-public-library/)和个人提供不同的[计划和收费](https://www.safaribooksonline.com/pricing/)。

Safari Books Online会员能够访问上千本图书，教学视频，和来自[上百家出版方](https://www.safaribooksonline.com/our-library)，如：O'Reilly Media，Prentice Hall Professional, Addison- Wesley Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders, McGraw-Hill, Jones & Bartlett, Course Tech‐ nology，并且可以在数据库中检索的正式出版前的稿件。有关Safari Books Online更多的信息请访问我们的网站。

------

###联系我们

关本书的想法和问题，您可以通过以下方式和我们联系：

O’Reilly Media, Inc.
1005 Gravenstein Highway North
Sebastopol, CA 95472
800-998-9938 (in the United States or Canada) 707-829-0515 (international or local) 707-829-0104 (fax)

我们为本书建设了一个网页，上面有勘误，示例，和其他信息。可以通过[http://bit.ly/ydkjs_types-and-grammar](http://bit.ly/ydkjs_types-and-grammar.)这个链接访问。

有关本书的评论和技术问题，可以发送邮件到[bookquestions@oreilly.com](bookquestions@oreilly.com)。

有关其他图书的信息，课程，论坛，和新闻，请访问我们的网站[http://www.oreilly.com](http://www.oreilly.com)。

我们的Facebook页面：[http://facebook.com/oreilly](http://facebook.com/oreilly)

关注我们的Twitter：[http://twitter.com/oreillymedia](http://twitter.com/oreillymedia)

我们的Youtube频道：[http://www.youtube.com/oreillymedia](http://www.youtube.com/oreillymedia)

------

##第一章 类型

很多开发人员认为动态语言（如：JavaScript）是没有类型的。让我们看看ES5.1规范（[http:// www.ecma-international.org/ecma-262/5.1/](http:// www.ecma-international.org/ecma-262/5.1/)）对此怎样解释：

```
本规范中的算法所操纵的值均有一个相对应的类型。本条款中定义了所有可能的值类型。类型是对ECMAScript语言类型和规范类型的进一步细分。
ECMAScript语言类型对应ECMAScript程序员使用该语言直接操纵的值。ECMAScript语言中的类型有：Undefined，Null，Boolean，String，Number，和Object。
```

如果你喜欢强类型（又称为静态类型）语言，你也许不同意使用“类型”一词。在强类型语言中，“类型”一词的含义比在JavaScript中广得多。

有人认为JavaScript中的“类型”应该叫“标签”或者“子类型”更合适。

我们在本书中对类型做如下粗略定义（和规范中一样）：*类型*是值的内部属性集合，它定义了该值的行为特征，使其能够区别于其他值。对于语言解析引擎和开发人员来说都是如此。

换句话说，如果语言解析引擎和开发人员对数字42和字符串"42"区别对待，则说明它们具有不同的类型，一个是数字，一个是字符串。我们通常会对数字42做数学运算。而对字符串"42"做一些其他操作，如将其显示到网页等等。所以它们的类型是不同的。

这样的定义并非十全十美，不过对于本书而言已经足够，而且它也与JavaScript语言对自身的描述一致。

###类型的另一面

抛开学术定义上的分歧不谈，JavaScript中有无类型为什么这么重要？

要合理准确地对值进行类型转换（见`第四章`），我们必须正确理解各个类型及其内部行为特征。几乎所有的JavaScript程序都涉及到各种形式的类型强制，因此你需要在处理这些情况时有充分的把握和信心。

如果你要将数字42当作字符串来处理，比如获得其第二个字符"2"，你就需要先将其从数字转换（强制）为字符串。

道理很明显。

但是强制类型转换的方式可以有很多种。有一些是显示的，比较容易，也比较可靠。但是如果你不小心，强制类型转换可能会产生意想不到的结果。

强制类型转换带来的困扰是JavaScript程序员最头疼的事情之一。它经常被诟病太危险，以至于被认为是语言设计上的缺陷，需要尽量回避。

在全面理解JavaScript中的类型的前提下，我们旨在阐述为什么强制类型转换的坏名声被过分夸大了，甚至一定程度上是错误的，这也许能够彻底转变你对它的看法，让你认识到它的强大和实用之处。不过首先我们需要对值和类型有一个更好的理解。

###内置类型

JavaScript中有7种内置类型：

- null
- undefined
- boolean
- number
- string
- object
- symbol（ES6中新增）

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">除object之外，其他统称为基本类型。</td>
    </tr>
</table>

typeof操作符检测值的类型，返回类型的字符串值。令人惊讶的是，以上7种类型和类型的字符串值并不一一对应：

```
    typeof undefined    === "undefined";    // true
    typeof true         === "boolean";      // true
    typeof 42           === "number";       // true
    typeof "42"         === "string";       // true
    typeof { life: 42 } === "object";       // true
    // added in ES6!
    typeof Symbol()     === "symbol";       // true
```

以上6个类型均有与其对应的字符串值，与类型名称相同。`Symbol`是ES6中新增的类型，我们将在`第三章`中介绍。

你可能注意到，null类型不在此列。它有些特殊，typeof运算符针对它的返回结果有bug：

```
    typeof null === "object"; // true
```

正确的返回结果应该是"null"，但是这是一个JavaScrtip固有的bug，已经存在近20年了，也可能永远不会被修复，因为太多的Web系统在“使用”这一bug，修复它将会产生更多的bug，导致大量的Web系统无法工作。

如果你想检测一个null值的类型，需要使用复合条件：

```
    var a = null;
    (!a && typeof a === "object"); // true
```

null是唯一一个“falsy”的基本类型（也称作false-like，见`第四章`），typeof对其仍然返回"object"。

那么typeof的第7个返回字符串值是什么呢？

```
    typeof function a(){ /* .. */ } === "function"; // true
```

上面的typeof的返回值容易让我们得出一个结论，就是`函数（function）`也是JavaScript的一个内置类型。然而如果你查阅规范就会知道，它实际上是`object`的一个子类型（subtype）。具体来说，函数被称为可调用对象（callable object），即该对象内部有一个\[\[Call\]\]属性，使其能够被执行。

函数是对象对我们很有用，更为重要的是，函数还可以拥有属性。例如：

```
    function a(b,c) {
        /* .. */
    }
```

函数对象的`length`属性设置为它的正式参数的数目：

```
    a.length; // 2
```

因为你为该函数定义了两个正式命名参数（b和c），所以函数的长度为2。

那么数组呢？JavaScript本身支持数组，那它是不是也是一个特殊类型？

```
    typeof [1,2,3] === "object"; // true
```

答案是no，数组也是object。确切地说，是object的一个子类型（见`第三章`），它另外一个特征是按照数字顺序进行索引（而非普通对象那样是字符串键值），并且它的`.length`属性会自动更新。

###值作为类型

JavaScript中变量没有类型，值才有。变量在任何时候都可以持有任何类型的值。

理解JavaScript类型的另一种方式是，JavaScript没有“强制类型检测”，就是语言解析引擎不要求一个变量总是持有与其初始值同样类型的值。变量可以一会持有字符串类型的值，一会持有数字类型的值，诸如此类。

值42的内部类型为number，它的类型无法更改。另一个值，如"42"，类型为字符串，能够通过强制类型转换的方式从数字42转换而来(coercion，见`第四章``)。

我们对变量使用typeof时，得到的并非是该变量的类型，因为JavaScript变量没有类型。我们得到的是变量持有的值的类型。

```
    var a = 42;
    typeof a; // "number"

    a = true;
    typeof a; // "boolean"
```

typeof操作符总是返回一个字符串：

```
    typeof typeof 42; // "string"
```

typeof 42首先返回"number"，然后typeof "number"返回"string"。

###undefined和undeclared

变量在没有持有任何值时其值为undefined。此时typeof返回"undefined"：

```
    var a;

    typeof a; // "undefined"

    var b = 42;
    var c;

    // later 
    b = c;

    typeof b; // "undefined"
    typeof c; // "undefined"
```

很多开发人员容易将“undefined”当作“undeclared”的同义词。然而在JavaScript中，它们之间有很大区别。

值为“undefined”的变量是那些已经在访问空间中声明过，但是当前并没有持有任何值的变量。相反，值为“undeclared”的变量是那些还没有在访问空间中声明过的变量。

例如：

```
    var a;

    a; // undefined
    b; // ReferenceError: b is not defined
```

浏览器在处理这类情况的时候显示的错误信息很容易误导人。如你所见，“b is not defined”这样的信息比较容易让人理解为“b is undefined”。再次说明，“undefined”和“is not defined”非常不同。如果浏览器显示诸如“b is not found”或者“b is not declared”这样的错误信息，就能避免不必要的误解。

typeof在处理undeclared变量时有一个特殊的行为更加深了我们的困惑。例如：

```
    var a;

    typeof a; // "undefined"

    typeof b; // "undefined"
```

typeof对于“undeclared”（或者“not defined”）的变量也返回"undefined"。请注意在执行typeof b时没有产生任何错误，即使b是一个undeclared变量。这是typeof中的一个特殊的安全防范。

同上所述，如果typeof对undeclared变量返回“undeclared”而非合用“undefined”，情况会好很多。

###typeof Undeclared

不管怎么说，这样的安全防范对于在浏览器中运行的JavaScript来说是很有帮助的，因为多个script文件可以将变量加载到共享的全局命名空间中。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px; "><img src='images/note.png'></td>
        <td style="border: none;">很多开发人员觉得全局命名空间中不应该有任何变量，所有的东西应该被封装到模块和私有命名空间中。理论上说这样不错，虽然在实际操作中基本不可能实现，但仍不失为一个值得努力的目标。幸运的是在ES6中加入了对模块的优先支持，最终将会让其更具可操作性。
        </td>
    </tr>
</table>

我们举个简单的例子，在你的程序中通过一个全局变量DEBUG来作为“调试模式”的开关。在执行诸如将信息写入控制台这样的调试任务前，你会检查DEBUG变量是否已经被声明过。这时最顶层的全局变量声明var DEBUG = true只包含在“debug.js”文件中，该文件只有在开发和测试时才在浏览器中加载，在生产环境中则不加载。

然而，你需要在程序的其他地方特别注意检查DEBUG变量的方式，以免出现ReferenceError错误。这时安全防范就很有用：

```
    // oops, this would throw an error!
    if (DEBUG) {
        console.log( "Debugging is starting" );
    }
    // this is a safe existence check
    if (typeof DEBUG !== "undefined") {
        console.log( "Debugging is starting" );
    }

```

即使对非用户定义的变量来说，这样的检查也是很有用的。如果你在为一个内置的API做特性检查，这也可以帮助你避免出现错误：

```
    if (typeof atob === "undefined") {
        atob = function() { /*..*/ };
    }
```


<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">如果你在为某个之前没有的特性定义一个“polyfill”，你可能会避免使用var来声明atob。如果你在if语句中使用var atob声明变量，该声明会被提升（参见本系列的Scope &amp; Closures一书）到范围中的最顶层，即使if条件未通过（因为atob全局变量已经存在）。在一些浏览器中和对于一些特殊的内置全局变量（通常被称为host objects），这样的重复声明会产生错误。而去掉var可以防止声明被提升。
        </td>
    </tr>
</table>

另一种对全局变量做检查但是不使用typeof安全防范的方法，是检查所有全局变量是否也是全局对象的属性，在浏览器中全局变量是window。所以上述检查可以写成这样：

```
    if (window.DEBUG) {
        // ..
    }
    
    if (!window.atob) {
        // ..
    }
```

和访问undeclared变量不同，当试图访问的对象属性不存在时，并不会产生ReferenceError错误。

另一方面，许多程序员避免通过window来访问全局变量，特别是当你的代码在多个JS环境下运行（不仅仅在浏览器，还在服务器端node.js，诸如此类），此时全局变量并不一定是window。

从技术角度而言，即便不是全局变量，使用typeof来做安全防范仍然是有用的，虽然这种情况不太常见，所以一些开发人员不太倾向使用这种方式。设想如果你想让别人拷贝粘贴一个工具函数到他们的程序中，你需要在函数中检查一些变量是否已经在它拷贝到的程序中被使用：

```
    function doSomethingCool() {
        var helper =
            (typeof FeatureXYZ !== "undefined") ?
            FeatureXYZ :
            function() { /*.. default feature ..*/ };
        var val = helper();
        // .. 
    }
```

doSomethingCool()检查变量FeatureXYZ，如果已存在就使用它，否则使用自己定义的版本。如果有人将这段代码引入到他们自己的模块和程序中，它会安全地检查FeatureXYZ是否已经被定义过：

```
    // an IIFE (see the "Immediately Invoked Function Expressions"
    // discussion in the Scope & Closures title in this series)
    (function(){
        function FeatureXYZ() { /*.. my XYZ feature ..*/ }

        // include `doSomethingCool(..)`
        function doSomethingCool() {
            var helper =
                (typeof FeatureXYZ !== "undefined") ?
                FeatureXYZ :
                function() { /*.. default feature ..*/ };
            var val = helper();
    // .. }
        doSomethingCool();
    })();
```

在这里FeatureXYZ不是一个全局变量，但是我们还是使用typeof安全防范。重要的是我们没有使用对象（如前面提到的windows.___）来做检查，因而typeof非常有用。

有些程序员可能倾向使用“依赖注入”（dependency injection）的方式，不是使用doSomethingCool()来检查FeatureXYZ是否已经在别处定义过，而是需要将依赖关系通过参数显示地传递进来，如：

```
    function doSomethingCool(FeatureXYZ) {
        var helper = FeatureXYZ ||
            function() { /*.. default feature ..*/ };
        var val = helper();
        // ..
    }
```

实现类似功能的方式有很多。它们之间没有“错”与“对”之分，每种方法都各有利弊。总而言之，使用typeof来检查undeclared变量为我们提供了更多的选择。

###回顾

JavaScript有7种内置类型：null，undefined，boolean，number，string，object，和symbol。可以使用typeof操作符来查看。

变量没有类型，但是它们持有的值有类型。类型定义了值的内在行为特征。

很多开发人员认为“undefined“和“undeclared”基本上是一样的，但是在JavaScript中，它们区别很大。`undefined`是变量可以持有的值的一种。“Undeclared”表示变量还没有被声明过。

不幸的是JavaScript将二者合并起来使用，不仅在相关的错误信息中如此（“ReferenceError:a is not defined”），typeof的返回值"undefined"也涵盖了这两种情况。

然而，使用typeof做安全防范对于检查undeclared的变量来说是非常有用的。

------

##第二章 值

数组，字符串，和数值是计算机程序最基本的组成部分，然而JavaScript中这些类型的一些独特的特性即能让人高兴，又能让人困惑。

###数组

相比其他的强制类型语言，JavaScript中的数组可以容纳任何类型的值，可以是字符串，数值，对象，甚至其他数组（多维数组就是以此方式来实现）：

```
    var a = [ 1, "2", [3] ];
    a.length;       // 3
    a[0] === 1;     // true
    a[2][0] === 3;  // true
```

你不需要预先设定数组的大小（参考`第44页的Array(...)`），你只需要对其进行声明，然后既可向其中加入值：

```
    var a = [ ];
    a.length;   // 0
    a[0] = 1;
    a[1] = "2";
    a[2] = [ 3 ];
    a.length;   // 3
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">对数组中的值执行delete操作能够将其从数组中移除，需要注意的是，即使值被移除后，数组的length属性并不会相应更改。我们将在第五章中详细介绍delete操作。
        </td>
    </tr>
</table>

创建“稀疏的”数组候需要特别注意（数组中有一些空白或者遗失的单元）：

```
    var a = [ ];
    a[0] = 1;
    // no `a[1]` slot set here
    a[2] = [ 3 ];
    a[1];       // undefined
    a.length;   // 3
```

虽然上面的代码没有问题，但是其中的“空白单元”会产生令人困惑的结果。即使单元[1]的值为`undefined`，但是它和我们明确设定该单元（a[1]=undefined）产生的结果还是有区别。详情参见`第44页的“Array(...)”`。

在你意料之中，数组使用数字索引，有趣的是数组也可以是字符串键值和属性组成的对象（它们并不计算在`length`内）：

```
    var a = [ ];
    a[0] = 1;
    a["foobar"] = 2;
    a.length;       // 1
    a["foobar"];    // 2
    a.foobar;       // 2
```

然而，我们需要注意的一个不容易察觉的地方是，如果你使用一个可以被强制转换为10进制数字的字符串作为键值，则默认为你是想使用其作为数字索引而非字符串键值！

```
    var a = [ ];
    a["13"] = 42;
    a.length; // 14
```

通常在数组中加入字符串键值/属性的方式并不是很好。推荐使用对象来存放键值/属性形式的值，使用数组来存放数字索引的值。

###类数组

有时候你需要将类似数组的值（一组使用数字索引的值）转换为真正的数组，通常你可以对其调用数组工具函数来实现（如：indexOf(..)，concat(..)，forEach(..)，等等）。

例如，一些DOM查询操作返回DOM元素列表，它们不是真正的数组，但是却很类似数组。另一个例子是一些函数使用自变量（类数组）对象将参数作为列表来访问（到ES6已经不支持了）。

使用slice(..)函数是实现此种转换的一个很普遍的方式：

```
    function foo() {
        var arr = Array.prototype.slice.call( arguments );
        arr.push( "bam" );
        console.log( arr );
    }

    foo( "bar", "baz" ); // ["bar","baz","bam"]
```

如上例所示，如果slice()不带其他参数，其参数的默认值为数组（本例中则是类数组）的值的复本(JJ-??)。

到ES6为止，其中有一个内置工具函数Array.from(..)也有相同的功能：

```
    ...
    var arr = Array.from( arguments );
    ...
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">Array.from(..)有几个强大的功能，我们将在本系列的《ES6及更多》一书中详细介绍。
</td>
    </tr>
</table>

###字符串

字符串通常被认为是由字符组成的数组。然而其内部实现也可能没有使用数组，重要的是认识到JavaScript中的字符串和字符数组不同。相同之处仅仅是皮毛而已。

例如下面两个值：

```
    var a = "foo";
    var b = ["f","o","o"];
```

如上所示，字符串确实和数组有相似之处，是类数组。比如，它们都有`length`属性，`indexOf(..)`方法（该方法对于数组只支持到ES5），和`concat(..)`方法：

```
    [source,js]

    a.length;                           // 3
    b.length;                           // 3

    a.indexOf( "o" );                   // 1
    b.indexOf( "o" );                   // 1

    var c = a.concat( "bar" );          // "foobar"
    var d = b.concat( ["b","a","r"] );  // ["f","o","o","b","a","r"]

    a === c;                            // false
    b === d;                            // false

    a;                                  // "foo" 
    b;                                  // ["f","o","o"]
```

那么是否可以说它们就是由字符组成的数组？答案是否定的：

```
    a[1] = "O";
    b[1] = "O";

    a; // "foo"
    b; // ["f","O","o"]
```

JavaScript中的`字符串`是不可变的，而`数组`是可变的。并且，a[1]这样的数据访问方式在JavaScript中并非总是合法的。旧版本的IE不允许这样做（现在允许了）。实际上*正确*的访问方式应该是`a.charAt(1)`。

`字符串`不可变意味着其中涉及到变更其内容的方法，都不会变更原始的内容，而是创建并返回一个新的`字符串`。相反，数组方法都是在其原始值上进行操作。

```
    c = a.toUpperCase();
    a === c;    // false
    a;          // "foo"
    c;          // "FOO"

    b.push( "!" );
    b;          // ["f","O","o","!"]
```

此外，很多`数组`中很有用的方法在`字符串`中并不支持，但是我们为`字符串`“借用”`数组`中那些非变更方法：

```
    a.join;         // undefined
    a.map;          // undefined

    var c = Array.prototype.join.call( a, "-" );
    var d = Array.prototype.map.call( a, function(v){
        return v.toUpperCase() + ".";
    } ).join( "" );
    
    c;              // "f-o-o"
    d;              // "F.O.O."
```

我们再来看看另外一个例子，反转`字符串`（一个经常在JavaScript面试中遇到的问题！）。`数组`中有一个叫做`reverse()`的变更方法，而`字符串`没有：

```
    a.reverse;      // undefined

    b.reverse();    // ["!","o","O","f"]
    b;              // ["f","O","o","!"]
```

遗憾的是，这种“借用”对于`数组`的变更方法而言无效，因为`字符串`是不可变的，其内容无法更改：

```
    Array.prototype.reverse.call( a );
    // still returns a String object wrapper (see Chapter 3)
    // for "foo" :(
```

一个变通（破解）的方法是将`字符串`转换为`数组`，执行需要的操作，然后在转换回`字符串`：

```
    var c = a
        // split `a` into an array of characters
        .split( "" )
        // reverse the array of characters
        .reverse()
        // join the array of characters back to a string
        .join( "" );
    
    c; // "oof"
```

该方法感觉太繁琐，实际也的确如此。至少它对于简单`字符串`还是可行的，往往这样简单粗暴的方法能够很快奏效。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">需要注意！上面的方法对于包含复杂字符（unicode）的字符串（星号，多子节字符等等）来说并不适用。对于这种情况你需要功能更加完备、能够处理unicode的工具库。可以参考Mathias Bynen开发的<a href='https://github.com/mathiasbynens/esrever'>Esrever</a>。</td>
    </tr>
</table>

另外一种思路是，如果你经常需要以`字符数组`的方式来处理字符串，那么不如直接用`数组`，而不是`字符串`。这样就不用花很多时间在`字符串`和`数组`之间进行转换了。你可以在需要时对`字符数组`执行`join("")`将其转换为`字符串`。

###数值

JavaScript只有一种数字类型，即：`数值`类型。它包括“整数”和带小数的十进制数。“整数“加引号的原因是，和其他语言不同，JavaScript中没有真正意义上的整数，这也是其一直被诟病的一个地方。这种情况在将来也许会有所改观，不过目前所有数字均为`数值`类型。

JavaScript中的整数只是没有小数的十进制数。所以42.0即等同于“整数”42。

和大多数现代编程语言一样，包括所有的脚本语言，JavaScript的`数值`类型的实现是基于“IEEE 754”标准，通常称为“浮点”。JavaScript具体使用的是“双精度”（又称“64位二进制”）标准。

网络上有很多优秀的文章详细介绍了二进制浮点数在内存中的存储方式，以及各种实现之间的不同。掌握JS中数值类型的正确使用方法，并不一定要求我们理解内存中的数位如何存储，所以本书不多做介绍，有兴趣的读者可以参考IEEE 754的细节。

###数值语法

JavaScript中的数值常量一般为十进制。例如：

```
    var a = 42;
    var b = 42.3;
```

数值前半部分为0的话可以省略：

```
    var a = 0.42;
    var b = .42;
```

同样地，数值后半部分（小数）为0的话也可以省略：

```
    var a = 42.0;
    var b = 42.;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">虽然42.这样的形式不太常见，但的确是允许的，考虑到代码可读性，通常不建议使用。</td>
    </tr>
</table>

缺省情况下，所有的`数值`都显示为十进制，小数部分后面的0省略。如：

```
    var a = 42.300;
    var b = 42.0;

    a; // 42.3
    b; // 42
```

