#第4章 强制类型转换

在对JavaScript的类型和值有了一个更全面的了解之后，本章旨在讨论一个非常有争议的话题：强制类型转换（coercion）。

第1章里讲过，关于强制类型转换是一个设计上的缺陷还是有好处的特性这一争论从JavaScript诞生之日起就开始了。在很多的JavaScript书籍中强制类型转换被说成是危险、晦涩和糟糕的设计。

秉承本系列丛书的一贯宗旨，对于不懂的地方我们应该迎难而上，知其然并且知其所以然，不会因为种种传言和挫折就退避三舍。

本章旨在全面介绍强制类型转换的优缺点，让你能够在开发中合理运用它。

##4.1 值类型转换

将值从一种类型转换为另一种类型通常称为“类型转换”（type casting），这是显式的情况，隐式的情况称为“强制类型转换”（coercion）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="500px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">JavaScript中的强制类型转换总是返回标量基本类型值（见<b>第2章</b>），如：<b>字符串</b>，<b>数字</b>，和<b>布尔值</b>，不会返回<b>对象</b>和<b>函数</b>。在<b>第3章</b>中我们介绍过“封装”，就是为标量基本类型值封装一个相应类型的对象，但这并非严格意义上的强制类型转换。</td>
    </tr>
</table>

也可以这样来区分：“类型转换”发生在静态类型语言的编译阶段（compile time），而“强制类型转换”则发生在动态类型语言的运行时（runtime）。

然而在JavaScript中我们将它们统称为*强制类型转换*，我个人则倾向于用“隐式强制类型转换”（implicit coercion）和“显式强制类型转换”（explicit coercion）来区分。

二者的区别显而易见：我们能够从代码中看出哪些地方是“显式强制类型转换”，而“隐式强制类型转换”就不那么明显，通常是某些操作产生的副作用。

例如：

```
    var a = 42;
    
    var b = a + "";         // implicit coercion
    
    var c = String( a );    // explicit coercion
```

对变量`b`而言，强制类型转换是隐式的，由于`+`运算符的其中一个操作数是`字符串`，所以是`字符串`拼接操作，结果是数字`42`被强制类型转换为相应的字符串`"42"`。

而`String(..)`则是将`a`显式强制类型转换为`字符串`。

两者都是将数字`42`转换为字符串`"42"`。然而它们各自不同的处理方式成为了争论的焦点。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="500px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">从技术角度来说，除了字面上的差别以外，二者在行为特征上也有一些细微的差别。我们将在下一章详细介绍，见<b>第87页“Implicitly: Strings &lt;--&gt; Numbers”</b>。</td>
    </tr>
</table>

这里的“显式”和“隐式”，以及“明显的副作用”和“隐藏的副作用“都是*相对而言*。

要是你明白`a + ""`是怎么回事，它对你来说就是“显式”的。相反如果你不知道`String(..)`可以用来做`字符串`强制类型转换，它对你来说可能就是“隐式”的。

我们在这里以普遍通行的标准来讨论“显式”和“隐式”，而非JS专家和规范的标准。如果你的理解与此有出入，请参照我们的标准。

要知道我们编写的代码大都是给别人看的。即便是JS高手也需要顾及其他不同水平的开发人员，要考虑他们是否能读懂自己的代码，以及他们对于“显式”和“隐式”的理解是否和自己一致。

##4.2 抽象值操作

介绍*显式*和*隐式*强制类型转换之前，我们需要掌握`字符串`，`数字`，和`布尔值`之间类型转换的基本规则。ES5规范第9节中定义了一些“抽象操作”（即“仅供内部使用的操作”）和转换规则。这里我们着重介绍`ToString`，`ToNumber`，和`ToBoolean`，附带讲一讲`ToPrimitive`。

###4.2.1 ToString

规范第9.8节中定义了抽象操作`ToString`，它负责处理非`字符串`到`字符串`的强制类型转换。

基本类型值的字符串化（stringification）规则为：`null`转换为`"null"`，`undefined`转换为`"undefined"`，`true`转换为`"true"`。`数字`的字符串化则遵循通用规则，不过`第2章`中讲过的那些极小和极大的`数字`使用指数形式：

```
    // multiplying `1.07` by `1000`, seven times over
    var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;

    // seven times three digits => 21 digits
    a.toString(); // "1.07e21"
```

对于普通对象来说，除非自行定义，否则`toString()`（`Object.prototype.toString()`）返回*内部*属性`[[Class]]`的值（见`第3章`），如：`"[object Object]"`。

然而前面我们介绍过，如果对象有自己的`toString()`方法，字符串化时就会调用该方法并使用其返回值。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="400px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">将对象强制类型转换为<b>string</b>是通过<b>ToPrimitive</b>抽象操作来完成的（ES5规范第9.1节），我们在此略过，稍后将在<b>ToNumber</b>一节中详细介绍。</td>
    </tr>
</table>

`数组`的默认`toString()`方法经过了重新定义，将所有单元字符串化以后再用`","`连接起来：

```
    var a = [1,2,3];

    a.toString(); // "1,2,3"
```

`toString()`可以被显式调用，或者在需要字符串化时自动调用。

####JSON字符串化

工具函数`JSON.stringify(..)`在将JSON对象序列化（serialize）为`字符串`时也用到了`ToString`。

请注意JSON字符串化并非严格意义上的强制类型转换，因为其中也涉及到`ToString`相关规则，所以这里顺带介绍一下。

对于大多数简单值来说，JSON字符串化和`toString()`的效果基本相同，只不过序列化的结果*总是*`字符串`：

```
    JSON.stringify( 42 );   // "42"
    JSON.stringify( "42" ); // ""42"" (a string with a
                            // quoted string value in it)
    JSON.stringify( null ); // "null"
    JSON.stringify( true ); // "true"

```

所有*安全的JSON值（JSON-safe）*都可以使用`JSON.stringify(..)`字符串化。安全的JSON值是指能够呈现为有效JSON格式的值。

为了简单起见，我们来看看什么是*不安全*的JSON值。`undefined`，`function`，`symbol`（ES6+），和包含循环引用（对象之间相互引用，形成一个无限循环）的`object`都是不符合JSON结构标准的值，支持JSON的语言无法处理它们。

`JSON.stringify(..)`在`对象`中遇到`undefined`，`function`，和`symbol`时会自动将其忽略，在`数组`中则会返回`null`（以保证单元位置不变）。

例如：

```
    JSON.stringify( undefined );        // undefined
    JSON.stringify( function(){} );     // undefined
 
    JSON.stringify(
       [1,undefined,function(){},4]
    );                                  // "[1,null,null,4]"
    JSON.stringify(
       { a:2, b:function(){} }
    );                                  // "{"a":2}"
```

对包含循环引用的对象执行`JSON.stringify(..)`会出错。

如果`对象`中定义了`toJSON()`方法，JSON字符串化时会首先调用该方法，然后用它的返回值来进行序列化（serialization）。

如果要对含有非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义`toJSON()`方法来返回一个安全的JSON值。

例如：

```
    var o = { };

    var a = { 
        b: 42,
        c: o,
        d: function(){}
    };

    // create a circular reference inside `a`
    o.e = a;
    
    // would throw an error on the circular reference
    // JSON.stringify( a );
    
    // define a custom JSON value serialization
    a.toJSON = function() {
        // only include the `b` property for serialization
        return { b: this.b };
    };
    
    JSON.stringify( a ); // "{"b":42}"
```

很多人误以为`toJSON()`返回的是JSON字符串化后的值，其实不然，除非我们确实想要对`字符串`进行字符串化（通常不会！）。`toJSON()`返回的应该是一个适当的值，可以是任何类型，然后再由`JSON.stringify(..)`对其进行字符串化。

也就是说`toJSON()`应该“返回一个能够被字符串化的安全的JSON值”，而不是“返回一个JSON字符串”。

例如：

```
    var a = {
        val: [1,2,3],

        // probably correct!
        toJSON: function(){
            return this.val.slice( 1 );
        }
    };
    
    var b = {
        val: [1,2,3],
        
        // probably incorrect!
        toJSON: function(){
            return "[" +
                this.val.slice( 1 ).join() +
            "]"; 
        }
    };
    
    JSON.stringify( a ); // "[2,3]"
    
    JSON.stringify( b ); // ""[2,3]""
```

这里第二个函数是对`toJSON`返回的`字符串`做字符串化，而非`数组`本身。

现在介绍几个不太为人知但却非常有用的功能。

我们可以向`JSON.stringify(..)`传递一个可选参数（optional argument）*replacer*，它可以是`数组`或者`函数`，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除，和`toJSON()`很像。

如果`replacer`是一个`数组`，那么它必须是一个`字符串数组`，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略。

如果`replacer`是一个`函数`，它会对`对象`本身调用一次，然后对`对象`中的每个属性各调用一次，每次传递两个参数，`key`和`value`。如果要忽略某个`key`就返回`undefined`，否则返回指定的*值*。

```
    var a = { 
        b: 42,
        c: "42",
        d: [1,2,3] 
    };
    
    JSON.stringify( a, ["b","c"] ); // "{"b":42,"c":"42"}"
    
    JSON.stringify( a, function(k,v){
        if (k !== "c") return v;
    } );
    // "{"b":42,"d":[1,2,3]}"
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="700px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba">
</td>
     <td style="border: none;">如果<i>replacer</i>是<b>函数</b>，它的参数<b>k</b>在第一次调用时为<b>undefined</b>（就是对对象本身调用的那次）。<b>if</b>语句将属性<b>"c"</b>排除掉。由于字符串化是递归的，因此数组<b>[1,2,3]</b>中的每个元素都会通过参数<b>v</b>传递给*replacer*，即<b>1，2，和3</b>，参数<b>k</b>是它们的索引值，即<b>0，1，和2</b>。</td>
    </tr>
</table>

`JSON.string`还有一个可选参数*space*，用来指定输出的缩进格式。*space*为正整数时是指定每一级缩进的字符数，它还可以是`字符串`，此时最前面的十个字符被用于每一级的缩进：

```
    var a = { 
        b: 42,
        c: "42",
        d: [1,2,3] 
    };
    
    JSON.stringify( a, null, 3 );
    // "{
￼   //      "b": 42,
    //      "c": "42",
    //      "d": [
    //          1, 
    //          2,
    //          3
    //      ]
    // }"

    JSON.stringify( a, null, "-----" );
    // "{
    // -----"b": 42,
    // -----"c": "42",
    // -----"d": [
    // ----------1,
    // ----------2,
    // ----------3
    // -----]
    // }"
```

请记住，`JSON.stringify(..)`并不是强制类型转换。在这里介绍是因为它涉及`ToString`强制类型转换，具体表现在以下两点：

1. `字符串`，`数字`，`布尔值`，和`null`的`JSON.stringify(..)`规则与`ToString`基本相同。

2. 如果传递给`JSON.stringify(..)`的`对象`中定义了`toJSON()`方法，那么该方法会在字符串化前调用，以便将`对象`转换为*安全的JSON值*。

###4.2.2 ToNumber

有时我们需要将非`数字`值当作`数字`来使用，比如数学运算。为此ES5规范在第9.3节定义了抽象操作`ToNumber`。

其中`true`转换为`1`，`false`转换为`0`。`undefined`转换为`NaN`，`null`转换为`0`。

`ToNumber`对`字符串`的处理基本遵循`数字`常量的相关规则／语法（见`第3章`）。处理失败时返回`NaN`（处理`数字`常量失败时会产生语法错误）。不同之处是`ToNumber`对以`0`开头的十六进制数并不按十六进制处理（而是按十进制，见`第2章`）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="300px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba">
</td>
        <td style="border: none;"><b>数字</b>常量的语法规则与<b>ToNumber</b>处理<b>字符串</b>所遵循的规则之间差别不大，这里不做进一步介绍，可参考ES5规范第9.3.1节。</td>
    </tr>
</table>

对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非`数字`的基本类型值，则再遵循以上规则将其强制转换为`数字`。

为了将值转换为相应的基本类型值，抽象操作`ToPrimitive`（见ES5规范第9.1节）会首先（通过内部操作`DefaultValue`，见ES5规范第8.12.8节）检查该值是否有`valueOf()`方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用`toString()`的返回值（如果存在）来进行强制类型转换。

如果`valueOf()`和`toString()`均不返回基本类型值的话会产生`TypeError`错误。

从ES5开始，使用`Object.create(null)`创建的对象`[[Prototype]]`属性为`null`，并且没有`valueOf()`和`toString()`方法，因此无法进行强制类型转换。详情请参考本系列的*《this & Object Prototypes》*一书中`[[Prototype]]`相关部分。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="250px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba">
</td>
        <td style="border: none;">我们稍后将详细介绍<b>数字</b>的强制类型转换，在下面的示例代码中我们假定<b>Number(..)</b>已经实现了此功能。</td>
    </tr>
</table>

例如：

```
    var a = {
        valueOf: function(){
            return "42";
        }
    };
    
    var b = {
        toString: function(){
            return "42";
        }
    };
    
    var c = [4,2];
    c.toString = function(){
        return this.join( "" ); // "42"
    };

    Number( a );            // 42
    Number( b );            // 42
    Number( c );            // 42
    Number( "" );           // 0
    Number( [] );           // 0
    Number( [ "abc" ] );    // NaN
```

###4.2.3 ToBoolean

下面介绍`布尔值`，关于这个主题存在许多误解和困惑，需要我们特别注意。

首先也是最重要的一点是，JS中有两个关键词`true`和`false`，分别代表`布尔`类型中的真和假。我们常误以为数值`1`和`0`分别等同于`true`和`false`。在有些语言中可能是这样，但在JS中`布尔值`和`数字`是不一样的。虽然我们可以将`1`强制类型转换为`true`，将`0`强制类型转换为`false`，反之亦然，但它们并不是一回事。

####假值（Falsy value）

我们再来看看其它值是如何被强制类型转换为`布尔`值的。

JavaScript中的值可以分为以下两类：

1. 可以被强制类型转换为`false`的值
2. 其他（被强制类型转换为`true`的值）

JS规范具体定义了一小撮可以被强制类型转换为`false`的值。

ES5规范第9.2节中定义了抽象操作`ToBoolean`，列举了`布尔`强制类型转换所有可能出现的结果。

以下这些是假值：

- `undefined`
- `null`
- `false`
- `+0`，`-0`和`NaN`
- `""`

假值的`布尔`强制类型转换结果为`false`。

从逻辑上说，假值列表以外的都应该是真值（“truthy”）。但JS规范对此并没有明确定义，只是给出了一些实例，例如规定所有的`对象`都是真值，我们可以理解为*假值列表以外的值都是真值*。

####假值对象（Falsy object）

这个标题似乎有点自相矛盾。前面讲过规范规定所有的`对象`都是真值，怎么还会有假值对象呢？

有人可能会以为假值对象就是包装了假值的封装对象（如：`""`，`0`，和`false`，见`第3章`），实际不然。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="100px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">这只是规范开的一个小玩笑。</td>
    </tr>
</table>

例如：

```
    var a = new Boolean( false );
    var b = new Number( 0 );
    var c = new String( "" );
```

它们都是封装了假值的对象（见`第3章`）。那它们究竟是`true`还是`false`呢？答案很简单：

```
    var d = Boolean( a && b && c );
    
    d; // true
```

`d`为`true`，说明`a，b，c`都为`true`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="400px" src="/api/storage/getbykey/screenshow?key=16047bc8813535bf18e1">
</td>
        <td style="border: none;">请注意这里Boolean(..)对<b>a &amp;&amp; b &amp;&amp; c</b>进行了封装，有人可能会问为什么。我们暂且记下，稍后会作说明。你可以试试不用Boolean(..)的话<b>d = a &amp;&amp; b &amp;&amp; c</b>会产生什么结果。</td>
    </tr>
</table>

如果“假值对象（falsy objects）”并非封装了假值的对象，那它究竟是什么？

值得注意的是，虽然JS代码中会出现`假值对象`，但它实际上并不属于JavaScript语言的范畴。

浏览器在某些特定情况下、在常规JS语法基础上自己了创建一些*外来（exotic）*值，这些就是“假值对象”。

“假值对象”看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为`布尔`值时结果为`false`。

最常见的例子是`document.all`，它是一个类数组（array-like）对象，包含了页面上的所有元素，由*DOM*（而不是JS引擎）提供给JS程序使用。它以前曾是一个真正意义上的对象，`布尔`强制类型转换结果为`true`，不过现在它是一个“假值对象”。

`document.all`并不是一个标准用法，早就被废止了。

有人也许会问：“既然这样的话浏览器能否将它彻底去掉？”，这个想法是好的，只不过仍然有很多JS程序在使用它。

那为什么它要是假值呢？因为我们经常通过将`document.all`强制类型转换为`布尔`值（比如在`if`语句中）来判断浏览器是否是老版本的IE。IE自诞生之日起就始（cong）终 （wei）遵循浏览器标准，较其他浏览器更为有（keng）力（die）地推动了Web的发展。

`if(document.all) { /* it's IE */ }`依然存在于许多程序中，也许会一直存在下去，这对IE的用户体验来说不是一件好事。

虽然我们无法彻底摆脱`document.all`，但为了让新版本更符合标准，IE并不打算继续支持`if (document.all) { .. }`。

“那我们应该怎么办？”，“也许可以修改JS的类型机制，将`document.all`作为假值来处理！”。这并不是一个好办法。大多数JS开发人员对这个坑了解得不多，不过更糟糕还是对其置若罔闻的态度。

####真值（Truthy value）

真值就是假值列表之外的值。

例如：

```
    var a = "false";
    var b = "0";
    var c = "''";

    var d = Boolean( a && b && c );
    
    d;
```

这里`d`应该是`true`还是`false`呢？

答案是`true`。上例的`字符串`看似`假值`，但所有`字符串`都是`真值`。`""`除外，它是`假值`列表中唯一的`字符串`。

再如：

```
    var a = [];             // empty array--truthy or falsy?
    var b = {};             // empty object--truthy or falsy?
    var c = function(){};   // empty function--truthy or falsy?

    var d = Boolean( a && b && c );
    
    d;
```

`d`依然是`true`。还是同样的道理，`[]`，`{}`，和`function(){}`都不在`假值`列表中，因此它们都是`真值`。

也就是说`真值`列表可以无限长，无法一一列举，所以我们只能用`假值`列表作为参考。

你可以花五分钟时间将`假值`列表写出来贴在显示器上，或者记在脑子里，在需要判断真／假值的时候就可以派上用场。

掌握真／假值重点在于理解`布尔`强制类型转换（显式和隐式），在此基础上我们就能对强制类型转换实例进行深入介绍。

##4.3 显式强制类型转换

*显式*强制类型转换（Explicit Coercion）是那些显而易见的类型转换，很多类型转换都属此列。

我们在编码时应尽可能地将类型转换表达清楚，以免给别人留坑。类型转换越清晰，代码可读性越高，更容易理解。

对*显式强制类型转换*几乎不存在非议，它类似静态语言中的类型转换，已被广为接受，不会有什么坑。我们后面会再讨论这个话题。

###4.3.1 字符串和数字之间的显式转换

我们从最常见的`字符串`和`数字`之间的强制类型转换开始。

`字符串`和`数字`之间的转换是通过`String(..)`和`Number(..)`这两个内建函数（“原生构造函数”，见`第3章`）来实现，请注意它们前面没有`new`关键字，并不创建封装对象。

下面是两者之间的显式强制类型转换：

```
    var a = 42;
    var b = String( a );
    
    var c = "3.14";
    var d = Number( c );
    
    b; // "42"
    d; // 3.14
```

`String(..)`遵循前面讲过的`ToString`规则，将值转换为`字符串`基本类型。`Number(..)`遵循前面讲过的`ToNumber`规则，将值转换为`数字`基本类型。

它们和静态语言中的类型转换很像，一目了然，所以我们将它们归为*显式*强制类型转换。

例如，在C/C++中我们可以使用`(int)x`或`int(x)`将`x`转换为整数。大部分人倾向于后者，因为它看起来更象函数调用。JavaScript中的`Number(x)`与此十分类似，至于它是否真是一个函数并不重要。

除了`String(..)`和`Number(..)`以外，还有其他方法可以实现`字符串`和`数字`之间的“显式”转换：

```
    var a = 42;
    var b = a.toString();
    
    var c = "3.14";
    var d = +c;

    b; // "42"
    d; // 3.14
```

`a.toString()`是显式的（“toString”意为“to a string”），不过其中涉及隐式转换。因为`toString()`对`42`这样的基本类型值不适用，所以JS引擎会自动为`42`创建一个封装对象（见`第3章`），然后对该对象调用`toString()`。这里显式转换中含有隐式转换。

上例中`+c`是`+`运算符的*一元（unary）*形式（即只有一个操作数）。`+`运算符显式地将`c`转换为`数字`，而非数字加法运算（也不是字符串拼接－－见下）。

`+c`是显式还是隐式，取决于你自己的理解和经验。如果你已然知道一元运算符`+`会将操作数显式强制类型转换为`数字`，那它就是显式的。如果不明就里的话它就是隐式强制类型转换，让你摸不着头脑。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="150px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba">
</td>
        <td style="border: none;">在JS开源社区中，一元运算<b>+</b>被普遍认为是<i>显式</i>强制类型转换。</td>
    </tr>
</table>

不过这样有时候也容易产生误会。例如：

```
    var c = "3.14";
    var d = 5+ +c;

    d; // 8.14
```

一元运算符`-`和`+`一样，并且它还会反转（flip）数字的符号位。由于`--`会被当作递减运算符来处理，所以我们不能使用`--`来撤销反转，而应该象`- -"3.14"`这样，在中间加一个空格，才能得到正确结果`3.14`。

下面是一个疯狂的例子：

```
    1 + - + + + - + 1;  // 2
```

尽量不要把一元运算符`+`（还有`-`）和其他运算符放在一起使用。上面的例子可以运行，但这样的代码很糟糕。此外`d = +c`（还有`d =+ c`）也容易和`d += c`搞混，两者天壤之别。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="300px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">一元运算符<b>+</b>紧挨着<b>++</b>和<b>--</b>也很容易引起混淆。例如<b>a +++b</b>，<b>a + ++b</b>，和<b>a + + +b</b>。有关<b>++</b>请参见<b>第125页“表达式的副作用”</b>。</td>
    </tr>
</table>

####日期显式转换为数字

一元运算符`+`的另一个常见用途是将`日期（Date）`对象强制类型转换为`数字`，返回结果为Unix时间戳，以微秒为单位（从1970年1月1日00:00:00 UTC到当前时间）：

```
    var d = new Date( "Mon, 18 Aug 2014 08:53:06 CDT" );

    +d; // 1408369986000
```

我们常用下面的方法来获得当前的时间戳，例如：

```
    var timestamp = +new Date();
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="600px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">JavaScript有一处奇特的语法，即构造函数没有参数时可以不用带<b>()</b>。于是我们可能会碰到<b> var timestamp = +new Date; </b>这样的写法。这样能否提高代码可读性还存在争议，因为这仅用于<b> new fn() </b>，对一般的函数调用<b> fn() </b>并不适用。</td>
    </tr>
</table>

将`日期`对象转换为时间戳并非只有强制类型转换这一种方法，或许使用更显式的方法会更好一些：

```
    var timestamp = new Date().getTime();
    // var timestamp = (new Date()).getTime();
    // var timestamp = (new Date).getTime();
```

不过*最好*还是使用ES5中新加入的静态方法`Date.now()`：

```
    var timestamp = Date.now();
```

为老版本浏览器提供 `Date.now()`的polyfill也很简单：

```
    if (!Date.now) {
        Date.now = function() {
            return +new Date();
        };
    }
```

我们不建议对`日期`类型使用强制类型转换，应该使用`Date.now()`来获得当前的时间戳，使用`new Date(..).getTime()`来获得指定时间的时间戳。

####奇特的~运算符

一个常被人忽视的地方是`~`运算符（即字位操作“非”）相关的强制类型转换，它很让人费解，以至于了解它的开发人员也常常对其敬而远之。秉承本书的一贯宗旨，我们在此深入探讨一下`~`有哪些用处。

在`第23页的“32位有符号整数”`中我们讲过字位运算符只适用于32位整数，运算符会强制操作数使用32位格式。这是通过抽象操作`ToInt32`来实现的（ES5规范第9.5节）。

`ToInt32`首先执行`ToNumber`强制类型转换，比如`"123"`会先被转换为`123`，然后再执行`ToInt32`。

虽然严格说来并非强制类型转换（因为返回值类型并没有发生变化），但字位运算符（如`|`和`~`）和某些特殊`数字`一起使用时会产生类似强制类型转换的效果，返回另外一个`数字`。

例如`|`运算符（字位操作“或”）的空操作（no-op）`0 | x`，它仅执行`ToInt32`转换（`第2章`中介绍过）：

```
    0 | -0;         // 0
    0 | NaN;        // 0
    0 | Infinity;   // 0
    0 | -Infinity;  // 0
```

以上这些特殊数字无法以32位格式呈现（因为它们来自64位IEEE 754标准，见`第2章`），因此`ToInt32`返回`0`。

关于`0 | ___`是*显式*还是*隐式*仍存在争议。从规范的角度来说它无疑是*显式*的，但如果对字位运算符没有这样深入的理解，它可能就是*隐式*的。为了前后保持一致，我们这里将其视为*显式*。

再回到`~`。它首先将值“强制类型转换”为`32位数字`，然后执行字位操作“非”（对每一个字位进行反转）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="300px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">这与<b>!</b>很相像，不仅将值强制类型转换为<b>布尔值</b>，还对其做字位反转（见第83页的<b>“显式转换为布尔值”</b>）。</td>
    </tr>
</table>

字位反转是个很晦涩的主题，JS开发人员一般很少需要关心到字位级别。

对`~`还可以有另外一种诠释，源自早期的计算机科学和离散数学：`~`返回2的补码。这样一来问题就清楚多了！

`~x`大致等同于`-(x+1)`。很奇怪，但相对更容易说明问题：

```
    ~42;    // -(42+1) ==> -43
```

也许你还是没有完全弄明白`~`到底是什么玩意？为什么把它放在强制类型转换一章中介绍？稍安勿躁。

在`-(x+1)`中唯一能够得到`0`（或者严格说是`-0`）的`x`值是`-1`。也就是说如果`x`为`-1`时，`~`和一些`数字`值在一起会返回假值`0`，其他情况则返回真值。

然而这与我们讨论的内容有什么关系呢？

`-1`是一个“哨位值（sentinel value）”，`哨位值`是那些在各个类型中（这里是`数字`）被赋予了特殊含义的值。在C语言中我们用`-1`来代表函数执行失败，用大于等于`0`的值来代表函数执行成功。

JavaScript中`字符串`的`indexOf(..)`方法也遵循这一惯例，该方法在字符串中搜索指定的子字符串，如果找到就返回子字符串所在的位置（从0开始），否则返回`-1`。

`indexOf(..)`不仅能够得到子字符串的位置，还可以用来检查字符串中是否包含指定的子字符串，相当于一个条件判断。例如：

```
    var a = "Hello World";
    
    if (a.indexOf( "lo" ) >= 0) {   // true
        // found it!
    }
    if (a.indexOf( "lo" ) != -1) {  // true
        // found it }
    if (a.indexOf( "ol" ) < 0) {    // true
        // not found!
    }
    if (a.indexOf( "ol" ) == -1) {  // true
        // not found!
    }
```

`>= 0`和`== -1`这样的写法不是很好，称为“抽象渗漏（leaky abstraction）”，意思是在代码中暴露了底层的实现细节，这里是指用`-1`作为失败时的返回值，这些细节应该被屏蔽掉。

现在我们终于明白`~`有什么用处了！`~`和`indexOf()`一起可以将结果“强制类型转换”（实际上仅仅是转换）为真／假值：

```
    var a = "Hello World";
    
    ~a.indexOf( "lo" );         // -4 <-- truthy!
    
    if (~a.indexOf( "lo" )) {   // true
        // found it!
    }
    
    ~a.indexOf( "ol" );         // 0  <-- falsy!
    !~a.indexOf( "ol" );        // true
    
    if (!~a.indexOf( "ol" )) {  // true
        // not found!
    }
```

如果`indexOf(..)`返回`-1`，`~`将其转换为`假值0`，其他情况一律转换为`真值`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="250px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">由<b>-(x+1)</b>推断<b>~-1</b>的结果应该是<b>-0</b>，然而实际上结果是<b>0</b>，因为它是字位操作而非数学运算。</td>
    </tr>
</table>

从技术角度来说，`if (~a.indexOf(..))`仍然是对`indexOf(..)`的返回结果进行*隐式*强制类型转换，`0`转换为`false`，其他情况转换为`true`。但我觉得`~`更象*显式*强制类型转换，前提是我对它有充分的理解。

个人认为`~`比`>= 0`和`== -1`更简洁。

####字位截除

一些开发人员使用`~~`来截除（truncate）`数字`值的小数部分，以为这和`Math.floor(..)`的效果一样，实际上并非如此。

`~~`中的第一个`~`执行`ToInt32`并反转字位，然后第二个`~`再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是`ToInt32`的结果。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="200px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;"><b>~~</b>和<b>!!</b>很相似，我们将在<b>第83页“显式转换为布尔值”</b>一节中介绍。</td>
    </tr>
</table>

对`~~`我们要多加注意。首先它只适用于32位数字，更重要的是它对负数的处理与`Math.floor(..)`不同。

```
    Math.floor( -49.6 );    // -50
    ~~-49.6;                // -49
```

`~~x`能将值截除为一个32位整数，`x | 0`也可以，而且看起来还更*简洁*。

出于对运算符优先级（详见`第5章`）的考虑，我们可能更倾向于使用`~~x`：

```
    ~~1E20 / 10;        // 166199296
    1E20 | 0 / 10;      // 1661992960
    (1E20 | 0) / 10;    // 166199296
```

我们在使用`~`和`~~`进行此类转换时需要确保其他人也能够看得懂。

###4.3.2 显式解析数字字符串

解析`字符串`中的`数字`和将`字符串`强制类型转换为`数字`的返回结果都是`数字`。但解析和转换两者之间还是有明显的差别。

例如：

```
    var a = "42";
    var b = "42px";

    Number( a );    // 42
    parseInt( a );  // 42
    
    Number( b );    // NaN
    parseInt( b );  // 42
```

解析*允许*`字符串`中含有非`数字`字符，解析按从左到右的顺序，如果遇到非`数字`字符就停止。而转换*不允许*出现非`数字`字符，否则会失败并返回`NaN`。

解析和转换之间不是相互替代的关系。它们虽然类似，但各有各的用途。如果`字符串`右边的非`数字`字符不影响结果，就可以使用解析。而转换要求`字符串`中所有的字符都是数字，象"42px"这样的`字符串`就不行。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="150px" src="/api/storage/getbykey/screenshow?key=16047bc8813535bf18e1">
</td>
        <td style="border: none;">解析字符串中的浮点数可以使用<b>parseFloat(..)</b>函数。
        </td>
    </tr>
</table>

不要忘了`parseInt(..)`针对的是`字符串`值。向`parseInt(..)`传递`数字`和其他类型的参数是没有用的，比如：`true`，`function(){...}`，和`[1,2,3]`。

非`字符串`参数会首先被强制类型转换为`字符串`（见`第59页的“ToString”`），依赖这样的*隐式*强制类型转换并非上策，应该避免向`parseInt(..)`传递非`字符串`参数。

ES5之前的`parseInt(..)`有一个坑导致了很多bug。即如果没有第二个参数来指定转换的基数（又称为radix），`parseInt(..)`会根据`字符串`的第一个字符来自行决定基数。

如果第一个字符是`x`或`X`，则转换为十六进制`数字`。如果是`0`则转换为八进制`数字`。

以'x'和'X'开头的十六进制相对来说还不是很容易搞错，八进制则不然。例如：

```
    var hour = parseInt( selectedHour.value );
    var minute = parseInt( selectedMinute.value );
    
    console.log(
       "The time you selected was: " + hour + ":" + minute
);
```

上面的代码看似没有问题，但是当小时为`08`、分钟为`09`时结果是`0:0`，因为`8`和`9`都不是有效的八进制数。

*将第二个参数设置为10*即可避免这个问题：

```
    var hour = parseInt( selectedHour.value, 10 );
    var minute = parseInt( selectedMiniute.value, 10 );
```

从ES5开始`parseInt(..)`默认转换为十进制数，除非另外指定。如果你的代码需要在ES5之前的环境运行，请记得将第二个参数设置为`10`。

####解析非字符串

曾经有人发帖吐槽过`parseInt(..)`的一个坑：

```
    parseInt( 1/0, 19 ); // 18
```

很多人想当然地以为（实际上大错特错）“如果第一个参数值为`Infinity`，解析结果也应该是`Infinity`”，返回`18`也太无厘头了。

尽管这个例子纯属虚构，我们还是来看看JS是否真的这样无厘头。 

其中第一个错误是向`parseInt(..)`传递非`字符串`，这完全是在自找麻烦。此时JS会将参数强制类型转换为它能够处理的`字符串`。

有人可能会觉得这不合理，`parseInt(..)`应该拒绝接受非`字符串`参数。但如果这样的话它是否应该抛出一个错误？这是Java的做法。一想到JS代码中到处是抛出的错误，要在每个地方加上`try..catch`，我整个人都不好了。

那是不是应该返回`NaN`？也许吧，但是下面的情况是否应该运行失败？

```
    parseInt( new String( "42") );
```

因为它的参数也是一个非`字符串`。如果你认为此时应该将`String`封装对象拆封（unbox）为`"42"`，那么将`42`先转换为`"42"`、再解析回`42`不也合情合理吗？

这种半*显式*
、半*隐式*的强制类型转换很多时候非常有用。例如：

```
    var a = {
        num: 21,
        toString: function() { return String( this.num * 2 ); }
    };

    parseInt( a ); // 42
```

`parseInt(..)`先将参数强制类型转换为`字符串`再进行解析，这样做没有任何问题。因为传递错误的参数而得到错误的结果，并不能归咎于函数本身。

怎么来处理`Infinity`（`1/0`的结果）最合理呢？有两个选择：`"Infinity"`和`"∞"`，JS选择的是`"Infinity"`。

JS中所有的值都有一个默认的`字符串`形式，这很不错，能够方便我们调试。

再回到基数19，这显然是个玩笑话，在实际的JS代码中我们不会用到基数19。它的有效数字字符范围是`0-9`和`a-i`（区分大小写）。

`parseInt(1/0, 19)`实际上是`parseInt("Infinity", 19)`。第一个字符是"I"，以19为基数时值为`18`。第二个字符`"n"`不是一个有效的数字字符，解析到此为止，和`"42px"`中的`"p"`一样。

最后的结果是`18`，而非`Infinity`或者报错。所以理解其中的工作原理对于我们学习JS是*非常重要*的。

此外还有一些看起来奇怪但实际上解释得通的例子：

```
    parseInt( 0.000008 );       // 0   ("0" from "0.000008")
    parseInt( 0.0000008 );      // 8   ("8" from "8e-7")
    parseInt( false, 16 );      // 250 ("fa" from "false")
    parseInt( parseInt, 16 );   // 15  ("f" from "function..")
    
    parseInt( "0x10" );         // 16
    parseInt( "103", 2 );       // 2
```

其实`parseInt(..)`函数是十分靠谱的，只要使用得当就不会有问题。因为使用不当而导致一些莫名其妙的结果，并不能归咎于JavaScript本身。

###4.3.3 显式转换为布尔值

现在我们来看看从非`布尔值`强制类型转换为`布尔值`的情况。

与前面的`String(..)`和`Number(..)`一样，`Boolean(..)`（不带`new`）是显式的`ToBoolean`强制类型转换：

```
    var a = "0";
    var b = [];
    var c = {};

    var d = "";
    var e = 0;
    var f = null;
    var g;
    
    Boolean( a ); // true
    Boolean( b ); // true
    Boolean( c ); // true
    
    Boolean( d ); // false
    Boolean( e ); // false
    Boolean( f ); // false
    Boolean( g ); // false
```

虽然`Boolean(..)`是显式的，但并不常用。

和前面讲过的`+`类似，一元运算符`!`显式地将值强制类型转换为`布尔值`。但是它同时还将真值反转为假值（或者将假值反转为真值）。所以显式强制类型转换为`布尔值`最常用的方法是`!!`，因为第二个`!`会将结果反转回原值：

```
    var a = "0";
    var b = [];
    var c = {};

    var d = "";
    var e = 0;
    var f = null;
    var g;

    !!a; // true
    !!b; // true
    !!c; // true

    !!d; // false
    !!e; // false
    !!f; // false
    !!g; // false
```

在`if(..)..`这样的`布尔值`上下文中，如果没有使用`Boolean(..)`和`!!`，就会自动*隐式*地进行`ToBoolean`转换。建议使用`Boolean(..)`和`!!`来进行显式转换以便让代码更清晰易读。

显式`ToBoolean`的另外一个用处，是在JSON序列化过程中将值强制类型转换为`true`或`false`：

```
    var a = [ 1,
            function(){ /*..*/ },
            2,
            function(){ /*..*/ }
    ];

    JSON.stringify( a ); // "[1,null,2,null]"

    JSON.stringify( a, function(key,val){
        if (typeof val == "function") {
            // force `ToBoolean` coercion of the function
            return !!val;
        }
        else {
            return val;
    } } );
    // "[1,true,2,true]"
```

下面的语法对于熟悉Java的人并不陌生：

```
    var a = 42;

    var b = a ? true : false;
```

三元运算符`? :`判断`a`是否为真，如果是则将变量`b`赋值为`true`，否则赋值为`false`。

表面上这是一个*显式*的`ToBoolean`强制类型转换，因为返回结果是`true`或者`false`。

然而这里涉及*隐式*强制类型转换，因为`a`要首先被强制类型转换为`布尔值`才能进行条件判断。这种情况称为“显式的隐式”，有百害而无一益，我们应彻底杜绝。

建议使用`Boolean(a)`和`!!a`来进行显式强制类型转换。

##4.4 隐式强制类型转换

*隐式*强制类型转换（implicit coercion）指的是那些隐蔽的强制类型转换，副作用（side effects）也不是很明显。换句话说，你自己觉得不够明显的强制类型转换都可以算做*隐式*强制类型转换。

*显式*强制类型转换旨在让代码更加清晰易读，而*隐式*强制类型转换看起来就象是它的对立面，会让代码变得晦涩难懂。

对强制类型转换的诟病大多是针对*隐式*强制类型转换。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="800px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba">
</td>
        <td style="border: none;"><i>《JavaScript: The Good Parts》</i>的作者Douglas Crockford在许多场合和文章中都主张不要使用强制类型转换，认为其非常糟糕。然而他的代码中也大量使用了<i>隐式</i>和<i>显式</i>强制类型转换。实际上他的吐槽大部分是针对<b>==</b>运算符，但读完本章你会发现这只是强制类型转换的冰山一角。</td>
    </tr>
</table>

问题是隐式强制类型转换真是如此不堪吗？它是不是JavaScript语言的设计缺陷？我们是否应该对其退避三舍？

估计大多数读者会回答“是的！”。其实不然，请容我细细道来。

让我们从另一个角度来看待*隐式*强制类型转换，看看它究竟为何物、该如何使用，不要简单地把它当作“显式强制类型转换的对立面”，因为这样理解过于狭隘，忽略了它们之间一个细微却十分重要的区别。

*隐式*强制类型转换的作用是减少冗余，让代码更简洁。

###4.4.1 隐式地简化

我们先来看一个例子，它不是JavaScript代码，而是强类型语言的伪代码（pseudo code）：

```
    SomeType x = SomeType( AnotherType( y ) )
```

其中变量`y`的值被转换为`SomeType`类型。问题是语言本身不允许直接将`y`转换为`SomeType`类型。于是我们需要一个中间步骤，先将`y`转换为`AnotherType`类型，然后再从`AnotherType`转换为`SomeType`。

如果能够这样：

```
    SomeType x = SomeType( y )
```

省去了中间步骤以后，类型转换变得更简洁了。这些无关紧要的中间步骤可以也应该被隐藏。

也许有些情况下这些中间步骤还是必要的，但是我觉得通过语言机制或定制方法来简化（simplification）代码，抽象和隐藏那些细枝末节，有助于提高代码的可读性。

当然这些中间步骤仍然会发生在某处。通过隐藏这些细节，我们就可以专注于问题本身，这里是将变量`y`转换为`SomeType`类型。

虽然这并非是个十分恰当的*隐式*强制类型转换的例子，但我想说明的问题是，*隐式*强制类型转换同样可以用来提高代码可读性。

然而*隐式*强制类型转换也会带来一些负面影响，有时甚至是弊大于利。因此我们更应该学习怎样去其糟粕，取其精华。

很多开发人员认为如果某个机制有优点*A*但同时又有缺点*Z*，为了保险起见不如全部弃之不用。

我不赞同这种“因噎废食”的做法。不要因为只看到了*隐式*强制类型转换的缺点就想当然地认为它一无是处。它也有好的方面，希望越来越多的开发人员能加以发现和运用。

###4.4.2 字符串和数字之间的隐式强制类型转换

前面我们讲了`字符串`和`数字`之间的*显式*强制类型转换，现在介绍它们之间的*隐式*强制类型转换。先来看一些会产生*隐式*强制类型转换的操作。

通过重载（overloading），`+`运算符即能用于`数字`加法，也能用于`字符串`拼接。JS怎样来判断我们要执行的是哪个操作？例如：

```
    var a = "42";
    var b = "0";

    var c = 42;
    var d = 0;
    
    a + b; // "420"
    c + d; // 42
```

这里为什么会得到`"420"`和`42`两个不同的结果呢？通常的理解是，因为某一个或者两个操作数都是`字符串`，所以`+`执行的是`字符串`拼接操作。这样解释只对了一半，实际情况要复杂得多。

例如：

```
    var a = [1,2];
    var b = [3,4];

    a + b; // "1,23,4"
```

`a`和`b`都不是`字符串`，但是它们都被强制转换为`字符串`然后进行拼接。原因何在？

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="150px" src="/api/storage/getbykey/screenshow?key=1604f65453ba2fc131a7"></td>
        <td style="border: none;">下面两段内容来自规范，如果太难理解可以跳过。</td>
    </tr>
</table>

根据ES5规范第11.6.1节，如果某个操作数是`字符串`或者能够通过以下步骤转换为`字符串`的话，`+`将进行拼接操作。如果其中一个操作数是`对象`（包括`数组`），则首先对其调用`ToPrimitive`抽象操作（第9.1节），该抽象操作再调用`[[DefaultValue]]`（第8.12.8节），以`数字`作为上下文。

你或许注意到这与`ToNumber`抽象操作处理`对象`的方式一样（见`第65页“ToNumber”`）。因为`数组`的`valueOf()`操作无法得到简单基本类型值，于是它转而调用`toString()`。因此上例中的两个数组变成了`"1,2"`和`"3,4"`。`+`将它们拼接后返回`"1,23,4"`。

简单来说就是，如果`+`的其中一个操作数是`字符串`（或者通过以上步骤可以得到`字符串`），则执行`字符串`拼接。否则执行`数字`加法。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="350px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">有一个坑常常被提到，即<b>[] + {}</b>和<b>{} + []</b>，它们返回不同的结果，分别是<b>"[object Object]"</b>和<b>0</b>。我们将在<b>第134页“代码块”一节</b>详细介绍。</td>
    </tr>
</table>

我们可以将`数字`和空`字符串 ""`相`+`来将其转换为`字符串`：

```
    var a = 42;
    var b = a + "";
    
    b; // "42"
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="300px" src="/api/storage/getbykey/screenshow?key=16047bc8813535bf18e1"></td>
        <td style="border: none;"><b>+</b>作为数字加法操作是可互换的，即<b>2 + 3</b>等同于<b>3 + 2</b>。作为字符串拼接操作则不行，但对于空字符串<b>""</b>来说，<b>a + ""</b>和<b>"" + a</b>结果一样。</td>
    </tr>
</table>

`a + ""`这样的*隐式*转换十分常见，一些对*隐式*强制类型转换持批评态度的人也不能免俗。

这本身就很能说明问题，无论怎样被人诟病，*隐式强制类型转换*仍然有它的用武之地。

`a + ""`（隐式）和前面的`String(a)`（显式）之间有一个细微的差别需要注意。根据`ToPrimitive`抽象操作规则，`a + ""`会对`a`调用`valueOf()`方法，然后通过`ToString`抽象操作将返回值转换为`字符串`。而`String(a)`则是直接调用`ToString()`。

它们最后返回的都是`字符串`，但如果`a`是`对象`而非`数字`结果可能会不一样！

例如：

```
    var a = {
        valueOf: function() { return 42; },
        toString: function() { return 4; }
    };
    
    a + ""; // "42"
    
    String( a );    // "4"
```

你一般不太可能会遇到这个问题，除非你的代码中真的有这些匪夷所思的数据结构和操作。在定制`valueOf()`和`toString()`方法时需要特别小心，因为这会影响到强制类型转换的结果。

我们再来看看从`字符串`强制类型转换为`数字`情况。

```
    var a = "3.14";
    var b = a - 0;
    
    b; // 3.14
```

`-`是数字减法运算符，因此`a - 0`会将`a`强制类型转换为`数字`。也可以使用`a * 1`和`a / 1`，因为这两个运算符也只适用于数字，只不过这样的用法不太常见。

`对象`的`-`操作与`+`类似：

```
    var a = [3];
    var b = [1];
    
    a - b; // 2
```

为了执行减法运算，`a`和`b`都需要被转换为`数字`，它们首先被转换为`字符串`（通过`toString()`），然后再转换为`数字`。

`字符串`和`数字`之间的*隐式*强制类型转换真如人们所说的那样糟糕吗？我个人不这么看。

`b = String(a)`（*显式*）和`b = a + ""`（*隐式*）各有优点，`b = a + ""`更常见一些。虽然饱受诟病，*隐式*强制类型转换仍然有它的用处。

###4.4.3 布尔值到数字的隐式强制类型转换

在将某些复杂的`布尔`逻辑转换为数字加法的时候，*隐式*强制类型转换能派上大用场。当然这种情况并不多见，属于特殊情况特殊处理。

例如：

```
    function onlyOne(a,b,c) {
        return !!((a && !b && !c) ||
            (!a && b && !c) || (!a && !b && c));
    }
    
    var a = true;
    var b = false;
    
    onlyOne( a, b, b ); // true
    onlyOne( b, a, b ); // true
    
    onlyOne( a, b, a ); // false
```

如果其中有且仅有一个参数为`true`（真值），则`onlyOne(..)`返回`true`。其在条件判断中使用了*隐式*强制类型转换，其他地方则是*显式*的，包括最后的返回值。

但如果有多个参数时（四个，五个，甚至二十个），用上面的代码就很难处理了。这时就可以使用从`布尔值`到`数字`（`0或1`）的强制类型转换：

```
    function onlyOne() {
        var sum = 0;
        for (var i=0; i < arguments.length; i++) {
            // skip falsy values. same as treating
            // them as 0's, but avoids NaN's.
            if (arguments[i]) {
                sum += arguments[i];
            }
        }
        return sum == 1;
    }
   
    var a = true;
    var b = false;
   
    onlyOne( b, a );                // true
    onlyOne( b, a, b, b, b );       // true
   
    onlyOne( b, b );                // false
    onlyOne( b, a, b, b, b, a );    // false
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="180px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba">
</td>
        <td style="border: none;">在<b>onlyOne(..)</b>中除了使用<b>for</b>循环，还可以使用ES5规范中的reduce(..)函数。</td>
    </tr>
</table>

我们通过`sum += arguments[i]`中的*隐式*强制类型转换，将真值（true/truthy）转换为`1`并进行累加。如果有且仅有一个参数为`true`，则结果为`1`，否则不等于`1`，`sum == 1`条件不成立。

同样的功能也可以通过*显式*强制类型转换来实现：

```
    function onlyOne() {
        var sum = 0;
        for (var i=0; i < arguments.length; i++) {
            sum += Number( !!arguments[i] );
        }
        return sum === 1;
    }
```

`!!arguments[i]`首先将参数转换为`true`或`false`。因此非`布尔值`参数在这里也是可以的，比如：`onlyOne("42", 0)`（否则的话`字符串`会执行拼接操作，这样结果就不对了）。

转换为`布尔值`以后，再通过`Number(..)`*显式*强制类型转换为`0`或`1`。

这里使用*显式*强制类型转换会不会更好一些？注释里说这样的确能够避免`NaN`带来的问题，不过最终是看我们自己的需要。我个人觉得前者，即*隐式*强制类型转换，更为简洁（前提是我们不会传递`undefined`和`NaN`这样的值），而*显式*强制类型转换则会带来一些代码冗余。

总之如本书一贯强调的那样，一切都取决于我们自己的判断和权衡。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="520px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba">
</td>
        <td style="border: none;">无论使用<i>隐式</i>还是<i>显式</i>，我们都能通过修改<b>onlyTwo(..)</b>或者<b>onlyFive(..)</b>来处理更复杂的情况，只需要将最后的条件判断从<b>1</b>改为<b>2</b>或者<b>5</b>。这比加入一大堆<b>&amp;&amp;</b>和<b>||</b>表达式要简洁的多。所以强制类型转换在这里还是很有用的。</td>
    </tr>
</table>

###4.4.4 隐式强制类型转换为布尔值

现在我们来看看到`布尔值`的*隐式*强制类型转换，它最为常见也最容易搞错。

相对`布尔值`，`数字`和`字符串`操作中的*隐式*强制类型转换还算比较明显。下面的情况会发生`布尔值`*隐式*强制类型转换：

1. `if (..)`语句中的条件判断表达式
2. `for ( .. ; .. ; .. )`语句中的条件判断表达式（第二个）
3. `while (..)`和`do..while(..)`循环中的条件判断表达式
4. `? :`中的条件判断表达式
5. 逻辑运算符`||`（逻辑或）和`&&`（逻辑与）左边的操作数（作为条件判断表达式）。

以上情况中，非`布尔值`会被*隐式*强制类型转换为`布尔值`，遵循前面介绍过的`ToBoolean`抽象操作规则。

例如：

```
    var a = 42;
    var b = "abc";
    var c;
    var d = null;
    
    if (a) {
        console.log( "yep" );   // yep
    }

    while (c) {
        console.log( "nope, never runs" );
    }

    c = d ? a : b; 
    c;                          // "abc"
    
    if ((a && d) || c) {
        console.log( "yep" );   // yep
    }
```

上例中的非`布尔值`会被*隐式*强制类型转换为`布尔值`以便执行条件判断。

###4.4.5 ||和&&

逻辑运算符`||`（或）和`&&`（与）对我们应该并不陌生，也许正因为如此有人觉得它们在JavaScript中的表现也和在其它语言中一样。

这里面有一些非常重要但却不太为人所知的细微差别。

我其实不太赞同将它们称为“逻辑运算符”，因为这不十分准确。称它们为“选择器运算符（selector operators）”或者“操作数选择器运算符（operand selector operators）”更恰当些。

因为和其他语言不同，在JavaScript中它们返回的并不是`布尔值`。

它们的返回值是两个操作数中的一个（且仅一个）。即选择两个操作数中的一个，然后返回它的值。

引述ES5规范第11.11节：

*&&和||运算符的返回值并不一定是`布尔`类型，而是两个操作数其中一个的值。*

例如：

```
    var a = 42;
    var b = "abc";
    var c = null;

    a || b;     // 42 
    a && b;     // "abc"
    
    c || b;     // "abc" 
    c && b;     // null
```

在C和PHP中，上例的结果是`true`或`false`，在JS（以及Python和Ruby）中却是某个操作数的值。

`||`和`&&`首先会对*第一个操作数*（`a`和`c`）执行条件判断，如果其不是`布尔值`（如上例）就先进行`ToBoolean`强制类型转换，然后再执行条件判断。

对于`||`来说，如果条件判断结果为`true`就返回第一个操作数（`a`和`c`）的值。如果为`false`就返回第二个操作数（`b`）的值。

`&&`则相反，如果条件判断结果为`true`就返回第二个操作数（`b`）的值。如果为`false`就返回第一个操作数（`a`和`c`）的值。

`||`和`&&`返回它们其中一个操作数的值，而非条件判断的结果（其中可能涉及强制类型转换）。`c && b`中`c`为`null`，是一个假值，因此`&&`表达式的结果是`null`（即`c`的值），而非条件判断的结果`false`。

现在你明白我为什么把它们叫做“操作数选择器”了吧？

换一个角度来理解：

```
    a || b;
    // 大致相当于(roughly equivalent to):
    a ? a : b;

    a && b;
    // 大致相当于(roughly equivalent to):
    a ? b : a;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="900px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba">
</td>
        <td style="border: none;">之所以说大致相当（roughly equivalent），是因为它们返回结果虽然相同但是却有一个细微的差别。在<b>a ? a : b</b>中，如果<b>a</b>是一个复杂一些的表达式（比如有副作用的函数调用等），它有可能被执行两次（如果第一次结果为真）。而在<b>a || b</b>中<b>a</b>只执行一次，其结果用于条件判断和返回结果（如果适用的话）。<b>a &amp;&amp; b</b>和<b>a ? b : a</b>也是如此。</td>
    </tr>
</table>

下面是一个十分常见的`||`的用法，也许你已经用过但并未完全理解：

```
    function foo(a,b) {
        a = a || "hello";
        b = b || "world";
     
        console.log( a + " " + b );
    }

    foo();                  // "hello world"
    foo( "yeah", "yeah!" ); // "yeah yeah!"
```

`a = a || "hello"`（又称为C#的“空值合并运算符，null coallescing operator”的JavaScript版本）检查变量`a`，如果还未赋值（或者为假值）就赋予它一个默认值（`"hello"`）。

这里需要注意！

```
    foo( "That's it!", "" ); // "That's it! world" <-- Oops!
```

第二个参数`""`是一个`假值`（`falsy value`，见`第67页的“ToBoolean”`），因此`b = b || "world"`条件不成立，返回缺省值`"world"`。

这种用法很常见，但是其中不能有`假值`，除非加上更明确的条件判断，或者转而使用`? :`三元表达式。

通过这种方式来设置`默认值`很方便，甚至那些公开诟病JavaScript强制类型转换的人也经常使用。

再来看看`&&`。

有一种用法对开发人员不常见，然而JS代码压缩工具常用。就是如果第一个操作数为真值，则`&&`运算符“选择”第二个操作数作为返回值，这也叫做“守护运算符（guard operator）”（见`第5章第140页的“短路（Short Circuited）”`），即前面的表达式为后面的表达式“把关”：

```
    function foo() {
        console.log( a );
    }
    
    var a = 42;
    
    a && foo(); // 42
```

`foo()`只有在条件判断`a`通过时才会被调用。如果条件判断未通过，`a && foo()`就会悄然终止（也叫做“短路，short circuiting”），`foo()`不会被调用。

这样的用法对开发人员不太常见，开发人员通常是用`if (a) { foo(); }`。但JS代码压缩工具用的是`a && foo()`，因为更简洁。以后再碰到这样的代码你就知道是怎么回事了。

`||`和`&&`各自有它们的用武之地，前提是我们理解并且愿意在代码中运用*隐式*强制类型转换。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="280px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;"><b>a = b || "something"</b>和<b>a &amp;&amp; b()</b>用到了“短路”机制，我们将在<b>第5章第140页的“短路”</b>一节详细介绍。</td>
    </tr>
</table>

你大概会有疑问，既然返回的不是`true`和`false`，为什么`a && (b || c)`这样的表达式在`if`和`for`中没出过问题。

这或许并不是代码的问题，问题在于你可能不知道这些条件判断表达式最后还会执行`布尔值`的*隐式*强制类型转换。

例如：

```
    var a = 42;
    var b = null;
    var c = "foo";
    
    if (a && (b || c)) {
        console.log( "yep" );
    }
```

这里`a && (b || c)`的结果实际上是`"foo"`而非`true`，然后再由`if`将`foo`强制类型转换为`布尔值`，所以最后结果为`true`。

现在明白了吧，这里发生了*隐式*强制类型转换。如果要避免*隐式*强制类型转换就得这样：

```
    if (!!a && (!!b || !!c)) {
        console.log( "yep" );
    }
```

###4.4.6 符号的强制类型转换

目前我们介绍的*显式*和*隐式*强制类型转换结果是一样的，它们之间的差异仅仅体现在代码可读性方面。

但ES6中引入了符号（symbol）类型，它的强制类型转换有一个坑，在这里有必要提一下。ES6允许从`符号`到`字符串`的*显式*强制类型转换，然而*隐式*强制类型转换会产生`错误`，具体的原因不在本书讨论范围之内。

例如：

```
    var s1 = Symbol( "cool" );
    String( s1 );     // "Symbol(cool)"
   
    var s2 = Symbol( "not cool" );
    s2 + "";      // 类型错误 TypeError
```

`符号`不能够被强制类型转换为`数字`（`显式`和`隐式`都会产生`错误`），但可以被强制类型转换为`布尔值`（`显式`和`隐式`结果都是`true`）。

由于规则缺乏一致性，我们要对ES6中`符号`的强制类型转换多加小心。

好在鉴于`符号`的特殊用途（见`第3章`），我们不会经常用到它的强制类型转换。

##4.5 宽松相等和严格相等

宽松相等（loose equals）`==`和严格相等（strict equals）`===`都用来判断两个值是否“相等”，但是它们之间有一个很重要的区别，特别是在判断条件上。

常见的误区是：“`==`检查值是否相等，`===`检查值和类型是否相等”。听起来蛮有道理，然而还不够准确。很多JavaScript的书籍和博客也是这样来解释的，但是很遗憾他们都错了。

正确的解释是：“`==`允许在相等比较中进行强制类型转换，而`===`不允许”。

###4.5.1 相等比较操作的性能

我们来看一看两种解释的区别。

根据第一种解释（不准确的版本），`===`似乎比`==`做的事情更多，因为它还要检查值的类型。第二种解释中`==`的工作量更大一些，因为如果值的类型不同还需要进行强制类型转换。

有人觉得`==`会比`===`慢，实际上虽然强制类型转换确实要多花点时间，但仅仅是微秒级（百万分之一秒）的差别而已。

如果进行比较的两个值类型相同，则`==`和`===`使用相同的算法，所以除了JS引擎实现上的细微差别之外，它们之间并没有什么不同。

如果两个值的类型不同，我们就需要考虑有没有强制类型转换的必要，有就用`==`，没有就用`===`，不用在乎性能。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="200px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;"><b>==</b>和<b>===</b>都会检查操作数的类型。区别在于操作数类型不同时它们的处理方式不同。</td>
    </tr>
</table>

###4.5.2 抽象相等

ES5规范第11.9.3节的“抽象相等比较算法”定义了`==`运算符的行为，该算法简单而又全面，涵盖了所有可能出现的类型组合，以及它们进行强制类型转换的方式。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="1000px" src="/api/storage/getbykey/screenshow?key=1604f65453ba2fc131a7"></td>
        <td style="border: none;">“抽象相等（abstract equality）”的这些规则正是<i>隐式</i>强制类型转换被诟病的原因。开发人员觉得它们太晦涩，很难掌握和运用，弊（导致bug）大于利（提高代码可读性）。这种观点我不敢苟同，因为本书的读者都是优秀的开发人员，整天与算法和代码打交道，“抽象相等”对各位来说只是小菜一碟。建议大家看一看ES5规范第11.9.3节，你会发现这些规则其实非常简单明了。</td>
    </tr>
</table>

其中第一段（11.9.3.1）规定如果两个值的类型相同，就仅比较它们是否相等。例如，`42`等于`42`，`"abc"`等于`"abc"`。

有几个非常规的情况需要注意：

- `NaN`不等于`NaN`（见`第2章`）。
- `+0`等于`-0`（见`第2章`）。 

11.9.3.1的最后定义了`对象`（包括`函数`和`数组`）的宽松相等`==`。两个对象指向*同一个值*时即视为相等，不发生强制类型转换。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="280px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;"><b>===</b>的定义和11.9.3.1一样，包括对象的情况。实际上在比较两个对象的时候，<b>==</b>和<b>===</b>的工作原理是一样的。</td>
    </tr>
</table>

11.9.3中还规定，`==`在比较两个不同类型的值时会发生*隐式*强制类型转换，会将其中之一或两者都转换为相同的类型后再进行比较。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="160px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">宽松不相等（loose not-equality）<b>!=</b>就是<b>==</b>的相反值，<b>!==</b>同理。</td>
    </tr>
</table>

####字符串和数字之间的相等比较

我们沿用本章前面`字符串`和`数字`的例子来解释`==`中的强制类型转换：

```
    var a = 42;
    var b = "42";

    a === b;    // false
    a == b;     // true
```

因为没有强制类型转换，所以`a === b`为`false`，`42`和`"42"`不相等。

而`a == b`是宽松相等，即如果两个值的类型不同，则对其中之一或两者都进行强制类型转换。

具体怎么转换？是`a`从`42`转换为`字符串`，还是`b`从`"42"`转换为`数字`？

ES5规范11.9.3.4-5这样定义：

```
1. 如果Type(x)是数字，Type(y)是字符串，则返回 x == ToNumber(y) 的结果。
2. 如果Type(x)是字符串，Type(y)是数字，则返回 ToNumber(x) == y 的结果。
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="520px" src="/api/storage/getbykey/screenshow?key=1604f65453ba2fc131a7"></td>
        <td style="border: none;">规范使用<b>Number</b>和<b>String</b>来代表数字和字符串类型，而本书使用的是<b>数字（number）</b>和<b>字符串（string）</b>。切勿将规范中的<b>Number</b>和原生函数<b>Number()</b>混为一谈。本书中类型名的首字符大写和小写是一回事。</td>
    </tr>
</table>

根据规范，`"42"`应该被强制类型转换为`数字`以便进行相等比较。相关规则，特别是`ToNumber`抽象操作的规则前面已经介绍过。本例中两个值相等，均为`42`。

####其他类型和布尔类型之间的相等比较

`==`最容易出错的一个地方是`true`和`false`与其他类型之间的相等比较。

例如：

```
    var a = "42";
    var b = true;

    a == b; // false
```

我们都知道`"42"`是一个真值（见本章前面部分），为什么`==`的结果不是`true`呢？原因既简单又复杂，让人很容易掉坑里，很多JS开发人员对这个地方并未引起足够的重视。

规范11.9.3.6-7是这样说的：

```
1. 如果Type(x)是布尔类型，则返回 ToNumber(x) == y 的结果。
2. 如果Type(y)是布尔类型，则返回 x == ToNumber(y) 的结果。
```

仔细分析例子，首先：

```
    var x = true;
    var y = "42";

    x == y; // false
```

`Type(x)`是`布尔值`，所以`ToNumber(x)`将`true`强制类型转换为`1`，变成`1 == "42"`，二者的类型仍然不同，`"42"`根据规则被强制类型转换为`42`，最后变成`1 == 42`，结果为`false`。

反过来也一样：

```
    var x = "42";
    var y = false;

    x == y; // false
```

`Type(y)`是`布尔值`，所以`ToNumber(y)`将`false`强制类型转换为`0`，然后`"42" == 0`再变成`42 == 0`，结果为`false`。

也就是说字符串`"42"`既不等于`true`，也不等于`false`。一个值怎么可以既非真值也非假值，这也太奇怪了吧？

这个问题本身就是错误的，我们被自己的大脑欺骗了。

`"42"`是一个真值没错，但`"42" == true`中并没有发生`布尔值`的比较和强制类型转换。这里不是`"42"`转换为`布尔值`（`true`），而是`true`转换为`1`，`"42"`转换为`42`。

这里并不涉及`ToBoolean`，所以`"42"`是真值还是假值与`==`本身没有关系！

重点是我们要搞清楚`==`对不同的类型组合怎样处理。`==`两边的`布尔值`会被强制类型转换为`数字`。

很奇怪吧？我个人建议无论什么情况下都不要使用`== true`和`== false`。

请注意这里说的只是`==`，`=== true`和`=== false`不允许强制类型转换，所以并不涉及`ToNumber`。

例如：

```
    var a = "42";
    
    // 不要这样用，条件判断不成立：
    if (a == true) {
        // .. 
    }
    
    // 也不要这样用，条件判断不成立：
    if (a === true) {
        // .. 
    }
    
    // 这样的显式用法没问题：
    if (a) {
        // ..
    }
  
    // 这样的显式用法更好：
    if (!!a) {
        // .. 
    }
    
    // 这样的显式用法也很好：
    if (Boolean( a )) {
        // .. 
    }
```

避免了`== true`和`== false`（也叫做`布尔值`的宽松相等）之后我们就不用担心这些坑了。

####null和undefined之间的相等比较

`null`和`undefined`之间的`==`也涉及*隐式*强制类型转换。ES5规范11.9.3.2-3规定：

```
1. 如果x为null，y为undefined，则结果为true。
2. 如果x为undefined，y为null，则结果为true。
```

在`==`中`null`和`undefined`相等（它们也与其自身相等），除此之外其他值都不存在这种情况。

这也就是说在`==`中`null`和`undefined`是一回事，可以相互进行*隐式*强制类型转换：

```
    var a = null;
    var b;

    a == b;     // true
    a == null;  // true
    b == null;  // true
    
    a == false; // false
    b == false; // false
    a == "";    // false
    b == "";    // false
    a == 0;     // false
    b == 0;     // false
```

`null`和`undefined`之间的强制类型转换是安全可靠的，上例中除`null`和`undefined`以外的其他值均无法得到假阳（false positive）结果。个人认为通过这种方式将`null`和`undefined`作为等价值来处理比较好。

例如：

```
    var a = doSomething();
    
    if (a == null) {
        // ..
    }
```

条件判断`a == null`仅在`doSomething()`返回非`null`和`undefined`时才成立，除此之外其他值都不成立，包括`0`，`false`和`""`这样的假值。

下面是*显式*的做法，其中不涉及强制类型转换，个人感觉更繁琐一些（大概执行效率也会更低）：

```
    var a = doSomething();

    if (a === undefined || a === null) {
        // ..
    }
```

我认为`a == null`这样的*隐式*强制类型转换在保证安全性的同时还能提高代码可读性。

####对象和非对象之间的相等比较

关于`对象`（`对象`／`函数`／`数组`）和标量基本类型（`字符串`／`数字`／`布尔值`）之间的相等比较，ES5规范11.9.3.8-9做如下规定：

```
1. 如果Type(x)是字符串或数字，Type(y)是对象，则返回x == ToPrimitive(y)的结果。
2. 如果Type(x)是对象，Type(y)是字符串或数字，则返回ToPromitive(x) == y的结果。
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="300px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba">
</td>
        <td style="border: none;">这里只提到了<b>字符串</b>和<b>数字</b>，没有<b>布尔值</b>。原因是我们之前介绍过11.9.3.6-7中规定了<b>布尔值</b>会先被强制类型转换为<b>数字</b>。</td>
    </tr>
</table>

例如：

```
    var a = 42;
    var b = [ 42 ];
    
    a == b; // true
```

`[ 42 ]`首先调用`ToPromitive`抽象操作（见`第59页“抽象值操作”`），返回`"42"`，变成`"42" == 42`，然后又变成`42 == 42`，最后二者相等。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="420px" src="/api/storage/getbykey/screenshow?key=16047bc8813535bf18e1">
</td>
        <td style="border: none;">之前介绍过的<b>ToPromitive</b>抽象操作的所有特性（如：<b>toString()</b>，<b>valueOf()</b>）在这里都适用。如果我们需要自定义<b>valueOf()</b>以便从复杂的数据结构返回一个简单值进行相等比较，这些特性会很有帮助。</td>
    </tr>
</table>

在`第3章`中我们介绍过“拆封（unboxing）”，即“打开”封装对象（如：`new String("abc"）`），返回其中的基本数据类型值（`"abc"`）。`==`中的`ToPromitive`强制类型转换也会发生这样的情况：

```
    var a = "abc";
    var b = Object( a );    // 和`new String( a )`一样

    a === b;                // false
    a == b;                 // true
```

`a == b`结果为`true`，因为`b`通过`ToPromitive`进行强制类型转换（也称为“拆封”，英文为unboxed或者unwrapped），并返回标量基本类型值`"abc"`，与`a`相等。

但有一些值不这样，原因是`==`算法中其它优先级更高的规则。例如：

```
    var a = null;
    var b = Object( a );    // 和`Object()`一样
    a == b;                 // false

    var c = undefined;      
    var d = Object( c );    // 和`Object()`一样
    c == d;                 // false
    
    var e = NaN;            
    var f = Object( e );    // 和`new Number( e )`一样
    e == f;                 // false
```

因为没有对应的封装对象（object wrapper），所以`null`和`undefined`不能够被封装（boxed），`Object(null)`和`Object()`均返回一个常规对象。

`NaN`能够被封装为数字封装对象，但拆封之后`NaN == NaN`返回`false`，因为`NaN`不等于`NaN`（见`第2章`）。

###4.5.3 比较少见的情况

我们已经全面介绍了`==`中的*隐式*强制类型转换（常规和非常规的情况），现在来看一下那些需要特别注意和避免的比较少见的情况。

首先来看看更改内置原生原型（built-in native prototypes）会导致哪些奇怪的结果：

```
    Number.prototype.valueOf = function() {
        return 3;
    };

    new Number( 2 ) == 3;   // true
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="400px" src="/api/storage/getbykey/screenshow?key=1604f65453ba2fc131a7">
</td>
        <td style="border: none;"><b>2 == 3</b>不会有这种问题，因为<b>2</b>和<b>3</b>都是数字基本类型值，不会调用<b>Number.prototype.valueOf()</b>方法。而<b>Number(2)</b>涉及<b>ToPrimitive</b>强制类型转换，因此会调用<b>valueOf()</b>。</td>
    </tr>
</table>

真是让人头大。这也是强制类型转换和`==`被诟病的原因之一。但问题并非出自JavaScript，而是我们自己。不要有这样的想法，觉得“编程语言应该阻止我们犯错误”。

还有更奇怪的情况：

```
    if (a == 2 && a == 3) {
        // ..
    }
```

你也许觉得这不可能，因为`a`不会同时等于`2`和`3`。但“同时”一词并不准确，因为`a == 2`在`a == 3`之前执行。

如果让`a.valueOf()`每次调用都产生副作用，比如第一次返回`2`，第二次返回`3`，就会出现这样的情况。这实现起来很简单：

```
    var i = 2;
    
    Number.prototype.valueOf = function() {
        return i++;
    };
   
    var a = new Number( 42 );
    
    if (a == 2 && a == 3) {
        console.log( "Yep, this happened." );
    }
```

再次强调千万不要这样，也不要因此而抱怨强制类型转换。对一种机制的滥用并不能成为诟病它的借口。我们应该正确合理地运用强制类型转换，避免这些极端的情况。

####假值的相等比较

`==`中的*隐式*强制类型转换最为人诟病的地方是假值的相等比较。

下面分别列出了常规和非常规的情况：

```
    "0" == null;        // false
    "0" == undefined;   // false
    "0" == false;       // true -- 晕！
    "0" == NaN;         // false
    "0" == 0;           // true
    "0" == "";          // false

    false == null;      // false
    false == undefined; // false
    false == NaN;       // false
    false == 0;         // true -- 晕！
    false == "";        // true -- 晕！
    false == [];        // true -- 晕！
    false == {};        // false

    "" == null;         // false
    "" == undefined;    // false
    "" == NaN;          // false
    "" == 0;            // true -- 晕！
    "" == [];           // true -- 晕！
    "" == {};           // false

    0 == null;          // false
    0 == undefined;     // false
    0 == NaN;           // false
    0 == [];            // true -- 晕！
    0 == {};            // false
```

以上二十四种情况中有十七种比较好理解。比如我们都知道`""`和`NaN`不相等，`"0"`和'0'相等。

然而有七种情况加了注释“晕！”，因为它们属于假阳（false positive）的情况，里面坑很多。`""`和`0`明显是两个不同的值，它们之间的强制类型转换很容易搞错。请注意这里不存在假阴（false negatives）的情况。

####极端情况

这还不算完，还有更极端的例子：

```
    [] == ![]   // true
```

事情变得越来越疯狂了。这看起来象是真值和假值之间的相等比较，结果不应该是`true`，因为一个值不可能同时既是真值也是假值！

事实并非如此。让我们来看看`!`运算符都做了些什么？根据`ToBoolean`规则，它会进行`boolean`显式强制类型转换（同时反转奇偶校验位）。所以`[] == ![]`变成了`[] == false`。前面我们介绍过，`false == []`，所以最后的结果并不出人意料。

再来看看其他情况：

```
    2 == [2];       // true
    "" == [null];   // true
```

介绍`ToNumber`时我们讲过，`==`右边的值`[2]`和`[null]`会进行`ToPrimitive`强制类型转换，以便能够和左边的基本类型值（`2`和`""`）进行比较。因为`array`的`valueOf()`返回`array`本身，所以强制类型转换将对`array`进行字符串化（stringifying）。

第一行中`[2]`会转换为`"2"`，然后通过`ToNumber`转换为`2`。第二行中`[null]`会直接转换为`""`。

最后的结果是`2 == 2`和`"" == ""`就不难理解了。

如果还是觉得头大，那么你的不解可能并非由于强制类型转换，而是`ToPrimitive`将`array`转换为`string`这一过程。你很可能没有想到`[2].toString()`返回的是`"2"`，`[null].toString()`返回的是`""`。

但是如果不这样处理的话又能怎样呢？我实在想不出其他更好的办法。或许应该将`[2]`转换为`"[2]"`，但这样的话在别的地方又显得很奇怪。

有人也许会觉得既然`String(null)`返回`"null"`，所以`String([null])`也应该返回`"null"`。想法确实有道理，这就是问题所在。

*隐式*强制类型转换本身不是问题的根源，因为`[null]`在*显式*强制类型转换中也是转换为`""`。问题在于将`array`转换为`string`是否合理，具体该如何处理。所以实际上这是`String([..])`规则的问题。或许`array`根本就不应该被转换为`string`？但这样一来又会导致很多其它问题。

还有一个常被提到的坑：

```
    0 == "\n";  // true
```

前面介绍过，`""`，`"\n"`（或者`" "`等其他空格组合）等空字符串被`ToNumber`强制类型转换为`0`。这样处理总没有问题了吧，不然你要咋整？

或许可以将空字符串和空格转换为`NaN`，这样`" " == NaN`就为`false`了，然而这并没有从根本上解决问题。

`0 == "\n"`导致程序出错的几率小之又小，不太容易碰到。

类型转换*总*会出现一些特殊情况，并非只有强制类型转换，任何编程语言都是如此。问题出在我们的臆断（有时也许碰巧对了！？），但这并不能成为诟病强制类型转换机制的理由。

上述七种情况基本涵盖了所有我们可能遇到的坑（除修改`valueOf()`和`toStrign()`的情况以外）。

与前面二十四种情况列表相对应的是下面这个列表：

```
    42 == "43";         // false
    "foo" == 42;        // false
    "true" == true;     // false
   
    42 == "42";         // true
    "foo" == [ "foo" ]; // true    
```

这些是非假值的常规情况（实际上还可以加上无穷大数字的相等比较），其中涉及的强制类型转换是安全、合理和好懂的。

####完整性检查

我们深入介绍了*隐式*强制类型转换中的一些特殊情况。也难怪大多数开发人员都觉得太晦涩，唯恐避之不及。

现在我们回过头来做一下完整性检查（sanity check）。

前面列出了相等比较中的强制类型转换的7个坑，但另外还有至少十七种情况是绝对安全和容易理解的。

因为7棵歪脖树而放弃整片森林似乎有点因噎废食了。明智的做法是扬长避短。

再来看看那些*短*的地方：

```
    "0" == false;   // true -- 晕！
    false == 0;     // true -- 晕！
    false == "";    // true -- 晕！
    false == [];    // true -- 晕！
    "" == 0;        // true -- 晕！
    "" == [];       // true -- 晕！
    0 == [];        // true -- 晕！
```

其中有四种情况涉及`== false`，之前我们说过应该避免，这并不难掌握。

现在剩下三种：

```
    "" == 0;        // true -- 晕！
    "" == [];       // true -- 晕！
    0 == [];        // true -- 晕！
```

正常情况下我们应该不会这样写代码吧。

我想你应该不太可能会用`== []`来做条件判断，而是用`== ""`或者`== 0`，如：

```
    function doSomething(a) {
        if (a == "") {
            // .. 
        }
    }
```

如果不小心碰到`doSomething(0)`和`doSomething([])`这样的情况，结果会让你很惊讶。又如：

```
    function doSomething(a,b) {
        if (a == b) {
            // .. 
        }
    }
```

`doSomething("",0)`和`doSomething([],"")`也会产生意料之外的结果。

这些特殊情况会导致种种问题，需要我们多加小心，好在它们并不是十分常见。

####安全运用隐式强制类型转换

关键是我们要对`==`两边的值认真推敲。以下两个原则可以有效地避免错误：

- 如果两边的值中有`true`或者`false`，不要使用`==`。
- 如果两边的值中有`[]`，`""`或者`0`时，尽量不要使用`==`。

这时候最好用`===`，可以避免产生意外的强制类型转换。这两个原则可以让我们避开几乎所有强制类型转换的坑。

这时候的强制类型转换越显式越好，可以避免很多麻烦。

所以`==`和`===`选择哪一个取决于是否允许在相等比较中发生强制类型转换。

强制类型转换在很多地方非常有用，能够让相等比较更简洁（比如`null`和`undefined`）。

*隐式*强制类型转换在少数情况下的确很危险，这时为了安全起见就要使用`===`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">有一种情况下的强制类型转换是绝对安全的，那就是<b>typeof</b>操作。<b>typeof</b>总是返回七个字符串之一（见<b>第1章</b>），其中没有空字符串。所以在类型检查过程中不会发生隐式强制类型转换。<b>typeof x == "function"</b>是100%安全的，和<b>typeof x === "function"</b>一样。事实上两者在规范中是一回事。所以即不要盲从代码工具每一处都用<b>===</b>，更不要不管不问。我们要对自己的代码质量负责。</td>
    </tr>
</table>

*隐式*强制类型转换真的那么不堪吗？某些情况下是，但总的来说并不是。

做为一个成熟负责的开发人员，我们应该学会安全有效地运用强制类型转换（*显式*和*隐式*），并对周围的小伙伴言传身教。

Alex Dorey（GitHub用户名@dorey）在GitHub上制作了一张图表，列出了各种相等比较的情况，如`图4-1`。

![](figures/Figure4-1.png)

*图4-1. JavaScript中的相等比较*

##4.6 抽象关系比较

`a < b`中涉及的*隐式*强制类型转换不太引人注意，不过还是很有必要深入了解一下。

ES5规范11.8.5节定义了“抽象关系比较（Abstract Relational Comparison）”，分两部分：比较双方都是`string`（后半部分）的情况和其他的情况（前半部分）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">该算法仅针对<b>a &lt; b</b>，<b>a > b</b>会被处理为<b>b &lt; a</b>。</td>
    </tr>
</table>

比较双方首先调用`ToPrimitive`，如果结果出现非`string`则根据`ToNumber`规则将双方强制类型转换为`number`来进行比较。

例如：

```
    var a = [ 42 ];
    var b = [ "43" ];

    a < b;  // true
    b < a;  // false
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">前面介绍过的<b>-0</b>和<b>NaN</b>的相关规则在这里也适用。</td>
    </tr>
</table>

如果比较双方都是`string`则按字母顺序（natural alphabetic）来比较：

```
    var a = [ "42" ];
    var b = [ "043" ];
    
    a < b; // false
```

`a`和`b`并没有被转换为`number`，因为`ToPrimitive`返回的是`string`，所以这里比较的是`"42"`和`"043"`两个字符串，它们分别以`"4"`和`"0"`开头。因为`"0"`在字母顺序上小于`"4"`，所以最后结果为`false`。

同理：

```
    var a = [ 4, 2 ];
    var b = [ 0, 4, 3 ];
    
    a < b; // false
```

`a`转换为`"4, 2"`，`b`转换为`"0, 4, 3"`，也是按字母顺序进行比较。

再比如：

```
    var a = { b: 42 };
    var b = { b: 43 };
    
    a < b; // ??
```

结果还是`false`，因为`a`是`[object Object]`，`b`也是`[object Object]`，所以按照字母顺序`a < b`并不成立。

下面的例子就有些奇怪了：

```
    var a = { b: 42 };
    var b = { b: 43 };

    a < b;  // false
    a == b; // false
    a > b;  // false
    
    a <= b; // true
    a >= b; // true
```

为什么`a == b`的结果不是`true`？它们的`string`值相同（为`"[object Object]"`），按道理应该相等才对？实际上不是。你可以回忆一下前面介绍过的`object`的相等比较。

但是如果`a < b`和`a == b`的结果是`false`，为什么`a <= b`和`a >= b`的结果会是`true`呢？

因为根据规范`a <= b`被处理为`b < a`，然后将结果反转。因为`b < a`的结果是`false`，所以`a <= b`的结果是`true`。

这可能与我们设想的大相径庭，即`<=`应该是“小于或者等于”。实际上JS中`<=`是“不大于”的意思（即`!(a > b)`，处理为`!(b < a)`）。同理`a >= b`处理为`b <= a`。

相等比较有严格相等，而关系比较没有“严格关系比较（strict relational comparison）”。也就是说如果要避免`a < b`中发生*隐式*强制类型转换，我们只能确保`a`和`b`有相同的类型，除此之外别无他法。

与`==`和`===`的完整性检查一样，我们应该在必要和安全的情况下使用强制类型转换，如：`42 < "43"`。换句话说就是为了保证安全，应该对关系比较中的值进行*显式强制类型转换*：

```
    var a = [ 42 ];
    var b = "043";

    a < b;                      // false -- string comparison!
    Number( a ) < Number( b );  // true -- number comparison!
```

##4.7 回顾

本章中我们介绍了JavaScript的数据类型之间的转换，即`强制类型转换`，包括*显式*和*隐式*。

强制类型转换常常为人诟病，但实际上很多时候它们是非常有用的。作为一个有责任感的JS开发人员，我们有必要深入了解强制类型转换，这样就能取其精华，去其糟粕。

*显式*强制类型转换明确告诉我们哪里发生了类型转换，它的好处是有助于提高代码的可读性和可维护性。

*隐式*强制类型转换则没有那么明显，是其它操作的副作用。感觉上好象是*显式*强制类型转换的反面，实际上*隐式*强制类型转换也有助于提高代码的可读性。

处理强制类型转换时要十分小心，特别是*隐式*强制类型转换。我们在编码的时候要知其然，还要知其所以然，并尽量让代码清晰易读。