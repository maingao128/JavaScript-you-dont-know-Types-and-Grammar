##第四章 强制类型转换

在对JavaScript的类型和值有了一个更全面的了解之后，我们来讨论一个非常有争议的话题：强制类型转换（coercion）。

`第一章`里我们说过，强制类型转换是一个设计上的缺陷还是一个有用的特性，这个争论从JS诞生之日起就有了。许多JS书籍将强制类型转换描述为危险，晦涩，和糟糕的设计。

这里我们秉承本系列丛书的一贯宗旨，对于不懂的地方应该有困难要上，没有困难创造困难也要上，不会因为种种传言和挫折就退避三舍。

本章旨在全面介绍强制类型转换的优缺点，让你能够在开发中合理运用它。

###值类型转换

将值从一种类型转换为另一种类型通常称为“类型转换”（type casting），这是显式的情况，隐式的情况称为“强制类型转换”（coercion）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="500px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">JavaScript中的强制类型转换总是返回标量基本类型值（见<b>第二章</b>），如：<b>字符串</b>，<b>数字</b>，和<b>布尔值</b>，不会返回<b>对象</b>和<b>函数</b>。在<b>第三章</b>中我们介绍过“封装”，就是为标量基本类型值封装一个相应类型的对象，但这并非严格意义上的强制类型转换。</td>
    </tr>
</table>

也可以这样来区分：“类型转换”发生在静态类型语言的编译阶段（compile time），而“强制类型转换”则发生在动态类型语言的运行时（runtime）。

然而在JavaScript中我们将它们统称为*强制类型转换*，我个人则倾向于用“隐式强制类型转换”（implicit coercion）和“显式强制类型转换”（explicit coercion）来区分。

二者的区别显而易见：我们能够从代码中看出哪些地方是“显式强制类型转换”，而“隐式强制类型转换”就不那么明显，通常是某些操作产生的副作用。

例如：

```
    var a = 42;
    
    var b = a + "";         // implicit coercion
    
    var c = String( a );    // explicit coercion
```

对变量`b`而言，强制类型转换是隐式的，由于`+`运算符的其中一个操作数是`字符串`，所以是`字符串`拼接操作，结果是数字`42`被强制类型转换为相应的字符串`"42"`。

而`String(..)`则是将`a`显式强制类型转换为`字符串`。

两者都是将数字`42`转换为字符串`"42"`。然而它们各自不同的处理方式成为了争论的焦点。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="500px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">从技术角度来说，除了字面上的差别以外，二者在行为特征上也有一些细微的差别。我们将在下一章详细介绍，见<b>第87页“Implicitly: Strings &lt;--&gt; Numbers”</b>。</td>
    </tr>
</table>

这里的“显式”和“隐式”，以及“明显的副作用”和“隐藏的副作用“都是*相对而言*。

要是你明白`a + ""`是怎么回事，它对你来说就是“显式”的。相反如果你不知道`String(..)`可以用来做`字符串`强制类型转换，它对你来说可能就是“隐式”的。

我们在这里以普遍通行的标准来讨论“显式”和“隐式”，而非JS专家和规范的标准。如果你的理解与此有出入，请参照我们的标准。

要知道我们编写的代码大都是给别人看的。即便是JS高手也需要顾及其他不同水平的开发人员，要考虑他们是否能读懂自己的代码，以及他们对于“显式”和“隐式”的理解是否和自己一致。

###抽象值操作

介绍*显式*和*隐式*强制类型转换之前，我们需要掌握`字符串`，`数字`，和`布尔值`之间类型转换的基本规则。ES5规范第9节中定义了一些“抽象操作”（即“仅供内部使用的操作”）和转换规则。这里我们着重介绍`ToString`，`ToNumber`，和`ToBoolean`，附带讲一讲`ToPrimitive`。

####ToString

规范第9.8节中定义了抽象操作`ToString`，它负责处理非`字符串`到`字符串`的强制类型转换。

基本类型值的字符串化（stringification）规则为：`null`转换为`"null"`，`undefined`转换为`"undefined"`，`true`转换为`"true"`。`数字`的字符串化则遵循通用规则，不过`第二章`中讲过的那些极小和极大的`数字`使用指数形式：

```
    // multiplying `1.07` by `1000`, seven times over
    var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;

    // seven times three digits => 21 digits
    a.toString(); // "1.07e21"
```

对于普通对象来说，除非自行定义，否则`toString()`（`Object.prototype.toString()`）返回*内部*属性`[[Class]]`的值（见`第三章`），如：`"[object Object]"`。

然而前面我们介绍过，如果对象有自己的`toString()`方法，字符串化时就会调用该方法并使用其返回值。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="400px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">将对象强制类型转换为<b>string</b>是通过<b>ToPrimitive</b>抽象操作来完成的（ES5规范第9.1节），我们在此略过，稍后将在<b>ToNumber</b>一节中详细介绍。</td>
    </tr>
</table>

`数组`的默认`toString()`方法经过了重新定义，将所有单元字符串化以后再用`","`连接起来：

```
    var a = [1,2,3];

    a.toString(); // "1,2,3"
```

`toString()`可以被显式调用，或者在需要字符串化时自动调用。

####JSON字符串化

工具函数`JSON.stringify(..)`在将JSON对象序列化（serialize）为`字符串`时也用到了`ToString`。

请注意JSON字符串化并非严格意义上的强制类型转换，因为其中也涉及到`ToString`相关规则，所以这里顺带介绍一下。

对于大多数简单值来说，JSON字符串化和`toString()`的效果基本相同，只不过序列化的结果*总是*`字符串`：

```
    JSON.stringify( 42 );   // "42"
    JSON.stringify( "42" ); // ""42"" (a string with a
                            // quoted string value in it)
    JSON.stringify( null ); // "null"
    JSON.stringify( true ); // "true"

```

所有*安全的JSON值（JSON-safe）*都可以使用`JSON.stringify(..)`字符串化。安全的JSON值是指能够呈现为有效JSON格式的值。

为了简单起见，我们来看看什么是*不安全*的JSON值。`undefined`，`function`，`symbol`（ES6+），和包含循环引用（对象之间相互引用，形成一个无限循环）的`object`都是不符合JSON结构标准的值，支持JSON的语言无法处理它们。

`JSON.stringify(..)`在`对象`中遇到`undefined`，`function`，和`symbol`时会自动将其忽略，在`数组`中则会返回`null`（以保证单元位置不变）。

例如：

```
    JSON.stringify( undefined );        // undefined
    JSON.stringify( function(){} );     // undefined
 
    JSON.stringify(
       [1,undefined,function(){},4]
    );                                  // "[1,null,null,4]"
    JSON.stringify(
       { a:2, b:function(){} }
    );                                  // "{"a":2}"
```

对包含循环引用的对象执行`JSON.stringify(..)`会出错。

如果`对象`中定义了`toJSON()`方法，JSON字符串化时会首先调用该方法，然后用它的返回值来进行序列化（serialization）。

如果要对含有非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义`toJSON()`方法来返回一个安全的JSON值。

例如：

```
    var o = { };

    var a = { 
        b: 42,
        c: o,
        d: function(){}
    };

    // create a circular reference inside `a`
    o.e = a;
    
    // would throw an error on the circular reference
    // JSON.stringify( a );
    
    // define a custom JSON value serialization
    a.toJSON = function() {
        // only include the `b` property for serialization
        return { b: this.b };
    };
    
    JSON.stringify( a ); // "{"b":42}"
```

很多人误以为`toJSON()`返回的是JSON字符串化后的值，其实不然，除非我们确实想要对`字符串`进行字符串化（通常不会！）。`toJSON()`返回的应该是一个适当的值，可以是任何类型，然后再由`JSON.stringify(..)`对其进行字符串化。

也就是说`toJSON()`应该“返回一个能够被字符串化的安全的JSON值”，而不是“返回一个JSON字符串”。

例如：

```
    var a = {
        val: [1,2,3],

        // probably correct!
        toJSON: function(){
            return this.val.slice( 1 );
        }
    };
    
    var b = {
        val: [1,2,3],
        
        // probably incorrect!
        toJSON: function(){
            return "[" +
                this.val.slice( 1 ).join() +
            "]"; 
        }
    };
    
    JSON.stringify( a ); // "[2,3]"
    
    JSON.stringify( b ); // ""[2,3]""
```

这里第二个函数是对`toJSON`返回的`字符串`做字符串化，而非`数组`本身。

现在介绍几个不太为人知但却非常有用的功能。

我们可以向`JSON.stringify(..)`传递一个可选参数（optional argument）*replacer*，它可以是`数组`或者`函数`，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除，和`toJSON()`很像。

如果`replacer`是一个`数组`，那么它必须是一个`字符串数组`，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略。

如果`replacer`是一个`函数`，它会对`对象`本身调用一次，然后对`对象`中的每个属性各调用一次，每次传递两个参数，`key`和`value`。如果要忽略某个`key`就返回`undefined`，否则返回指定的*值*。

```
    var a = { 
        b: 42,
        c: "42",
        d: [1,2,3] 
    };
    
    JSON.stringify( a, ["b","c"] ); // "{"b":42,"c":"42"}"
    
    JSON.stringify( a, function(k,v){
        if (k !== "c") return v;
    } );
    // "{"b":42,"d":[1,2,3]}"
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="700px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba">
</td>
     <td style="border: none;">如果<i>replacer</i>是<b>函数</b>，它的参数<b>k</b>在第一次调用时为<b>undefined</b>（就是对对象本身调用的那次）。<b>if</b>语句将属性<b>"c"</b>排除掉。由于字符串化是递归的，因此数组<b>[1,2,3]</b>中的每个元素都会通过参数<b>v</b>传递给*replacer*，即<b>1，2，和3</b>，参数<b>k</b>是它们的索引值，即<b>0，1，和2</b>。</td>
    </tr>
</table>

`JSON.string`还有一个可选参数*space*，用来指定输出的缩进格式。*space*为正整数时是指定每一级缩进的字符数，它还可以是`字符串`，此时最前面的十个字符被用于每一级的缩进：

```
    var a = { 
        b: 42,
        c: "42",
        d: [1,2,3] 
    };
    
    JSON.stringify( a, null, 3 );
    // "{
￼   //      "b": 42,
    //      "c": "42",
    //      "d": [
    //          1, 
    //          2,
    //          3
    //      ]
    // }"

    JSON.stringify( a, null, "-----" );
    // "{
    // -----"b": 42,
    // -----"c": "42",
    // -----"d": [
    // ----------1,
    // ----------2,
    // ----------3
    // -----]
    // }"
```

请记住，`JSON.stringify(..)`并不是强制类型转换。在这里介绍是因为它涉及`ToString`强制类型转换，具体表现在以下两点：

1. `字符串`，`数字`，`布尔值`，和`null`的`JSON.stringify(..)`规则与`ToString`基本相同。

2. 如果传递给`JSON.stringify(..)`的`对象`中定义了`toJSON()`方法，那么该方法会在字符串化前调用，以便将`对象`转换为*安全的JSON值*。

####ToNumber

有时我们需要将非`数字`值当作`数字`来使用，比如数学运算。为此ES5规范在第9.3节定义了抽象操作`ToNumber`。

其中`true`转换为`1`，`false`转换为`0`。`undefined`转换为`NaN`，`null`转换为`0`。

`ToNumber`对`字符串`的处理基本遵循`数字`常量的相关规则／语法（见`第三章`）。处理失败时返回`NaN`（处理`数字`常量失败时会产生语法错误）。不同之处是`ToNumber`对以`0`开头的十六进制数并不按十六进制处理（而是按十进制，见`第二章`）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="300px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba">
</td>
        <td style="border: none;"><b>数字</b>常量的语法规则与<b>ToNumber</b>处理<b>字符串</b>所遵循的规则之间差别不大，这里不做进一步介绍，可参考ES5规范第9.3.1节。</td>
    </tr>
</table>

对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非`数字`的基本类型值，则再遵循以上规则将其强制转换为`数字`。

为了将值转换为相应的基本类型值，抽象操作`ToPrimitive`（见ES5规范第9.1节）会首先（通过内部操作`DefaultValue`，见ES5规范第8.12.8节）检查该值是否有`valueOf()`方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用`toString()`的返回值（如果存在）来进行强制类型转换。

如果`valueOf()`和`toString()`均不返回基本类型值的话会产生`TypeError`错误。

从ES5开始，使用`Object.create(null)`创建的对象`[[Prototype]]`属性为`null`，并且没有`valueOf()`和`toString()`方法，因此无法进行强制类型转换。详情请参考本系列的*《this & Object Prototypes》*一书中`[[Prototype]]`相关部分。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="300px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba">
</td>
        <td style="border: none;">我们稍后将详细介绍<b>数字</b>的强制类型转换，在下面的示例代码中我们假定<b>Number(..)</b>已经实现了此功能。</td>
    </tr>
</table>

例如：

```
    var a = {
        valueOf: function(){
            return "42";
        }
    };
    
    var b = {
        toString: function(){
            return "42";
        }
    };
    
    var c = [4,2];
    c.toString = function(){
        return this.join( "" ); // "42"
    };

    Number( a );            // 42
    Number( b );            // 42
    Number( c );            // 42
    Number( "" );           // 0
    Number( [] );           // 0
    Number( [ "abc" ] );    // NaN
```

####ToBoolean

下面介绍`布尔值`，关于这个主题存在许多误解和困惑，需要我们特别注意。

首先也是最重要的一点是，JS中有两个关键词`true`和`false`，分别代表`布尔`类型中的真和假。我们常误以为数值`1`和`0`分别等同于`true`和`false`。在有些语言中可能是这样，但在JS中`布尔值`和`数字`是不一样的。虽然我们可以将`1`强制类型转换为`true`，将`0`强制类型转换为`false`，反之亦然，但它们并不是一回事。

#####假值（Falsy values）

我们再来看看其它的值是如何被强制类型转换为`boolean`值的。

JavaScript中的值可以分为以下两类：

1. 可以被强制类型转换为`false`的值
2. 其他（可以被强制类型转换为`true`的值）

JS规范具体定义了一小撮可以被强制类型转换为`false`的值。

ES5规范第9.2节中定义了抽象操作`ToBoolean`，列出了`boolean`强制类型转换所有可能的结果。

以下是假值（“falsy”）：

- `undefined`
- `null`
- `false`
- `+0`，`-0`和`NaN`
- `""`

假值的`boolean`强制类型转换结果为`false`。

从逻辑上说，假值列表以外的值则会被转换为`true`，我们称为真值（“truthy”）。但JS规范对此并没有明确定义，只是给出了一些例子，例如明确规定所有的`object`都是真值，我们可以这样来理解：*假值列表以外的值都是真值*。

#####假值对象（Falsy objects）

这个标题似乎有点自相矛盾。前面讲过规范规定所有的`object`都是真值，怎么还会有假值对象呢？

有人可能会以为假值对象就是包装假值的封装对象（如：`""`，`0`，和`false`，见`第三章`），实际不然。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这只是规范给我们开的一个小玩笑。</td>
    </tr>
</table>

例如：

```
    var a = new Boolean( false );
    var b = new Number( 0 );
    var c = new String( "" );
```

它们都是封装了假值的对象（见`第三章`）。那它们是`true`还是`false`呢？答案很简单：

```
    var d = Boolean( a && b && c );
    
    d; // true
```

`d`的值为`true`，所以`a，b，c`都是`true`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">请注意Boolean(..)对<b>a &amp;&amp; b &amp;&amp; c</b>进行了封装，你可能会问为什么要这样。这里我们暂且记下，稍后会作说明。你可以试试不用Boolean(..)，看看<b>d = a &amp;&amp; b &amp;&amp; c</b>的结果是什么。</td>
    </tr>
</table>

如果“假值对象（falsy objects）”并非封装假值的对象，那究竟又是什么玩意？

有趣的是虽然JS代码中会出现`假值对象`，但是它实际上并不属于JavaScript语言的范畴。

在一些特定情况下，浏览器会自己创建一些*外来（exotic）*值，即“假值对象”。

“假值对象”看起来和普通对象并无二致（比如都包含属性），但`boolean`强制类型转换结果为`false`。

最常见的例子是`document.all`，它是一个类数组（array-like）对象，包含了页面上所有的元素，由*DOM*提供给JS程序使用（而非由JS引擎提供）。它曾经是一个真正意义上的对象，`boolean`强制类型转换结果为`true`，不过现在它是一个“假值对象”。

`document.all`并非标准用法，并且很早就被废止了。

有人也许会问：“既然这样，那浏览器能否将它彻底去除？”，想法是好的，只是很多JS程序仍然在使用它。

那为什么要让它成为假值呢？因为我们经常将`document.all`强制类型转换为`boolean`（比如在`if`语句中）来检测浏览器是否是老版本的IE。IE自诞生以来就一（cong）直 （wei）遵循浏览器标准，比其他浏览器更有（keng）力（die）地推动了Web的发展。

那些`if(document.all) { /* it's IE */ }`依然存在于许多程序中，并且可能会一直存在下去，对IE用户而言并非好的体验。

虽然我们无法彻底抛弃`document.all`，但为了让新版本更符合标准，IE并不打算继续支持`if (document.all) { .. }`。

“那我们应该怎么办呢？”，“也许我们可以修改JS的类型机制，将`document.all`作为假值处理！”。这并不是一个好主意。大多数JS开发人员对这个坑并不了解，不过更糟糕的是对其置若罔闻。

#####真值

真值就是假值列表之外的值。

例如：

```
    var a = "false";
    var b = "0";
    var c = "''";

    var d = Boolean( a && b && c );
    
    d;
```

这里`d`应该是`true`还是`false`呢？

答案是`true`。上例的`string`看起来象是`假值`，但所有`string`都是`真值`。`""`除外，它是`假值`列表中唯一的`string`。

再如：

```
    var a = [];             // empty array--truthy or falsy?
    var b = {};             // empty object--truthy or falsy?
    var c = function(){};   // empty function--truthy or falsy?

    var d = Boolean( a && b && c );
    
    d;
```

`d`依然是`true`。还是同样的道理，`[]`，`{}`，和`function(){}`都不在`假值`列表中，因此它们都是`真值`。

换句话说`真值`列表可以无限长，因而无法对其进行明确的定义，所以我们只能定义一个`假值`列表作为参照。

你可以花五分钟时间将`假值`列表写出来贴在显示器上，或者记在脑子里，这样遇到真／假值的时候就可以轻松做出判断。

真／假值的重点在于理解`boolean`强制类型转换（显式和隐式），之后我们就可以深入讨论强制类型转换的实例了。

####显式强制类型转换（Explicit Coercion）

*显式*强制类型转换是明显的类型转换，很多类型转换都属于此类。

编码时我们应该尽量将类型转换表达清楚，以免给别的开发人员留坑。代码越清晰可读性越高。

*显式强制类型转换*的好处毋庸置疑，它与我们所熟悉的静态语言的类型转换差不多，所以对它应该不存在什么非议。我们后面会再讨论这个话题。

#####字符串和数字之间的显式转换

让我们从最常见的`string`和`number`之间的强制类型转换开始。

`string`和`number`之间的转换使用的是`String(..)`和`Number(..)`这两个内建函数（称为“原生构造函数”，见`第三章`），注意它们前面不带`new`关键字，因此并不创建封装对象。

下面是两者之间的显式强制类型转换：

```
    var a = 42;
    var b = String( a );
    
    var c = "3.14";
    var d = Number( c );
    
    b; // "42"
    d; // 3.14
```

`String(..)`遵循前面介绍的`ToString`相关规则，将值转换为`string`基本类型。`Number(..)`遵循前面介绍的`ToNumber`相关规则，将值转换为`number`基本类型。

它们和静态语言的类型转换很相似，一看便知，所以将其归为*显式*强制类型转换。

例如在C/C++中我们可以使用`(int)x`或`int(x)`将`x`转换为整数。大多数人倾向后者，因为它看起来更象一个函数调用。JavaScript中的`Number(x)`与此非常类似，至于它是否真是一个函数并不重要。

除了`String(..)`和`Number(..)`外，还有其他方法可以实现`string`和`number`之间的“显式”类型转换：

```
    var a = 42;
    var b = a.toString();
    
    var c = "3.14";
    var d = +c;

    b; // "42"
    d; // 3.14
```

调用`a.toString()`的意图非常明显（“toString”意指“to a string”），不过这里涉及一些隐蔽的隐式转换。因为`toString()`对`42`这样的基本类型值不适用，所以JS引擎会自动为`42`创建一个封装对象（见`第三章`），然后在该对象上调用`toString()`。这里的显式转换中含有隐式转换。

上例中`+c`是`+`运算符的*一元（unary）*形式（即只有一个操作数）。`+`运算符显式地将`c`转换为`number`，而不是数学加法运算（也不是字符串拼接操作－－见下）。

那`+c`是不是显式强制类型转换呢？这取决于我们自己的经验和理解。如果我们已经明白一元运算符`+`会将操作数显式强制类型转换为`number`，那它就是显式的。如果我们不知道，那它就是让人费解的、有隐藏副作用的隐式强制类型转换。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">JS开源社区普遍认为一元运算<b>+</b>是<i>显式</i>强制类型转换。</td>
    </tr>
</table>

`+c`这样的用法很普遍，但有时候下也让人挠头。例如：

```
    var c = "3.14";
    var d = 5+ +c;

    d; // 8.14
```

一元运算符`-`和`+`类似，不过它还会将数字的符号位进行反转（flip）。不能用两个`-（--）`来撤销反转，因为`--`会被当作递减运算符来处理。应该采用`- -"3.14"`的方式，在中间加一个空格，这样结果才是`3.14`。

下面是一个让人抓狂的例子：

```
    1 + - + + + - + 1;  // 2
```

尽量不要把一元运算符`+`（和`-`）和其他运算符放在一起使用。上面的例子运行起来没问题，但并不是一个好方法。另外`d = +c`（和`d =+ c`）也很容易与`d += c`搞混，它们之间的区别大了去了。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">还有一个极易搞混的情况是一元运算符挨着<b>++</b>和<b>--</b>。例如<b>a +++b</b>，<b>a + ++b</b>，和<b>a + + +b</b>。有关<b>++</b>请参见<b>第125页“表达式的副作用”</b>。</td>
    </tr>
</table>

#####日期显式转换为数字

一元运算符`+`的另一个常见用法是将`Date`对象强制类型转换为`number`，其结果值是Unix时间戳，以微秒为单位（从1970年1月1日00:00:00 UTC起到现在的时间）：

```
    var d = new Date( "Mon, 18 Aug 2014 08:53:06 CDT" );

    +d; // 1408369986000
```

我们常用以下方式来获得当前的时间戳，例如：

```
    var timestamp = +new Date();
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">JavaScript中有一个特殊语法，即构造函数没有参数时可以不用带<b>()</b>。所以我们有时会碰到<b> var timestamp = +new Date; </b>这样的写法。这样做是否能提高代码可读性还存在争议，因为其只适用于<b> new fn() </b>，对一般的函数调用<b> fn() </b>并不适用。</td>
    </tr>
</table>

将`Date`对象转换为时间戳并非只有强制类型转换这一种方法，其它更显式的方法或许还更好一些：

```
    var timestamp = new Date().getTime();
    // var timestamp = (new Date()).getTime();
    // var timestamp = (new Date).getTime();
```

不过*最好*还是使用ES5中新加入的静态方法`Date.now()`：

```
    var timestamp = Date.now();
```

为老版本浏览器polyfill `Date.now()`也很简单：

```
    if (!Date.now) {
        Date.now = function() {
            return +new Date();
        };
    }
```

建议不要对`Date`类型使用强制类型转换，而应该用`Date.now()`来获得当前时间戳，用`new Date(..).getTime()`来获得指定时间的时间戳。

#####奇特的运算符~

`~`运算符（即字位操作“非”）也涉及强制类型转换，它即让人费解又常被人忽视，甚至熟悉它的开发人员也常对其敬而远之。秉承本书的一贯宗旨，让我们来深入探讨一下`~`有哪些用处。

在`“32位有符号整数”第23页`中我们介绍过字位运算符只适用于32位整数，即运算符会强制操作数使用32位格式。这一切都是通过抽象操作`ToInt32`来实现的（ES5规范第9.5节）。

`ToInt32`首先进行`ToNumber`强制类型转换，例如`"123"`会先被转换为`123`，然后再执行`ToInt32`。

虽然严格说来并非强制类型转换（因为返回值类型并没有发生变化），但字位运算符（比如`|`和`~`）和某些特殊`number`一起使用时会产生类似强制类型转换的效果，返回值为另一个`number`。

先来看看`|`运算符（字位操作“或”）的空操作（no-op）`0 | x`，此时仅执行`ToInt32`转换（在`第二章`介绍过）：

```
    0 | -0;         // 0
    0 | NaN;        // 0
    0 | Infinity;   // 0
    0 | -Infinity;  // 0
```

以上这些特殊数字无法以32位格式呈现（因为它们来自64位IEEE 754标准，见`第二章`），因此`ToInt32`对它们返回`0`。

至于`0 | ___`是*显式*还是*隐式*还存在争议。从规范的角度来说它无疑是*显式*的，但如果对字位运算符没有这样深入的理解，它可能就是*隐式*的。为了保证前后一致，这里我们将其视为*显式*。

再回到`~`。它首先将值“强制类型转换”为`32位数字`，然后执行字位操作“非”（对每一个字位进行反转）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这和<b>!</b>很相像，不仅将值强制类型转换为<b>boolean</b>，还对其做字位反转（见第83页的<b>“显式类型转换为Boolean”</b>）。</td>
    </tr>
</table>

字位反转这个主题太晦涩，JS开发人员一般也很少需要处理到字位级别。

`~`的另一定义源自早先的计算机科学和离散数学：`~`得到二的补码。这样解释就清楚多了！

`~x`和`-(x+1)`大致相同。虽然奇怪但比较容易理解：

```
    ~42;    // -(42+1) ==> -43
```

或许有人还是没有完全弄明白`~`是怎么回事，为什么我们会把它放在强制类型转换一章中，原因如下。

以`-(x+1)`为例。唯一能得到结果`0`（严格来说是`-0`）的`x`值是`-1`。

然而这与我们讨论的内容有什么关系呢？

`-1`通常称为“哨位值（sentinel value）”，指的是那些在各自类型中（这里是`number`）被赋予了特殊含义的值。在C语言中我们用`-1`来代表函数执行失败，用大于等于`0`的值来代表函数执行成功。

JavaScript中`string`的`indexOf(..)`方法也遵循此惯例，其在字符串中搜索指定的子字符串，如果找到则返回子字符串的位置（从0开始），否则返回`-1`。

`indexOf(..)`不仅用于获取子字符串的位置，还被用来检查字符串中是否包含指定的子字符串，相当于一个`boolean`判断。例如：

```
    var a = "Hello World";
    
    if (a.indexOf( "lo" ) >= 0) {   // true
        // found it!
    }
    if (a.indexOf( "lo" ) != -1) {  // true
        // found it }
    if (a.indexOf( "ol" ) < 0) {    // true
        // not found!
    }
    if (a.indexOf( "ol" ) == -1) {  // true
        // not found!
    }
```

`>= 0`和`== -1`这样的写法不是很好，属于“抽象渗漏（leaky abstraction）”，意思是在代码中暴露了底层的实现细节，这里是指用`-1`作为失败返回值，这些细节应该被隐藏。

现在我们终于明白`~`的用处了！`~`和`indexOf()`一起可以将结果“强制类型转换”（实际上只是转换）为真／假值：

```
    var a = "Hello World";
    
    ~a.indexOf( "lo" );         // -4 <-- truthy!
    
    if (~a.indexOf( "lo" )) {   // true
        // found it!
    }
    
    ~a.indexOf( "ol" );         // 0  <-- falsy!
    !~a.indexOf( "ol" );        // true
    
    if (!~a.indexOf( "ol" )) {  // true
        // not found!
    }
```

如果`indexOf(..)`返回`-1`，`~`将其转换为`假值0`，其他情况一律转换为`真值`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>-(x+1)</b>似乎意味着<b>~-1</b>的结果是<b>-0</b>，然而实际上结果是<b>0</b>，因为其是字位操作而非数学运算。</td>
    </tr>
</table>

从技术角度来说，`if (~a.indexOf(..))`仍然是对`indexOf(..)`的返回结果进行*隐式*强制类型转换，`0`转换为`false`，其他情况则为`true`。但我感觉`~`更象*显式*强制类型转换，前提是我对它有充分的理解。

个人认为`~`比`>= 0`和`== -1`更简洁。

#####字位截除

有些开发人员使用`~~`来截除（truncate）`number`值的小数部分，以为这和`Math.floor(..)`的效果一样，实际上并非如此。

`~~`中的第一个`~`执行`ToInt32`并反转字位，然后第二个`~`再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是`ToInt32`的结果。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>~~</b>和<b>!!</b>很相似，我们将在<b>第83页的“显式转换为Boolean”</b>一节中介绍。</td>
    </tr>
</table>

对`~~`我们要特别小心。首先它仅适用于32位数字，更重要的是它对负数的处理与`Math.floor(..)`不同。

```
    Math.floor( -49.6 );    // -50
    ~~-49.6;                // -49
```

抛开它们之间的差异不谈，`~~x`能将值截除为一个32位整数。`x | 0`同样也可以，而且还显得更*简洁*。

出于运算符优先级（详见`第五章`）的考虑，我们更倾向于使用`~~x`：

```
    ~~1E20 / 10;        // 166199296
    1E20 | 0 / 10;      // 1661992960
    (1E20 | 0) / 10;    // 166199296
```

建议在自己充分掌握以及别人充分理解的前题下再使用`~`和`~~`进行“强制类型转换”。

#####显式解析数字字符串

解析`string`中的`number`类似于将`string`强制类型转换为`number`，返回的也是`number`。但它们之间仍有一些显著的差别。

例如：

```
    var a = "42";
    var b = "42px";

    Number( a );    // 42
    parseInt( a );  // 42
    
    Number( b );    // NaN
    parseInt( b );  // 42
```

对`string`中的`number`进行解析时*允许*`string`中含有非`number`字符，按从左到右的顺序，如果遇到非`number`字符则解析停止。然而`string`到`number`的强制类型转换*不允许*非`number`字符，否则会失败并返回`NaN`。

两者之间并非相互替代的关系。它们虽然相似，但用途不同。如果`string`右边的非`number`字符无关紧要，就可以使用解析。而`string`到`number`的强制类型转换要求`string`中所有的字符都是数字，象"42px"这样的`string`是不行的。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">解析字符串中的浮点数可以用<b>parseFloat(..)</b>函数。
        </td>
    </tr>
</table>

不要忘了`parseInt(..)`针对的是`string`值。向`parseInt(..)`传递`number`和其他类型的参数是没有意义的，比如：`true`，`function(){...}`，和`[1,2,3]`。

非`string`参数会首先被强制类型转换为`string`（见`第59页上的“ToString”`），依赖这类*隐式*强制类型转换并非上策，应该避免向`parseInt(..)`传递非`string`参数。

ES5之前`parseInt(..)`有一个导致了很多bug的坑。如果没有第二个参数来指定转换的基数（又称为radix），`parseInt(..)`会根据`string`的第一个字符来自行决定基数。

如果第一个字符是`x`或`X`，则转换为十六进制`number`。如果第一个字符是`0`，则转换为八进制`number`。

以'x'和'X'开头的十六进制相对来说还不是很容易搞错，八进制则不然。例如：

```
    var hour = parseInt( selectedHour.value );
    var minute = parseInt( selectedMinute.value );
    
    console.log(
       "The time you selected was: " + hour + ":" + minute
);
```

上面的代码看似没有问题。但是当小时数为`08`、分钟数为`09`时上例的结果为`0:0`，因为`8`和`9`都不是有效的八进制数。

解决办法很简单，*将第二个参数设置为10*即可：

```
    var hour = parseInt( selectedHour.value, 10 );
    var minute = parseInt( selectedMiniute.value, 10 );
```

从ES5开始`parseInt(..)`默认转换为十进制数，除非特别指定。如果代码需要在ES5之前的环境中运行，还是要记得将第二个参数设置为`10`。

#####解析非字符串

曾经有人发帖吐槽过`parseInt(..)`的一个坑：

```
    parseInt( 1/0, 19 ); // 18
```

我们想当然地认为（实际上是完全错误的）“如果第一个参数值为`Infinity`，解析结果也应该是`Infinity`”，返回`18`也太无厘头了。

抛开这个纯属虚构的例子不谈，我们来看看JS是否真有这么搞。 

首先一个错误是向`parseInt(..)`传递非`string`，这完全是在自找麻烦。这种情况下JS会将参数强制类型转换为它能够处理的`string`。

有人可能会觉得这毫无道理，`parseInt(..)`应该拒绝接受非`string`参数。这样的话它是否应该抛出一个错误？这是Java的做法。一想到JS代码中到处是抛出的错误，要在每个地方加上`try..catch`，我整个人都不好了。

那是不是应该返回`NaN`？也许吧，但是下面的情况又怎么办呢：

```
    parseInt( new String( "42") );
```

是否应该运行失败？因为它的参数也是一个非`string`。如果我们认为应该将该`String`封装对象拆封（unbox）为`"42"`，那么将非`string`参数`42`先转换为`"42"`，再解析回`42`也是可以的了？

这种半*显式*
、半*隐式*的强制类型转换很多时候非常有用。例如：

```
    var a = {
        num: 21,
        toString: function() { return String( this.num * 2 ); }
    };

    parseInt( a ); // 42
```

`parseInt(..)`先将参数强制类型转换为`string`再进行解析，这样做合情合理。传递垃圾参数得到垃圾结果，这并不是函数本身的问题。

`Infinity`（`1/0`的结果）怎么来处理最合理呢？有两个选择：`"Infinity"`和`"∞"`，JS选择了`"Infinity"`。

JS中所有的值都有一个缺省的`string`呈现，这样挺好，能够方便我们调试。

再来看看基数19？这显然是个玩笑话，我们在实际的JS代码中不会用到基数19。玩笑与否我们先不管，它的有效数字字符范围是`0-9`和`a-i`（区分大小写）。

回到`parseInt(1/0, 19)`。它实际上是执行`parseInt("Infinity", 19)`。第一个字符是"I"，以19为基数时值为`18`。第二个字符`"n"`不是一个有效的数字字符，解析到此为止，和`"42px"`中的`"p"`一样。

最后的结果是`18`，而非`Infinity`或者抛出错误。所以理解其中的工作原理对于我们学习JS是*非常重要*的。

下面是`parseInt(..)`其他一些看似奇怪实则不然的例子：

```
    parseInt( 0.000008 );       // 0   ("0" from "0.000008")
    parseInt( 0.0000008 );      // 8   ("8" from "8e-7")
    parseInt( false, 16 );      // 250 ("fa" from "false")
    parseInt( parseInt, 16 );   // 15  ("f" from "function..")
    
    parseInt( "0x10" );         // 16
    parseInt( "103", 2 );       // 2
```

实际上`parseInt(..)`的行为极具一致性和可预测性。使用得当的话都不会有问题。由于使用不当而产生一些莫名其妙的结果并非JavaScript本身的问题。

#####显式转换为Boolean

现在我们来看看从非`boolean`强制类型转换为`boolean`的情况。

与前面的`String(..)`和`Number(..)`一样，`Boolean(..)`（不带`new`）是一种显式的`ToBoolean`强制类型转换：

```
    var a = "0";
    var b = [];
    var c = {};

    var d = "";
    var e = 0;
    var f = null;
    var g;
    
    Boolean( a ); // true
    Boolean( b ); // true
    Boolean( c ); // true
    
    Boolean( d ); // false
    Boolean( e ); // false
    Boolean( f ); // false
    Boolean( g ); // false
```

虽然`Boolean(..)`是显式的，但并不常用。

和`+`（前面讲过）类似，一元运算符`!`显式地将值强制类型转换为`boolean`。*问题*是它同时还将真值反转为假值（或者相反）。所以将值显式地强制类型转换为`boolean`最常见的方法是使用`!!`，因为第二个`!`会将结果反转回原值：

```
    var a = "0";
    var b = [];
    var c = {};

    var d = "";
    var e = 0;
    var f = null;
    var g;

    !!a; // true
    !!b; // true
    !!c; // true

    !!d; // false
    !!e; // false
    !!f; // false
    !!g; // false
```

在`boolean`上下文，如`if(..)..`中，如果没有`Boolean(..)`和`!!`，上述的`ToBoolean`转换会*隐式*地进行。为了让代码更加清晰，建议使用`Boolean(..)`和`!!`来进行显式转换。

显式`ToBoolean`的另外一个用途，是在JSON序列化过程中将值强制类型转换为`true`或`false`：

```
    var a = [ 1,
            function(){ /*..*/ },
            2,
            function(){ /*..*/ }
    ];

    JSON.stringify( a ); // "[1,null,2,null]"

    JSON.stringify( a, function(key,val){
        if (typeof val == "function") {
            // force `ToBoolean` coercion of the function
            return !!val;
        }
        else {
            return val;
    } } );
    // "[1,true,2,true]"
```

下面的语法对于熟悉Java的人并不陌生：

```
    var a = 42;

    var b = a ? true : false;
```

三元运算符`? :`判断`a`是否为真，如果是则将变量b赋值`true`，否则赋值`false`。

表面上这是一个*显式*的`ToBoolean`强制类型转换，因为返回结果是`true`或者`false`。

然而其中包含*隐式*强制类型转换，因为`a`要首先被强制类型转换为`boolean`才能进行判断。这种情况称为“显式的隐式”，有害无益，要彻底杜绝。

建议使用`Boolean(a)`和`!!a`来进行显式强制类型转换。

####隐式强制类型转换

*隐式*强制类型转换（implicit coercion）指的是那些隐蔽的类型转换，产生的副作用（side effects）也不是很明显。换而言之，任何你觉得不明显的类型转换都是*隐式*类型转换。

*显式*强制类型转换旨在让代码更加清晰易读，而*隐式*强制类型转换则相反，会让代码晦涩难懂。

对强制类型转换的诟病大多是针对*隐式*强制类型转换。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><i>《JavaScript: The Good Parts》</i>的作者Douglas Crockford在许多场合和文章中都主张尽量不要使用强制类型转换。他认为<i>隐式</i>强制类型转换非常糟糕。然而看看他的代码我们就会发现他也大量使用了<i>隐式</i>和<i>显式</i>强制类型转换。他的不满大部分是针对<b>==</b>运算符，但在本章中你会发现其只是强制类型转换的冰山一角。</td>
    </tr>
</table>

问题是隐式强制类型转换真是如此不堪吗？它是不是JavaScript语言的设计缺陷？我们是否应该对其退避三舍？

大多数人或许会毫不犹豫地回答“是！”。

其实不然，请容我细细道来。

让我们从另一个角度来看看*隐式*强制类型转换究竟为何物、应该如何运用，而非仅将其视为“显式强制类型转换的对立面”，因为这样理解太过狭隘，并且忽略了它们之间一个重要而细微的差别。

我理解的*隐式*强制类型转换的目是减少冗余，让代码更简洁。

#####隐式简化

我们先来看看下面这个例子，它不是JavaScript代码，而是强类型语言伪代码（pseudo code）：

```
    SomeType x = SomeType( AnotherType( y ) )
```

变量`y`的值被转换为`SomeType`类型。问题是语言本身不允许直接将`y`转换为`SomeType`类型。于是我们需要一个中间步骤，先将`y`转换为`AnotherType`类型，然后再从`AnotherType`转换为`SomeType`。

如果语言本身允许这样：

```
    SomeType x = SomeType( y )
```

省去了中间步骤以后，类型转换是不是变得更简洁了。因为这些不必要的中间步骤可以也应该被隐藏。

也许有人会说在某些情况下这些中间步骤还是必要的。但是我认为通过语言本身或者定制方法来抽象和隐藏一些琐碎的细节，让代码更简洁易读，才是简化（simplification）的真正意义所在。

当然这些中间步骤仍然会在幕后某处发生。但是如果在代码中隐藏了这些细节，我们就可以专注于问题本身，这里是将变量`y`转换为`SomeType`类型。

虽然这个例子与JS的*隐式*强制类型转换并非完全是一码事，但这里我想表达的意思是，*隐式*强制类型转换同样可以用来提高代码可读性。

但凡事无绝对，*隐式*强制类型转换也会带来一些不好的东西，有时甚至超过它带来的好处。因此我们更应该学习如何避免这些不好的东西。

许多开发人员认为如果某个机制能够带来好处*A*但是同时又有坏处*Z*，为保险起见就干脆整个放弃。

我反对这种“因噎废食”的做法。不要因为我们看到的都是负面影响而想当然地认为*隐式*强制类型转换一无是处。它也有好的方面，希望越来越多的人能够发现并接受它。

#####字符串和数字之间的隐式转换

前面我们介绍了`string`和`number`之间的*显式*强制类型转换。现在说一说它们之间的*隐式*强制类型转换。我们先来看一些会导致*隐式*强制类型转换的操作。

通过重载（overloading），`+`运算符即能用于`number`加法，也能用于`string`拼接。那么JS如何知道我们要执行哪种操作呢？例如：

```
    var a = "42";
    var b = "0";

    var c = 42;
    var d = 0;
    
    a + b; // "420"
    c + d; // 42
```

为什么会得到`"420"`和`42`两个不同的结果？常见的误解是，因为某个或者两个操作数都是`string`，所以`+`进行的是`string`拼接。这样理解部分正确，实际情况要复杂得多。

例如：

```
    var a = [1,2];
    var b = [3,4];

    a + b; // "1,23,4"
```

`a`和`b`都不是`string`，但是它们都被强制转换为`string`然后进行拼接。这是为什么呢？

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">下面两段内容来自规范，如果太难理解可以跳过。</td>
    </tr>
</table>

根据ES5规范第11.6.1节，如果某个操作数为`string`，或者能够通过以下步骤得到`string`值的话，`+`将进行拼接操作。如果`+`的其中一个操作数为`object`（包括`array`），则首先对该操作数调用`ToPrimitive`抽象操作（第9.1节），该抽象操作接着调用`[[DefaultValue]]`（第8.12.8节），以`number`作为上下文。

如果我们多加留意会发现这和`ToNumber`抽象操作处理`object`的方式一样（见`第65页“ToNumber”`）。因为`array`的`valueOf()`操作无法产生简单基本类型值，所以它转而调用`toString()`来得到`string`值。因此上例中的两个数组变成了`"1,2"`和`"3,4"`。`+`将这两个`string`拼接起来返回：`"1,23,4"`。

简单说就是如果`+`的其中一个操作数是`string`（或者通过以上步骤可以得到`string`值），则执行`string`拼接。否则执行`number`加法。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">一个常被人们提到的坑是<b>[] + {}</b>和<b>{} + []</b>，它们的结果不同，分别是"[object Object]"和0。我们将在<b>第134页的“代码块”一节</b>详细介绍。</td>
    </tr>
</table>

这意味着我们可以通过和空`string ""`的`+`操作来将`number`转换为`string`：

```
    var a = 42;
    var b = a + "";
    
    b; // "42"
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;"><b>+</b>作为数字加法操作是可互换的，即<b>2 + 3</b>等同于<b>3 + 2</b>。作为字符串拼接操作则不行，但对于空字符串""来说，<b>a + ""</b>和<b>"" + a</b>的结果是一样的。</td>
    </tr>
</table>

`a + ""`这样的*隐式*转换极为常见。有意思的是许多批评*隐式*强制类型转换的人也这样做。

这很能说明问题，无论怎样为人诟病，*隐式强制类型转换*仍然有它的用武之地。

比较`a + ""`（隐式）和之前介绍过的`String(a)`（显式），两者之间有一个细微的差别需要注意。根据`ToPrimitive`抽象操作的工作原理，`a + ""`会对`a`调用`valueOf()`方法，然后返回值通过`ToString`抽象操作转换为`string`。而`String(a)`则是直接调用`ToString()`。

它们最终返回的都是`string`，但如果`a`不是`number`基本类型而是`object`，就有可能得到其它结果！

例如：

```
    var a = {
        valueOf: function() { return 42; },
        toString: function() { return 4; }
    };
    
    a + ""; // "42"
    
    String( a );    // "4"
```

如果代码中不存在匪夷所思的数据结构和操作，一般是不太可能碰到这个问题的，但是如果我们要为某些对象自定义`valueOf()`和`toString()`方法，就需要特别小心，因为这会影响到强制类型转换的结果。

再来看看反过来从`string`强制类型转换为`number`情况。

```
    var a = "3.14";
    var b = a - 0;
    
    b; // 3.14
```

`-`是数字减法运算符，因此`a - 0`会将`a`强制类型转换为`number`。也可以用`a * 1`和`a / 1`，因为这两个运算符也只适用于数字，不过这两种用法不太常见。

对`object`执行`-`操作和`+`类似：

```
    var a = [3];
    var b = [1];
    
    a - b; // 2
```

为了执行减法运算符`-`，`a`和`b`都需要转换为`number`，首先转换为`string`（通过`toString()`），然后再转换为`number`。

`string`和`number`之间的*隐式*强制类型转换真如大家所说的那样糟糕吗？我不这样认为。

`b = String(a)`（*显式*）和`b = a + ""`（*隐式*）各有各的好处，`b = a + ""`更常见一些。所以就算备受争议，*隐式*强制类型转换仍然有它存在的意义。

#####布尔值到数字的隐式强制类型转换

将复杂的`boolean`逻辑转换为数字加法时，*隐式*强制类型转换相当管用。这种情况并不多见，属于特殊情况的特殊处理。

例如：

```
    function onlyOne(a,b,c) {
        return !!((a && !b && !c) ||
            (!a && b && !c) || (!a && !b && c));
    }
    
    var a = true;
    var b = false;
    
    onlyOne( a, b, b ); // true
    onlyOne( b, a, b ); // true
    
    onlyOne( a, b, a ); // false
```

如果其中有且仅有一个参数为`true`（或者真值），函数`onlyOne(..)`返回`true`。它在条件判断中使用了*隐式*强制类型转换，其他地方则是*显式*的，包括最后的返回值。

但是如果有四个、五个、甚至二十个参数，上面的代码就很难处理了。

这时就可以使用从`boolean`到`number`（`0或1`）的强制类型转换：

```
    function onlyOne() {
        var sum = 0;
        for (var i=0; i < arguments.length; i++) {
            // skip falsy values. same as treating
            // them as 0's, but avoids NaN's.
            if (arguments[i]) {
                sum += arguments[i];
            }
        }
        return sum == 1;
    }
   
    var a = true;
    var b = false;
   
    onlyOne( b, a );                // true
    onlyOne( b, a, b, b, b );       // true
   
    onlyOne( b, b );                // false
    onlyOne( b, a, b, b, b, a );    // false
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">在<b>onlyOne(..)</b>中，除了使用loop循环，也可以直接使用ES5规范中的reduce(..)函数。</td>
    </tr>
</table>

我们通过`sum += arguments[i]`中的*隐式*强制类型转换，将真值（true/truthy）的转换结果`1`进行累加。如果有且仅有一个参数为`true`，累加结果为`1`，否则结果不为`1`，`sum == 1`条件不成立。

同样的功能也可以通过*显式*强制类型转换来实现：

```
    function onlyOne() {
        var sum = 0;
        for (var i=0; i < arguments.length; i++) {
            sum += Number( !!arguments[i] );
        }
        return sum === 1;
    }
```

`!!arguments[i]`首先将参数转换为`true`或`false`。因此非`boolean`参数也不会出问题，如：`onlyOne("42", 0)`（否则会发生`string`拼接，这样结果就不对了）。

参数转换为`boolean`后，再通过`Number(..)`*显式*强制类型转换为`0`或`1`。

这里使用*显式*强制类型转换会不会更好一些？注释说这样确实能够避免`NaN`带来的问题。但这最终取决于我们自身的需要。我个人觉得前者，即*隐式*强制类型转换，更为简洁（前提是我们不会传递`undefined`和`NaN`这样的值），而*显式*强制类型转换则会带来一些代码冗余。

总之如本书一贯强调的那样，一切都取决于我们自己的判断和权衡。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">无论是<i>隐式</i>还是<i>显式</i>，我们都能通过修改<b>onlyTwo(..)</b>或者<b>onlyFive(..)</b>来处理更复杂的情况，只需要将最后的条件判断从<b>1</b>改为<b>2</b>或者<b>5</b>。这比加入一大堆<b>&amp;&amp;</b>和<b>||</b>表达式要简洁的多。所以强制类型转换在这里还是很有帮助的。</td>
    </tr>
</table>

#####到布尔值的隐式强制类型转换

现在我们来看看到`boolean`的*隐式*强制类型转换，它最常见也最容易弄错。

请记住这里涉及*隐式*强制类型转换。`number`和`string`操作中的强制类型转换十分显而易见。

涉及`boolean`*隐式*强制类型转换的情况有：

1. `if (..)`语句中的条件判断表达式
2. `for ( .. ; .. ; .. )`语句中的条件判断表达式（第二个）
3. `while (..)`和`do..while(..)`循环中的条件判断表达式
4. `? :`中的条件判断表达式
5. 逻辑运算符`||`（逻辑或）和`&&`（逻辑与）左边的操作数（作为条件判断表达式）。

以上情况中的非`boolean`值会被*隐式*强制类型转换为`boolean`，遵循本章之前介绍过的`ToBoolean`抽象操作规则。

例如：

```
    var a = 42;
    var b = "abc";
    var c;
    var d = null;
    
    if (a) {
        console.log( "yep" );   // yep
    }

    while (c) {
        console.log( "nope, never runs" );
    }

    c = d ? a : b; 
    c;                          // "abc"
    
    if ((a && d) || c) {
        console.log( "yep" );   // yep
    }
```

上例中，非`boolean`值会被*隐式*强制类型转换为`boolean`值以便执行条件判断。

#####||和&&

`||`（逻辑或）和`&&`（逻辑与）运算符对你应该并不陌生，或许你会以为它们在JavaScript中的表现和其它语言差不多。

然而这里有一个十分重要却不太为人所知的细微差别。

实际上我不太愿意把它们叫做“逻辑运算符”，因为这不能完全体现它们的功能。更准确（也更冗长）的叫法应该是“选择器运算符（selector operators）”，或者“操作数选择器运算符（operand selector operators）”。

因为和其他语言不同，它们在JavaScript中的返回值并非`boolean`。

它们返回两个操作数中的一个（且仅一个）。即选择两个操作数中的一个，然后返回它的值。

引述ES5规范第11.11节：

*&&和||运算符的返回值并不一定是`boolean`类型，而是两个操作数其中一个的值。*

例如：

```
    var a = 42;
    var b = "abc";
    var c = null;

    a || b;     // 42 
    a && b;     // "abc"
    
    c || b;     // "abc" 
    c && b;     // null
```

这是怎么回事？在C和PHP中它们的结果是`true`或`false`，在JS（以及Python和Ruby）中的结果却是操作数的值。

`||`和`&&`首先会对*第一个操作数*（`a`和`c`）进行`boolean`条件判断。如果不是`boolean`值（如上例）则执行`ToBoolean`强制类型转换以便执行条件判断。

对于`||`来说，如果条件判断结果为`true`则返回第一个操作数（`a`和`c`）的值。如果为`false`则返回第二个操作数（`b`）的值。

相反对于`&&`，如果条件判断结果为`true`则返回第二个操作数（`b`）的值。如果为`false`则返回第一个操作数（`a`和`c`）的值。

`||`和`&&`返回它们的其中一个操作数的值，而非条件判断的结果（其中可能涉及强制类型转换）。在`c && b`中`c`为`null`，是个假值，因而`&&`表达式的返回结果是`null`（即`c`的值），而不是条件判断的结果`false`。

现在你明白为什么把它们叫做“操作数选择器”了吧？

从另一个角度来理解：

```
    a || b;
    // 大致相当于(roughly equivalent to):
    a ? a : b;

    a && b;
    // 大致相当于(roughly equivalent to):
    a ? b : a;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">之所以说大致相当（roughly equivalent）是因为返回结果相同，但是它们之间存在一个细微的差别。在<b>a ? a : b</b>中，如果<b>a</b>是一个更为复杂的表达式（比如有副作用的函数调用等），则它有可能被执行两次（如果第一次结果为真）。相反在<b>a || b</b>中<b>a</b>只执行一次，其结果用于条件判断及返回值（如果适用的话）。<b>a &amp;&amp; b</b>和<b>a ? b : a</b>的情况也一样。</td>
    </tr>
</table>

下面是`||`一个十分常见的用法，也许你已经用过但并未完全理解：

```
    function foo(a,b) {
        a = a || "hello";
        b = b || "world";
     
        console.log( a + " " + b );
    }

    foo();                  // "hello world"
    foo( "yeah", "yeah!" ); // "yeah yeah!"
```

`a = a || "hello"`（又叫做C#“空合并运算符，null coallescing operator”的JavaScript版本）检查变量`a`，如果它未赋值（或者为假值），就赋予它一个缺省值（`"hello"`）。

但这里需要注意！

```
    foo( "That's it!", "" ); // "That's it! world" <-- Oops!
```

第二个参数`""`是一个`假值`（`falsy value`，见`第67页的“ToBoolean”`），因此`b = b || "world"`条件不成立，返回缺省值`"world"`。

这种用法极为常见，但是不能有`假值`，除非加入更多条件判断，或者转而使用`? :`三元表达式。

通过这种方式来设置`缺省值`很方便，甚至那些公开诟病JavaScript强制类型转换的人也在用。

再来看看`&&`。

有一种方法对于开发人员不太常见，但JS代码压缩工具经常使用。即如果第一个操作数为真值，则`&&`运算符“选择”第二个操作数作为返回值，这也叫做“守护运算符（guard operator）”（见`第五章``第140页的“短路（Short Circuited）”`）－－前面的表达式为后面的表达式“把关”：

```
    function foo() {
        console.log( a );
    }
    
    var a = 42;
    
    a && foo(); // 42
```

`foo()`只有在条件判断`a`通过时才会被调用。如果条件判断未通过，`a && foo()`就会悄然终止（也叫做“短路，short circuiting”），`foo()`不会被调用。

这样的用法对于开发人员不太常见，通常是用`if (a) { foo(); }`。但是JS代码压缩工具用的是`a && foo()`，因为更简洁。以后看到这样的代码我们就能知其所以然了。

`||`和`&&`有它们各自的用武之地，前提是我们理解且愿意在代码中使用*隐式*强制类型转换。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>a = b || "something"</b>和<b>a &amp;&amp; b()</b>使用到了“短路”机制，我们将在<b>第五章第140页的“短路”</b>一节中详细介绍。</td>
    </tr>
</table>

有人可能会问，如果返回的不是`true`和`false`，为什么`a && (b || c)`这样的表达式在`if`和`for`中没有出现问题。

问题或许不在于此，而在于他们不知道那些条件判断表达式最后还会执行`boolean`*隐式*强制类型转换。

例如：

```
    var a = 42;
    var b = null;
    var c = "foo";
    
    if (a && (b || c)) {
        console.log( "yep" );
    }
```

结果不出预料，除了一个细节，实际上`a && (b || c)`的结果是`"foo"`而非`true`，然后再由`if`将`foo`强制类型转换为`boolean`，所以最后结果为`true`。

现在明白了吧，这里发生了*隐式*强制类型转换。如果要避免*隐式*强制类型转换就得这样：

```
    if (!!a && (!!b || !!c)) {
        console.log( "yep" );
    }
```

#####Symbol强制类型转换

目前为止我们并没有发现*显式*和*隐式*强制类型转换产生的结果有明显不同，它们之间的差异仅仅体现在代码可读性方面。

但ES6中引入的symbol在强制类型转换时很容易出错，需要在这里介绍一下。ES6允许从`symbol`到`string`的*显式*强制类型转换，但相应的*隐式*强制类型转换则会产生`错误`，具体的原因不在本书讨论范围之内。

例如：

```
    var s1 = Symbol( "cool" );
    String( s1 );     // "Symbol(cool)"
   
    var s2 = Symbol( "not cool" );
    s2 + "";      // TypeError
```

`Symbol`不能被强制类型转换为`number`（`显式`和`隐式`都会产生`错误`），但可以被强制类型转换为`boolean`（`显式`和`隐式`结果都是`true`）。

由于规则缺乏一致性，我们需要对ES6中`symbol`的强制类型转换多加小心。

好消息是鉴于其用途（见`第三章`），我们不太可能经常碰到`symbol`强制类型转换。

####宽松相等和严格相等

宽松相等（loose equals）运算符`==`和严格相等（strict equals）运算符`===`都用来判断两个值是否“相等”，但是它们之间有一个非常重要的区别，特别是在判断条件上。

一个常见的误区是：“`==`检查值是否相等，`===`检查值和类型是否相等”。听起来蛮有道理，但是不太准确。很多JavaScript书籍和博客也是这样解释的，很遗憾他们都搞错了。

正确的解释是：“在相等比较中，`==`允许强制类型转换，而`===`不允许”。

#####相等比较操作的性能

我们来看一看两种解释的区别。

根据第一种解释（不准确的），`===`似乎比`==`做的事情更多一些，因为还需要检查值的类型。第二种解释中，`==`的工作量更大，因为如果值的类型不同还需要进行强制类型转换。

有人认为`==`比`===`更慢，实际上虽然强制类型转换的确需要花多点时间，但差别仅是微秒级（百万分之一秒）。

如果进行比较的两个值类型相同，则`==`和`===`使用相同的算法，所以除了JS引擎实现上的微小差别之外，它们之间并没有不同。

如果两个值类型不同，我们要考虑不是性能，而是有无进行强制类型转换的必要。

如果有必要就用`==`，没有就用`===`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>==</b>和<b>===</b>都会检查操作数的类型。区别在于操作数类型不同时它们的处理方式不同。</td>
    </tr>
</table>

#####抽象相等

ES5规范第11.9.3节的“抽象相等比较算法”定义了`==`运算符的工作机制。该算法既全面又简单，涵盖了所有可能出现的类型组合，以及每种组合的强制类型转换方式。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">这些“抽象相等（abstract equality）”规则正是<i>隐式</i>强制类型转换被诟病的原因。开发人员觉得它们过于晦涩，难以掌握和运用，并且弊（导致bug）大于利（提高代码可读性）。这种观点我不敢苟同，因为我的读者都是优秀的开发人员，整天与算法和代码打交道，“抽象相等”只是小菜一碟。不过我还是推荐大家去看一看ES5规范第11.9.3节，到时你会惊讶地发现这些规则是多么有道理。</td>
    </tr>
</table>

其中第一段（11.9.3.1）中规定如果两个值类型相同，就只比较它们的值是否相等。例如，`42`等于`42`，`"abc"`等于`"abc"`。

有几个非常规的情况需要注意：

- `NaN`不等于`NaN`（见`第二章`）。
- `+0`等于`-0`（见`第二章`）。 

11.9.3.1最后一段中定义了`object`（包括`function`和`array`）的宽松相等`==`。两个对象指向*同一个值*时视为相等。这里不涉及强制类型转换。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">严格相等<b>===</b>的定义和11.9.3.1一样，包括对象的相等比较。很少有人知道在比较两个对象的时候，<b>==</b>和<b>===</b>的工作原理是一样的。</td>
    </tr>
</table>

11.9.3中还规定，使用`==`来比较两个不同类型的值时会发生*隐式*强制类型转换，需要将两者其中之一或者全部转换为相同类型后再进行相等比较。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">宽松不相等（loose not-equality）<b>!=</b>的定义和我们设想的一样，即<b>==</b>的相反值。<b>!==</b>也同理。</td>
    </tr>
</table>

#####字符串和数字之间的相等比较

为了举例说明`==`，我们先来看看本章前面的有关`string`和`number`的例子：

```
    var a = 42;
    var b = "42";

    a === b;    // false
    a == b;     // true
```

不出我们所料，`a === b`为`false`，因为其中没有强制类型转换，`42`和`"42"`不相等。

而`a == b`是宽松相等，即如果两个值的类型不同，则对其中之一或全部进行强制类型转换。

这里的强制类型转换是怎样进行的呢？是`a`从`42`转换为`string`，还是`b`从`"42"`转换为`number`？

ES5规范11.9.3.4-5中是这样定义的：

```
1. 如果Type(x)是数字，Type(y)是字符串，则返回 x == ToNumber(y) 的结果。
2. 如果Type(x)是字符串，Type(y)是数字，则返回 ToNumber(x) == y 的结果。
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">规范中使用<b>Number</b>和<b>String</b>代表数字和字符串类型，而本书使用的是<b>number</b>和<b>string</b>。切勿将规范中的<b>Number</b>和原生函数<b>Number()</b>搞混。本书中类型名的首字符大写和小写是一回事。</td>
    </tr>
</table>

根据规范`"42"`应该被强制类型转换为`number`以便进行相等比较。相关规则，特别是`ToNumber`抽象操作的规则，我们前面已经介绍过。本例中两个值相等，均为`42`。

#####其他类型和布尔类型之间的相等比较

`==`最容易出错的地方之一是`true`和`false`与其他类型之间的相等比较。

例如：

```
    var a = "42";
    var b = true;

    a == b; // false
```

这是怎么回事？我们都知道`"42"`是一个真值（见本章前面的介绍）。为什么`==`的结果不是`true`呢？原因很简单但又不好理解，很容易让人掉坑里，很多JS开发人员并未对此引起足够的重视。

规范11.9.3.6-7是这样说的：

```
1. 如果Type(x)是布尔类型，则返回 ToNumber(x) == y 的结果。
2. 如果Type(y)是布尔类型，则返回 x == ToNumber(y) 的结果。
```

仔细看一下这个例子。首先：

```
    var x = true;
    var y = "42";

    x == y; // false
```

`Type(x)`是布尔类型，所以`ToNumber(x)`将`true`强制类型转换为`1`，变成`1 == "42"`，二者的类型仍然不同，根据规则`"42"`被强制类型转换为`42`，最后变成`1 == 42`，结果为`false`。

反过来也一样：

```
    var x = "42";
    var y = false;

    x == y; // false
```

`Type(y)`是布尔类型，所以`ToNumber(y)`将`false`强制类型转换为`0`，然后`"42" == 0`再变成`42 == 0`，结果为`false`。

也就是说字符串`"42"`既不等于`true`，也不等于`false`。一个值怎么可以既非真值也非假值，这也太奇怪了吧？

提这样的问题本身就是错误的，实际情况并非如此。

`"42"`的确是一个真值，但`"42" == true`并非`boolean`值的比较和强制类型转换。`"42"`没有转换为`boolean`（`true`），而是`true`转换为`1`，`"42"`转换为`42`。

这里并不涉及`ToBoolean`，所以`"42"`是真值还是假值与`==`本身没有关系！

重点是要搞清楚`==`对不同的类型组合怎样处理。`==`两边的`boolean`值会被强制类型转换为`number`。

很奇怪不是吗？我个人建议无论什么情况，永远不要使用`== true`和`== false`。

请注意这里说的只是`==`，`=== true`和`=== false`不允许强制类型转换，所以并不涉及`ToNumber`转换。

例如：

```
    var a = "42";
    
    // bad (will fail!):
    if (a == true) {
        // .. 
    }
    
    // also bad (will fail!):
    if (a === true) {
        // .. 
    }
    
    // good enough (works implicitly):
    if (a) {
        // ..
    }
  
    // better (works explicitly):
    if (!!a) {
        // .. 
    }
    
    // also great (works explicitly):
    if (Boolean( a )) {
        // .. 
    }
```

如果不用`== true`和`== false`（也叫做`boolean`值的宽松相等）就不用担心这些坑了。

#####null和undefined之间的相等比较

`null`和`undefined`之间的`==`也涉及*隐式*强制类型转换。ES5规范11.9.3.2-3规定：

```
1. 如果x为null，y为undefined，则结果为true。
2. 如果x为undefined，y为null，则结果为true。
```

在`==`中`null`和`undefined`相等（它们也与其自身相等），除此之外的其他值都不存在这种情况。

这意味着`null`和`undefined`在宽松相等`==`中是一回事，相互间可以进行*隐式*强制类型转换：

```
    var a = null;
    var b;

    a == b;     // true
    a == null;  // true
    b == null;  // true
    
    a == false; // false
    b == false; // false
    a == "";    // false
    b == "";    // false
    a == 0;     // false
    b == 0;     // false
```

`null`和`undefined`之间的强制类型转换是安全和可预测的，上例中除`null`和`undefined`以外的其他值均无法得到假阳（false positive）结果。建议通过这种方式将`null`和`undefined`作为等同值来处理。

例如：

```
    var a = doSomething();
    
    if (a == null) {
        // ..
    }
```

条件判断`a == null`仅在`doSomething()`返回非`null`和`undefined`时才成立，除此之外的其他值都不成立，包括`0`，`false`和`""`这样的假值。

下面是*显式*的做法，其中不涉及强制类型转换，我个人感觉更繁琐一些（大概执行效率也更低一些）：

```
    var a = doSomething();

    if (a === undefined || a === null) {
        // ..
    }
```

在我看来，`a == null`这样的*隐式*强制类型转换在保证安全性的同时还能提高代码可读性。

#####对象和非对象之间的相等比较

关于对象（`object`／`function`／`array`）和标量基本类型（`string`／`number`／`boolean`）之间的相等比较，ES5规范11.9.3.8-9做如下规定：

```
1. 如果Type(x)是字符串或数字，Type(y)是对象，则返回x == ToPrimitive(y)的结果。
2. 如果Type(x)是对象，Type(y)是字符串或数字，则返回ToPromitive(x) == y的结果。
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这里只提到了字符串和数字，没有<b>布尔值</b>。原因是我们之前介绍过11.9.3.6-7中规定了<b>布尔值</b>会先被强制类型转换为数字。</td>
    </tr>
</table>

例如：

```
    var a = 42;
    var b = [ 42 ];
    
    a == b; // true
```

`[ 42 ]`首先调用`ToPromitive`抽象操作（见`第59页“抽象值操作”`），返回`"42"`，变成`"42" == 42`，然后又变成`42 == 42`，最后相等。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">之前介绍过的<b>ToPromitive</b>抽象操作的所有特性（如：<b>toString()</b>，<b>valueOf()</b>）在这里都适用。在数据结构很复杂需要自行定义<b>valueOf()</b>以便返回一个简单值进行相等比较的时候很有帮助。</td>
    </tr>
</table>

我们在`第三章`介绍了“拆封（unboxing）”，即打开封装对象（如：`new String("abc"）`），返回其中的基本数据类型值（`"abc"`）。`==`中的`ToPromitive`强制类型转换也是如此：

```
    var a = "abc";
    var b = Object( a );    // same as `new String( a )`

    a === b;                // false
    a == b;                 // true
```

`a == b`结果为`true`，因为`b`通过`ToPromitive`进行强制类型转换（也称为“拆封”，英文为unboxed或者unwrapped），并返回标量基本类型值`"abc"`，与变量`a`的值相等。

有一些值不在此列，原因是`==`中其它更优先的规则。例如：

```
    var a = null;
    var b = Object( a );    // same as `Object()`
    a == b;                 // false

    var c = undefined;      
    var d = Object( c );    // same as `Object()`
    c == d;                 // false
    
    var e = NaN;            
    var f = Object( e );    // same as `new Number( e )`
    e == f;                 // false
```

因为没有对应的封装对象（object wrapper），所以`null`和`undefined`不能够被封装（boxed），`Object(null)`和`Object()`均返回一个常规对象。

`NaN`能够被封装为数字封装对象，但拆封后的`NaN == NaN`返回`false`，因为`NaN`不等于`NaN`（见`第二章`）。

####边缘情况

我们已经全面介绍了`==`中的*隐式*强制类型转换（常规和非常规的情况），现在来看一下那些需要特别注意和避免的边缘情况。

首先来看看更改内置原生原型（built-in native prototypes）会导致哪些奇怪的结果：

```
    Number.prototype.valueOf = function() {
        return 3;
    };

    new Number( 2 ) == 3;   // true
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;"><b>2 == 3</b>不会有这种问题，因为<b>2</b>和<b>3</b>都是数字基本类型值，不会调用<b>Number.prototype.valueOf()</b>方法。而<b>Number(2)</b>涉及<b>ToPrimitive</b>强制类型转换，因此会调用<b>valueOf()</b>。</td>
    </tr>
</table>

让人头大。这也是强制类型转换和`==`被诟病的原因之一。但这并非JavaScript本身的问题，而是我们自身的问题。不要觉得“编程语言应该防止开发人员犯错”。

还有更诡异的情况：

```
    if (a == 2 && a == 3) {
        // ..
    }
```

你也许觉得这种情况不可能，因为`a`不可能同时等于`2`和`3`。但“同时”一词并不准确，因为`a == 2`在`a == 3`之前执行。

如果让`a.valueOf()`每次调用都产生副作用，比如第一次返回`2`，第二次返回`3`，就会出现这样的情况。实现起来很简单：

```
    var i = 2;
    
    Number.prototype.valueOf = function() {
        return i++;
    };
   
    var a = new Number( 42 );
    
    if (a == 2 && a == 3) {
        console.log( "Yep, this happened." );
    }
```

再次强调千万不要这样做，也不要因此归咎于强制类型转换。对一种机制的滥用并不能成为诟病它的借口。我们应该正确合理地运用强制类型转换，避免这些极端的情况。

#####假值的相等比较

`==`中的*隐式*强制类型转换最为人诟病的地方是假值的相等比较。

下面分别列出了常规和非常规的情况：

```
    "0" == null;        // false
    "0" == undefined;   // false
    "0" == false;       // true -- 晕！
    "0" == NaN;         // false
    "0" == 0;           // true
    "0" == "";          // false

    false == null;      // false
    false == undefined; // false
    false == NaN;       // false
    false == 0;         // true -- 晕！
    false == "";        // true -- 晕！
    false == [];        // true -- 晕！
    false == {};        // false

    "" == null;         // false
    "" == undefined;    // false
    "" == NaN;          // false
    "" == 0;            // true -- 晕！
    "" == [];           // true -- 晕！
    "" == {};           // false

    0 == null;          // false
    0 == undefined;     // false
    0 == NaN;           // false
    0 == [];            // true -- 晕！
    0 == {};            // false
```

以上二十四种情况中有十七种比较好理解。比如我们都知道`""`和`NaN`不相等，`"0"`和'0'相等。

然而有七种情况加了注释“晕！”，因为它们属于假阳（false positive）的情况，里面坑很多。`""`和`0`明显是两个不同的值，它们之间的强制类型转换很容易搞错。请注意这里不存在假阴（false negatives）的情况。

#####极端情况

这还不算完，还有更极端的例子：

```
    [] == ![]   // true
```

事情变得越来越疯狂了。这看起来象是真值和假值之间的相等比较，结果不应该是`true`，因为一个值不可能同时既是真值也是假值！

事实并非如此。让我们来看看`!`运算符都做了些什么？根据`ToBoolean`规则，它会进行`boolean`显式强制类型转换（同时反转奇偶校验位）。所以`[] == ![]`变成了`[] == false`。前面我们介绍过，`false == []`，所以最后的结果并不出人意料。

再来看看其他情况：

```
    2 == [2];       // true
    "" == [null];   // true
```

介绍`ToNumber`时我们讲过，`==`右边的值`[2]`和`[null]`会进行`ToPrimitive`强制类型转换，以便能够和左边的基本类型值（`2`和`""`）进行比较。因为`array`的`valueOf()`返回`array`本身，所以强制类型转换将对`array`进行字符串化（stringifying）。

第一行中`[2]`会转换为`"2"`，然后通过`ToNumber`转换为`2`。第二行中`[null]`会直接转换为`""`。

最后的结果是`2 == 2`和`"" == ""`就不难理解了。

如果还是觉得头大，那么你的不解可能并非由于强制类型转换，而是`ToPrimitive`将`array`转换为`string`这一过程。你很可能没有想到`[2].toString()`返回的是`"2"`，`[null].toString()`返回的是`""`。

但是如果不这样处理的话又能怎样呢？我实在想不出其他更好的办法。或许应该将`[2]`转换为`"[2]"`，但这样的话在别的地方又显得很奇怪。

有人也许会觉得既然`String(null)`返回`"null"`，所以`String([null])`也应该返回`"null"`。想法确实有道理，这就是问题所在。

*隐式*强制类型转换本身不是问题的根源，因为`[null]`在*显式*强制类型转换中也是转换为`""`。问题在于将`array`转换为`string`是否合理，具体该如何处理。所以实际上这是`String([..])`规则的问题。或许`array`根本就不应该被转换为`string`？但这样一来又会导致很多其它问题。

还有一个常被提到的坑：

```
    0 == "\n";  // true
```

前面介绍过，`""`，`"\n"`（或者`" "`等其他空格组合）等空字符串被`ToNumber`强制类型转换为`0`。这样处理总没有问题了吧，不然你要咋整？

或许可以将空字符串和空格转换为`NaN`，这样`" " == NaN`就为`false`了，然而这并没有从根本上解决问题。

`0 == "\n"`导致程序出错的几率小之又小，不太容易碰到。

类型转换*总*会出现一些特殊情况，并非只有强制类型转换，任何编程语言都是如此。问题出在我们的臆断（有时也许碰巧对了！？），但这并不能成为诟病强制类型转换机制的理由。

上述七种情况基本涵盖了所有我们可能遇到的坑（除修改`valueOf()`和`toStrign()`的情况以外）。

与前面二十四种情况列表相对应的是下面这个列表：

```
    42 == "43";         // false
    "foo" == 42;        // false
    "true" == true;     // false
   
    42 == "42";         // true
    "foo" == [ "foo" ]; // true    
```

这些是非假值的常规情况（实际上还可以加上无穷大数字的相等比较），其中涉及的强制类型转换是安全、合理和好懂的。

#####完整性检查

我们深入介绍了*隐式*强制类型转换中的一些特殊情况。也难怪大多数开发人员都觉得太晦涩，唯恐避之不及。

现在我们回过头来做一下完整性检查（sanity check）。

前面列出了相等比较中的强制类型转换的7个坑，但另外还有至少十七种情况是绝对安全和容易理解的。

因为7棵歪脖树而放弃整片森林似乎有点因噎废食了。明智的做法是扬长避短。

再来看看那些*短*的地方：

```
    "0" == false;   // true -- 晕！
    false == 0;     // true -- 晕！
    false == "";    // true -- 晕！
    false == [];    // true -- 晕！
    "" == 0;        // true -- 晕！
    "" == [];       // true -- 晕！
    0 == [];        // true -- 晕！
```

其中有四种情况涉及`== false`，之前我们说过应该避免，这并不难掌握。

现在剩下三种：

```
    "" == 0;        // true -- 晕！
    "" == [];       // true -- 晕！
    0 == [];        // true -- 晕！
```

正常情况下我们应该不会这样写代码吧。

我想你应该不太可能会用`== []`来做条件判断，而是用`== ""`或者`== 0`，如：

```
    function doSomething(a) {
        if (a == "") {
            // .. 
        }
    }
```

如果不小心碰到`doSomething(0)`和`doSomething([])`这样的情况，结果会让你很惊讶。又如：

```
    function doSomething(a,b) {
        if (a == b) {
            // .. 
        }
    }
```

`doSomething("",0)`和`doSomething([],"")`也会产生意料之外的结果。

这些特殊情况会导致种种问题，需要我们多加小心，好在它们并不是十分常见。

#####安全地运用隐式强制类型转换

关键是我们要对`==`两边的值认真推敲。以下两个原则可以有效地避免错误：

- 如果两边的值中有`true`或者`false`，不要使用`==`。
- 如果两边的值中有`[]`，`""`或者`0`时，尽量不要使用`==`。

这时候最好用`===`，可以避免产生意外的强制类型转换。这两个原则可以让我们避开几乎所有强制类型转换的坑。

这时候的强制类型转换越显式越好，可以避免很多麻烦。

所以`==`和`===`选择哪一个取决于是否允许在相等比较中发生强制类型转换。

强制类型转换在很多地方非常有用，能够让相等比较更简洁（比如`null`和`undefined`）。

*隐式*强制类型转换在少数情况下的确很危险，这时为了安全起见就要使用`===`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">有一种情况下的强制类型转换是绝对安全的，那就是<b>typeof</b>操作。<b>typeof</b>总是返回七个字符串之一（见<b>第一章</b>），其中没有空字符串。所以在类型检查过程中不会发生隐式强制类型转换。<b>typeof x == "function"</b>是100%安全的，和<b>typeof x === "function"</b>一样。事实上两者在规范中是一回事。所以即不要盲从代码工具每一处都用<b>===</b>，更不要不管不问。我们要对自己的代码质量负责。</td>
    </tr>
</table>

*隐式*强制类型转换真的那么不堪吗？某些情况下是，但总的来说并不是。

做为一个成熟负责的开发人员，我们应该学会安全有效地运用强制类型转换（*显式*和*隐式*），并对周围的小伙伴言传身教。

Alex Dorey（GitHub用户名@dorey）在GitHub上制作了一张图表，列出了各种相等比较的情况，如`图4-1`。

![](figures/Figure4-1.png)

*图4-1. JavaScript中的相等比较*

####抽象关系比较

`a < b`中涉及的*隐式*强制类型转换不太引人注意，不过还是很有必要深入了解一下。

ES5规范11.8.5节定义了“抽象关系比较（Abstract Relational Comparison）”，分两部分：比较双方都是`string`（后半部分）的情况和其他的情况（前半部分）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">该算法仅针对<b>a &lt; b</b>，<b>a > b</b>会被处理为<b>b &lt; a</b>。</td>
    </tr>
</table>

比较双方首先调用`ToPrimitive`，如果结果出现非`string`则根据`ToNumber`规则将双方强制类型转换为`number`来进行比较。

例如：

```
    var a = [ 42 ];
    var b = [ "43" ];

    a < b;  // true
    b < a;  // false
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">前面介绍过的<b>-0</b>和<b>NaN</b>的相关规则在这里也适用。</td>
    </tr>
</table>

如果比较双方都是`string`则按字母顺序（natural alphabetic）来比较：

```
    var a = [ "42" ];
    var b = [ "043" ];
    
    a < b; // false
```

`a`和`b`并没有被转换为`number`，因为`ToPrimitive`返回的是`string`，所以这里比较的是`"42"`和`"043"`两个字符串，它们分别以`"4"`和`"0"`开头。因为`"0"`在字母顺序上小于`"4"`，所以最后结果为`false`。

同理：

```
    var a = [ 4, 2 ];
    var b = [ 0, 4, 3 ];
    
    a < b; // false
```

`a`转换为`"4, 2"`，`b`转换为`"0, 4, 3"`，也是按字母顺序进行比较。

再比如：

```
    var a = { b: 42 };
    var b = { b: 43 };
    
    a < b; // ??
```

结果还是`false`，因为`a`是`[object Object]`，`b`也是`[object Object]`，所以按照字母顺序`a < b`并不成立。

下面的例子就有些奇怪了：

```
    var a = { b: 42 };
    var b = { b: 43 };

    a < b;  // false
    a == b; // false
    a > b;  // false
    
    a <= b; // true
    a >= b; // true
```

为什么`a == b`的结果不是`true`？它们的`string`值相同（为`"[object Object]"`），按道理应该相等才对？实际上不是。你可以回忆一下前面介绍过的`object`的相等比较。

但是如果`a < b`和`a == b`的结果是`false`，为什么`a <= b`和`a >= b`的结果会是`true`呢？

因为根据规范`a <= b`被处理为`b < a`，然后将结果反转。因为`b < a`的结果是`false`，所以`a <= b`的结果是`true`。

这可能与我们设想的大相径庭，即`<=`应该是“小于或者等于”。实际上JS中`<=`是“不大于”的意思（即`!(a > b)`，处理为`!(b < a)`）。同理`a >= b`处理为`b <= a`。

相等比较有严格相等，而关系比较没有“严格关系比较（strict relational comparison）”。也就是说如果要避免`a < b`中发生*隐式*强制类型转换，我们只能确保`a`和`b`有相同的类型，除此之外别无他法。

与`==`和`===`的完整性检查一样，我们应该在必要和安全的情况下使用强制类型转换，如：`42 < "43"`。换句话说就是为了保证安全，应该对关系比较中的值进行*显式强制类型转换*：

```
    var a = [ 42 ];
    var b = "043";

    a < b;                      // false -- string comparison!
    Number( a ) < Number( b );  // true -- number comparison!
```

###回顾

本章中我们介绍了JavaScript的数据类型之间的转换，即`强制类型转换`，包括*显式*和*隐式*。

强制类型转换常常为人诟病，但实际上很多时候它们是非常有用的。作为一个有责任感的JS开发人员，我们有必要深入了解强制类型转换，这样就能取其精华，去其糟粕。

*显式*强制类型转换明确告诉我们哪里发生了类型转换，它的好处是有助于提高代码的可读性和可维护性。

*隐式*强制类型转换则没有那么明显，是其它操作的副作用。感觉上好象是*显式*强制类型转换的反面，实际上*隐式*强制类型转换也有助于提高代码的可读性。

处理强制类型转换时要十分小心，特别是*隐式*强制类型转换。我们在编码的时候要知其然，还要知其所以然，并努力让代码清晰易读。