##第一章 类型

很多人认为JavaScript这样的动态语言是没有类型的。让我们看看[ES5.1规范](http://www.ecma-international.org/ecma-262/5.1/)对此怎样解释：

```
本规范中的算法所操纵的值均有相应的类型。本节中定义了所有可能出现的类型。ECMAScript类型又进一步细分为语言类型（language types）和规范类型（specification types）。
ECMAScript语言中所有的值都有一个对应的语言类型。ECMAScript语言类型包括：Undefined，Null，Boolean，String，Number，和Object。
```

喜欢强类型（又称为静态类型）语言的人也许会认为“类型（type）”一词用在这里不妥。“类型”在强类型语言中的涵义要广很多。

也有人觉得JavaScript中的“类型”应该叫“标签（tags）”或者“子类型（subtypes）”更合适。

本书中我们这样来定义类型（与规范类似）：对于语言引擎和开发人员来说，*类型*是值的内部特征，它定义了值的行为，使其能够区别于其他值。

换句话说，如果语言引擎和开发人员对`42`（数字）和`"42"`（字符串）采取不同的处理方式，那就说明它们有不同的类型，一个是`number`，一个是`string`。通常我们对数字`42`进行数学运算，而对字符串`"42"`进行字符串操作。

这样定义并非无懈可击，不过对于本书而言已经足矣，并且这也与JavaScript语言对自身的描述一致。

###类型

JavaScript有没有类型真的那么重要吗？

为了合理准确地进行类型转换（见`第四章`），我们必须正确理解各个类型及其内部行为特征。几乎所有的JS程序都会涉及各式各样的强制类型转换，我们在处理这些情况时需要有充分的把握和信心。

如果要将`number``42`当作`string`来处理，比如获得其中第二个字符`"2"`，我们就需要先将其从`number`转换（强制类型转换）为`string`。

这看似简单明了，然而强制类型转换的方式可以有很多种。有些是显式的，比较好理解，也很安全。但如果稍不留神，强制类型转换就可能会产生意想不到的结果。

强制类型转换是令JavaScript开发人员最头疼的地方之一。它经常被人诟病为语言设计上的缺陷，太过*危险*，应该敬而远之。

在对JavaScript的类型有了一个全面的了解之后，我们或许能够改变对它的成见，认识到它的威力和好处，并且明白为什么强制类型转换的缺点被过分放大了。不过首先我们需要深入学习值（values）和类型（types）。

###内置类型

JavaScript有七种内置类型：

- 空值 null
- 未定义 undefined
- 布尔值 boolean
- 数字 number
- 字符串 string
- 对象 object
- 标识 symbol（ES6中新增）

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">除<i>object</i>之外，其他统称为基本类型。</td>
    </tr>
</table>

我们用`typeof`运算符来检测值的类型，它返回类型的字符串值。有趣的是以上七种类型和它们的字符串值并不一一对应：

```
    typeof undefined    === "undefined";    // true
    typeof true         === "boolean";      // true
    typeof 42           === "number";       // true
    typeof "42"         === "string";       // true
    typeof { life: 42 } === "object";       // true
    
    // added in ES6!
    typeof Symbol()     === "symbol";       // true
```

以上六种类型均有同名的字符串值与之对应。`Symbol`是ES6中新加入的类型，我们将在`第三章`中介绍。

你可能注意到类型`null`不在此列。它比较*特殊*，`typeof`针对它的返回结果有bug：

```
    typeof null === "object"; // true
```

正确的返回结果应该是`"null"`，这个bug由来已久，已经存在了将近20年，也许永远也不会被修复，因为牵涉到太多的Web系统，“修复”它会*产生*更多的bug，从而导致大量系统无法正常工作。

我们需要使用复合条件来检测`null`值的类型，：

```
    var a = null;

    (!a && typeof a === "object"); // true
```

`null`是基本类型中唯一的一个“假值”（falsy，也称作false-like，见`第四章`）类型，`typeof`对其仍旧返回`"object"`。

`typeof`的返回值还有一种情况，即：

```
    typeof function a(){ /* .. */ } === "function"; //
     true
```

通过上例似乎可以得出这样的结论，`function（函数）`也是JavaScript的一个内置类型。然而我们查阅规范就会知道，它实际上是`object`的一个“子类型（subtype）”。具体来说，函数是“可调用对象”（callable object），其内部有一个`[[Call]]`属性让它成为可调用对象。

函数是对象，这一点很有用，更重要的是函数还可以拥有属性。例如：

```
    function a(b,c) {
        /* .. */
    }
```

函数对象的`length`属性值是它正式声明的参数数目：

```
    a.length; // 2
```

因为该函数声明了两个命名参数（named parameters，即`b`和`c`），所以它的`length`值为`2`。

那么数组的情况又如何呢？JavaScript支持数组，那它是不是也是一个特殊类型？

```
    typeof [1,2,3] === "object"; // true
```

非也，数组也是对象。确切地说是`object`的一个子类型（见`第三章`），其中的元素按数字顺序来索引（而非一般对象那样通过字符串键值），它的`length`属性会根据元素数量自动更新。

###值和类型

JavaScript中变量是没有类型的，只有值才有。变量随时可以持有任意类型的值。

从另一个角度来理解就是JavaScript不“强制指定类型”，也就是说语言引擎不要求变量总是持有与其初始值相同类型的值。一个变量可以当前被赋予字符串类型的值，随后又被赋予数字类型的值。

值`42`的类型为`number（数字）`，其类型无法更改。值`"42"`的类型为`string（字符串）`，数字`42`可以通过*强制类型转换（coercion）*（见`第四章`）转换为字符串`"42"`。

在对变量执行`typeof`操作时，得到结果的并非是该变量的类型，而是变量持有的值的类型，因为JavaScript中变量是没有类型的。

```
    var a = 42;
    typeof a; // "number"

    a = true;
    typeof a; // "boolean"
```

`typeof`运算符总是返回字符串：

```
    typeof typeof 42; // "string"
```

`typeof 42`首先返回字符串`"number"`，然后`typeof "number"`返回`"string"`。

###undefined和“undeclared”

变量在未持有值的时候为`undefined`。此时`typeof`返回`"undefined"`：

```
    var a;

    typeof a; // "undefined"

    var b = 42;
    var c;

    // later 
    b = c;

    typeof b; // "undefined"
    typeof c; // "undefined"
```

很多人容易将“undefined”等同为“未声明（undeclared）”。然而它们在JS中大相径庭。

对于已在作用域中声明过但是还未持有值的变量，它们的值为“undefined”。对于还没有在作用域中声明过的变量，它们的值为“undeclared”。

例如：

```
    var a;

    a; // undefined
    b; // ReferenceError: b is not defined
```

浏览器对于这类情况的报错信息很让人抓狂。上面的例子中，“b is not defined”容易让人理解为“b is undefined”。因此必须再次说明，“undefined”和“is not defined”截然不同。如果浏览器象“b is not found”或“b is not declared”这样报错的话就能避免很多不必要麻烦。

`typeof`在处理未声明（undeclared）变量时的一些特异功能让人更加抓狂。例如：

```
    var a;

    typeof a; // "undefined"

    typeof b; // "undefined"
```

对于“未声明（undeclared）”（或者“not defined”）变量，`typeof`同样返回`"undefined"`。请注意虽然`b`是一个未声明变量，但`typeof b`执行时并没有报错。这是由于`typeof`一个特殊的安全防范机制所致。

如果`typeof`能对未声明变量返回“undeclared”而非“undefined”的话情况会好很多。

###typeof Undeclared

这样的安全防范机制对于在浏览器中运行的JavaScript来说还是很有用的，因为很多script文件会将变量加载到共享全局命名空间中。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px; "><img src='images/note.png'></td>
        <td style="border: none;">很多人认为全局命名空间中不应该有变量存在，所有东西都应该被封装到模块和私有／独立的命名空间中。理论上这样没错，但在现实中基本不可能，虽然其仍不失为一个值得努力的方向。好消息是ES6中加入了对模块的支持，使得我们离这一目标更近了一步。
        </td>
    </tr>
</table>

一个简单的例子是在程序中使用全局变量`DEBUG`作为“调试模式”的开关。在执行诸如输出信息到控制台这样的调试任务前，我们会检查`DEBUG`变量是否已经被声明过。最顶层的全局变量声明`var DEBUG = true`只出现在“debug.js”文件中，该文件只在开发和测试时才加载到浏览器，在生产环境中则不加载。

我们需要特别注意的是，在程序的其它地方要怎样来检查全局变量`DEBUG`才能避免出现`ReferenceError`错误。这时`typeof`的安全防范机制就成了我们的好帮手：

```
    // 这样会抛出错误
    if (DEBUG) {
        console.log( "Debugging is starting" );
    }

    // 这样是安全的
    if (typeof DEBUG !== "undefined") {
        console.log( "Debugging is starting" );
    }

```

这类检查不仅对用户定义的变量有用，对检查内建的API也很有用：

```
    if (typeof atob === "undefined") {
        atob = function() { /*..*/ };
    }
```


<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">如果要为某个缺失的功能写“polyfill”（衬垫代码或者补充代码，用来补充当前运行环境中缺失的功能），我们或许不会用<b>var atob</b>来声明变量atob。如果在<b>if</b>语句中使用<b>var atob</b>，该声明会被提升（hoisted，参见本系列的《Scope &amp; Closures》一书）到作用域（当前脚本或函数的作用域）的最顶层，即使<b>if</b>条件不成立时也是如此（因为atob全局变量已经存在）。在一些浏览器中，对于一些特殊的内建全局变量（通常被称为“宿主对象，host objects”），这样重复声明会报错。去掉<b>var</b>则可以防止声明被提升。
        </td>
    </tr>
</table>

另外有一种不通过`typeof`的安全防范机制来检查全局变量是否已经存在的方法，即检查全局变量是否也是全局对象中的属性，在浏览器中该全局对象是`window`。所以前面的例子也可以这样来实现：

```
    if (window.DEBUG) {
        // ..
    }
    
    if (!window.atob) {
        // ..
    }
```

与未声明变量不同，访问不存在的对象属性并不会产生`ReferenceError`错误。

许多开发人员会尽量避免使用`window`来访问全局对象，尤其是当代码需要运行在多种JS环境下时（不仅是浏览器，还有服务器端，如node.js等），因为此时全局对象并非总是`window`。

从技术角度来说，`typeof`的安全防范机制对于非全局变量仍然是有用的，虽然这种情况很少见，也有一些开发人员不大愿意这样做。如果你想让其他人在他们的程序中拷贝粘贴你的工具函数，你就需要在函数中做一些检查来确定某些变量是否已经在宿主程序中定义过：

```
    function doSomethingCool() {
        var helper =
            (typeof FeatureXYZ !== "undefined") ?
            FeatureXYZ :
            function() { /*.. default feature ..*/ };

        var val = helper();
        // .. 
    }
```

`doSomethingCool()`检查变量`FeatureXYZ`是否已存在，如果是就使用之，否则使用自己定义的版本。如果其他模块和程序使用到这个函数，它会检查变量`FeatureXYZ`是否已在宿主程序中定义，从而让代码更安全：

```
    // an IIFE (see the "Immediately Invoked Function Expressions"
    // discussion in the Scope & Closures title in this series)
    (function(){
        function FeatureXYZ() { /*.. my XYZ feature ..*/ }

        // include `doSomethingCool(..)`
        function doSomethingCool() {
            var helper =
                (typeof FeatureXYZ !== "undefined") ?
                FeatureXYZ :
                function() { /*.. default feature ..*/ };

            var val = helper();
            // .. 
        }
        
        doSomethingCool();
    })();
```

这里`FeatureXYZ`并不是一个全局变量，但我们还是使用`typeof`的安全防范机制来做检查。关键是我们没有全局对象可用（如前面提到的`windows.___`），因此`typeof`在这种情况下很管用。

一些开发人员倾向使用一种叫“依赖注入”（dependency injection）的设计模式，即将需要的对象作为参数显式地传递进来，而不是通过函数`doSomethingCool()`来检查变量`FeatureXYZ`是否已经定义过，如：

```
    function doSomethingCool(FeatureXYZ) {
        var helper = FeatureXYZ ||
            function() { /*.. default feature ..*/ };
        var val = helper();
        // ..
    }
```

实现此类检查的方法有很多。它们各有利弊，没有对错之分。总的来说`typeof`的安全机制为我们提供了更多选择。

###回顾

JavaScript有七种内置类型：`null`，`undefined`，`boolean`，`number`，`string`，`object`，和`symbol`。可以使用`typeof`运算符来查看。

变量没有类型，但它们持有的值有类型。类型定义了值的内在行为特征。

很多开发人员将“undefined“和“undeclared”混为一谈，但是在JavaScript中它们完全不同。`undefined`是一种变量可以持有的值。“undeclared”表示变量还没有被声明过。

不幸的是JavaScript却将它们混为一谈，在访问"undeclared"变量时这样报错：“ReferenceError:a is not defined”，对"undefined"和"undeclared"变量`typeof`都返回"undefined"。

不过在某些场合使用`typeof`的安全防范机制（阻止报错）来检查未声明（undeclared）变量还是非常有用的。