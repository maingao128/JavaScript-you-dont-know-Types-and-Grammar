###附录A
<hr>
##混合环境JavaScript

除了我们之前介绍过的核心的语言机制，你的JS程序在实际运行中还会出现一些差异。如果JS程序仅是在引擎中运行的话，它是严格遵循规范并且可以预测的。但是JS程序几乎总是运行在宿主环境中，这使得它一定程度上变得不可预测。

例如当你的代码和其他第三方代码一起运行，或者当你的代码在不同的JS引擎上运行（并非仅仅是浏览器），在有些情况下会出现差异。

下面我们将就此做一些介绍。

###Annex B(ECMAScript)

JavaScript语言的官方名称是ECMAScript（指的是管理它的ECMA标准），这一点不太为人所知。那么“JavaScript”又是指什么呢？JavaScript是该语言的通用称谓，更确切地说，它是该规范在浏览器上的实现。

官方ECMAScript规范包括了“Annex B”，其中介绍了由于浏览器兼容性导致的与官方规范的差异。

可以这样来理解，这些差异只存在于浏览器中。如果你的代码只会在浏览器中运行，你不会发现任何差异。否则（如果代码也在node.js，Rhino等环境中运行），或者你也不确定的时候，就需要小心对待。

下面是一些主要的兼容性差异：

- 在非严格模式中允许八进制数值常量，如`0123`（十进制的`83`）。
- `window.escape(..)`和`window.unescape(..)`让你能够escape和unescape(JJ--??)带有%分隔符的十六进制字符串。例如：`window.escape("? foo=97%&bar=3%")`的结果为`"%3Ffoo%3D97%25%26bar%3D3%25"`。
- `String.prototype.substr`和`String.prototype.substring`十分相似，除了前者第二个参数是结束位置索引（非自包含），后者第二个参数是`长度`（需要包含的字符数）。

###Web ECMAScript

`Web ECMAScript规范`中介绍了官方ECMAScript规范和目前基于浏览器的JavaScript实现之间的差异。

换句话说，其中的内容对于浏览器来说是”必需的“（考虑到兼容性），但是没有包含在官方规范的”Annex B“部分（到本书写作时）：

- <!-- 和 -->是合法的单行注释符。
- `String.prototype`中返回HTML格式字符串的附加方法：`anchor(..)`，`big(..)`，`blink(..)`，`bold(..)`，`fixed(..)`，`fontcolor(..)`，`fontsize(..)`，`italics(..)`，`link(..)`，`small(..)`，`strike(..)`，和`sub(..)`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">以上的内容在实际开发中很少使用，也不推荐，我们相对更倾向使用其他的内建DOM API和自定义工具集。</td>
    </tr>
</table>

- `RegExp`扩展：`RegExp.$1 .. RegExp.$9`（匹配组）
和`RegExp.lastMatch/RegExp["$&"]`（最近匹配）。
- `Function.prototype`附加方法：`Function.prototype.arguments`（别名为`arguments`对象）和`Function.caller`（别名为`arguments.caller`）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warnning.png'></td>
        <td style="border: none;">arguments和arguments.caller均已经被废止，所以尽可能不要使用它们。也不要使用它们的别名。</td>
    </tr>
</table>

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">一些不常见和很细微的差异我们这里就不做介绍了。如有需要，详情可参考文档“Annex B”和“Web ECMAScript”。</td>
    </tr>
</table>

通常来说出现这些差异的情况很少，所以并不需要特别担心。只是在使用它们的时候要特别注意。

###宿主对象

JS中有关变量的规则定义得很清楚，但有时候也会出现例外情况，比如自动定义的变量，以及由宿主环境（浏览器等）提供给JS引擎的变量－我们称之为“宿主对象”（包括内建对象和函数）。

例如：

```
    var a = document.createElement( "div" );
    
    typeof a;                            // "object"--as expected
    Object.prototype.toString.call( a ); // "[object HTMLDivElement]"
    
    a.tagName;                           // "DIV"
```

`a`不仅仅是一个`object`，还是一个特殊的宿主对象，因为它是一个DOM元素。其内部的`[[Class]]`值（为`"HTMLDivElement"`）来自预定义的属性（通常也是不可更改的）。

另外一个难点我们之前在`第四章`中的“假值对象”部分介绍过：一些对象在强制转换为`boolean`时会意外地成为`假值`而非`真值`，这很让人挠头。

另外一些需要我们注意的宿主对象的行为差异有：

- 无法访问正常的`object`内建方法，如`toString()`
- 无法写覆盖
- 包含一些预定义的只读属性
- 包含一些无法被其他对象this重载(JJ--??)的方法
- 其他......

在我们针对运行环境编码时，宿主对象扮演着一个十分关键的角色。但是我们对它们的特性要非常注意，因为它们常常有别于普通的JS`object`。

在我们经常打交道的宿主对象中，`console`应该是比较值得一提的，它包含了许多方法（`log(..)`，`error(..)`等）。`console`对象由宿主环境提供，以便让我们能够从代码中输出各种值。

`console`在浏览器中是输出到开发工具控制台，而在node.js和其他服务器端JS环境中则是指向JavaScript环境系统进程的标准输出（`stdout`）和标准错误输出（`stderr`）。

###全局DOM变量

你可能已经知道声明一个全局变量（使用var或者不使用）的结果并非仅仅是创建了一个全局变量，并且还会在`global`对象（在浏览器中为`window`）中创建一个同名属性。

但还有一个不太为人所知的事实是，由于浏览器演进的历史遗留的关系，在创建带有`id`属性的DOM元素的时候也会创建同名的全局变量。例如：

```
     <div id="foo"></div>
```

以及：

```
    if (typeof foo == "undefined") {
        foo = 42;        // will never run
    }

    console.log( foo );  // HTML element
```

你可能已经习惯使用`typeof`或`.. in window`来检测全局变量，认为只有JS代码才会创建它们，但是如上例所示，HTML页面中的内容也会产生全局变量，如果不注意的话很容易让你的全局变量检查变得错误百出。

这是为什么我们尽量不要使用全局变量的一个原因，如果确实要用，也要确保变量名的唯一性从而避免与其他地方的变量产生冲突，包括HTML和其他第三方代码。

###原生原型

一个广为人知的JavaScript的最佳实践之一是：不要扩展原生原型。

如果你向`Array.prototype`加入了新的方法和属性，如果它们确实有用，设计和命名都很得当，最后很有可能会被加入到JS规范当中，这样一来你所做的扩展就会与之冲突。

我自己就遇到过一个这样的例子。

当时我正在为一些网站开发一个嵌入式构件，基于jQuery（基本上所有的框架都会犯这样的错误）。基本上在所有的网站上都可以运行，但是在某个网站上彻底无法运行。

在差不多一个星期的分析调试之后，我发现这个网站有一段遗留代码，象下面这样：

```
    // Netscape 4 doesn't have Array.push
    Array.prototype.push = function(item) {
        this[this.length-1] = item;
    };
```

除了注释以外（谁还会关心Netscape 4呢？），它看起来没有什么问题，是吧？

问题在于`Array.prototype.push`在随后被加入到了规范中，并且和这段代码不兼容。标准的`push(..)`可以一次加入多个值。而这段代码中的`push`方法则只会处理第一个值。

最初加入这个方法的开发人员将其命名为`push`合情合理，但是没有意识到需要处理多个值。这相当于挖了一个坑，10年之后让我掉了进去。

从这里我们得到几个教训。

首先，不要扩展原生方法，除非你确信你的代码在运行环境中不会有冲突。如果你不是100%确定而进行扩展是非常危险的。这需要你自己仔细权衡利弊。

其次，在扩展原生方法时加入判断条件（因为你可能无意中覆盖了原来的方法）。对于前面的例子，下面的处理方式更好些：

```
    if (!Array.prototype.push) {
        // Netscape 4 doesn't have Array.push
        Array.prototype.push = function(item) {
            this[this.length-1] = item;
        };
    }
```

`if`语句确保如果JS运行环境中没有`push()`方法时才将扩展加入。这应该可以解决我的问题，但是即使这样也存在着一定的隐患：

1. 如果网站代码中的`push(..)`原本就不打算处理多个值的情况，则标准的`push(..)`出台后会导致代码运行出错。

2. 如果在`if`判断前引入了其他第三方的`push(..)`方法，并且该方法的功能不同，也会导致代码运行出错。

这里显现出一个不太为JS开发人员注意的问题：在各种第三方代码混合运行的环境中是否只应该使用现有的原生方法。

答案是否定的，但是实际上不太行得通。通常你无法重新定义所有会用到的原生方法，同时确保它们的安全。即使可以也是一种浪费。

那么我们是否应该既测试原生方法是否存在，又测试它是否执行我们想要的功能？如果测试没通过怎么办，是不是代码停止执行？

```
    // don't trust Array.prototype.push
    (function(){
        if (Array.prototype.push) {
            var a = [];
            a.push(1,2);
            if (a[0] === 1 && a[1] === 2) {
                // tests passed, safe to use!
                return; 
            }
        }

        throw Error(
            "Array#push() is missing/broken!"
        ); 
    })();
```

理论上说这个方法不错，但实际上我们不可能为每个原生函数都做这样的测试。

那怎么办呢？我们是否应该逐一做测试？还是假设一切没问题，等出现问题时再做处理？

这里没有标准答案。实际上如果我们不去自己扩展原生原型的话就不会遇到这类问题。

如果你和第三方代码都遵循上面的原则，恭喜你，你是安全的。否则你对你的程序需要多加一些谨慎和小心，以防任何可能出现的这类问题。

针对各种运行环境做单元和回归测试能够早一些发现这类问题，但是却不能够杜绝之。

###Shims／Polyfills(JJ--??)

通常来说在老版本的（不符合规范的）运行环境中扩展原生方法是唯一安全的，因为环境不太可能有变化－老版本的浏览器会被支持新规范的新版本浏览器完全替代，而非在老版本上做扩展。

如果你能够预见哪些方法将来会成为新的标准，如`Array.prototype.foobar`，你完全可以放心地使用当前的扩展版本，不是吗？

```
    if (!Array.prototype.foobar) {
        // silly, silly
        Array.prototype.foobar = function() {
            this.push( "foo", "bar" );
        }; 
    }
```

如果规范中已经定义了`Array.prototype.foobar`，并且功能和上面的代码类似，那就没有什么问题，这种情况我们称为“polyfill”（或者“shim”）。

它可以有效地为那些不符合最新规范的老浏览器填补上缺失的功能。Polyfills让你能够通过可靠的代码来支持所有你想要支持的运行环境。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">ES5-Shim是一个完整的shims／polyfills集合，能够为你的项目提供ES5基本规范支持，同样地，ES6-Shim提供了对ES6的支持。虽然我们可以通过shims／polyfills来填补新的API，但是无法填补新的语法。我们可以使用Traceur这样的工具来实现新旧语法之间的转换。</td>
    </tr>
</table>

对于那些将来可能成为标准的功能，按照大部份人赞同的方式来预先实现以便和将来的标准兼容的polyfill，我们称为“prollyfill”（probably fill）。

真正的问题在于有一些标准功能没办法被完整地polyfill／prollyfill。

JS社区存在这样的争论，是否可以对一个功能做不完整的polyfill（将无法polyfill的部分文档化），或者不做则已，要做就要达到100%符合规范。

很多人可以接受一些不完整的polyfill（如`Object.create(..)`），因为缺失的那部分也不会被用到。

一些人认为在polyfill／shim中的`if`判断里需要加入一些兼容性测试，只在被测试的功能不存在或者未通过测试时才将其替换。这也是我们区别“shim“（有兼容性测试）和”polyfill“（检查功能是否存在）的方式。

最终的答案是没有正确答案。即便使用了“安全”的做法，对原生功能进行扩展也无法做到100%安全。依赖第三方代码中的原生功能也是这样，因为这些功能有可能被扩展了。

我们在处理这些情况的时候都需要格外小心，编写健壮的代码，并且写好文档。

###<script>s

绝大部分网站／Web应用程序的代码都存放在多个文件中，通常我们在网页中使用`<scriopt src=..></script>`来加载这些文件，或者使用`<script> .. </script>`来包含内联代码（inline code）。

这些文件和内联代码是相互独立的JS程序还是一个整体呢？

答案是（也许会令人惊讶）它们的运行方式更象是相互独立的JS程序，但是也并非总是如此。

它们共享`global`对象（在浏览器中则是`window`），也就是说这些文件中的代码在这个共享的命名空间中运行，并相互交互。

如果某个`script`中定义了函数`foo()`，后面的`script`代码就可以访问并调用`foo()`，就象`foo()`在它内部被声明过一样。

但是全局变量作用域的提升机制（hoisting，参见本系列的《Scope & Closures》一书）在这些边界中不适用，因此无论是`<script> .. </script>`还是`<script src=..></script>`，下面的代码都无法运行（因为`foo()`还未被声明）：

```
    <script>foo();</script>

    <script>
      function foo() { .. }
    </script>
```

但是下面的两段代码则没问题：

```
    <script>
      foo();
      function foo() { .. }
    </script>
```

和：

```
    <script>
      function foo() { .. }
    </script>

    <script>foo();</script>
```

如果`script`中的代码（无论是内联代码还是外部代码）发生错误，它会象独立的JS程序那样停止，但是后续的`script`中的代码（仍然共享`global`）依然会接着运行，不会受影响。

你可以使用代码来动态创建`script`，将其加入到页面的DOM中，效果是一样的：

```
    var greeting = "Hello World";

    var el = document.createElement( "script" );
    
    el.text = "function foo(){ alert( greeting );\
     } setTimeout( foo, 1000 );";

    document.body.appendChild( el );
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">如果你将el.src的值设置为一个文件URL的话，就可以实现通过&lt;script src=..&gt;&lt;/script&gt;动态加载外部文件。</td>
    </tr>
</table>

内联代码和外部文件中的代码之间有一个区别，在内联代码中不可以出现`</script>`字符串，一旦出现即被视为代码块结束。因此对下面这样的代码需要非常小心：

```
    <script>
      var code = "<script>alert( 'Hello World' )</script>";
    </script>
```

看起来似乎没什么问题，但是字符串常量中的`</script>`将会被当作结束标签来处理，因此会导致错误。常用的变通方法是：

```
    "</sc" + "ript>";
```

另外需要注意的是，我们是根据代码文件的字符集属性（UTF-8，ISO-8859-8等）来解析外部文件中的代码（或者缺省字符集），而内联代码则使用其所在页面文件的字符集（或者缺省字符集）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">内联代码的script标签没有charset属性。</td>
    </tr>
</table>

`script`标签一个已经被废止的用法是在内联代码中包含HTML和XHTML格式的注释，如：

```
    <script>
    <!--
    alert( "Hello" );
    //-->
    </script>
    
    <script>
    <!--//--><![CDATA[//><!--
    alert( "World" );
    //--><!]]>
    </script>
```

现在我们已经不需要这样做了，所以不要再用继续使用它们。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">&lt;--和--&gt;（HTML格式的注释）在JavaScript中被定义为合法的单行注释分隔符（var x = 2; &lt;-- 是一行合法注释 和 --&gt; 是另一行合法注释），这时由于老的技术导致（详见之前的“Web ECMAScript”），但是不要再使用它们。</td>
    </tr>
</table>

###保留字

ES5规范在7.6.1节中定义了一些“保留字”，我们不能把它们用作变量名。这些保留字有四类：“关键字”，“预留关键字”，`null`常量，和`true`／`false``boolean`常量。

象`function`和`switch`这些都是关键字。预留关键字包括`enum`等，它们中很多已经在ES6中被用到（如`class`，`extend`等）。另外还有一些在严格模式中使用的保留字，如`interface`。

一个名为“art4theSould”的StackOverflow用户将这些保留字编成了一首`有趣的小诗`：

```
    Let this long package float,
    Goto private class if short.
    While protected with debugger case, Continue volatile interface. Instanceof super synchronized throw, Extends final export throws.

    Try import double enum?
    + False, boolean, abstract function, Implements typeof transient break! Void static, default do,

    Switch int native new.
    Else, delete null public var
    In return for const, true, char ...Finally catch byte.
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这首诗中包含了ES3中的保留字（byte, long等），它们在ES5中已经不再是保留字。</td>
    </tr>
</table>

在ES5之前，保留字也不能用来作为对象常量中的属性名称或者键值，但是现在已经没有这个限制。

例如我们不允许下面的情况：

```
    var import = "42";
```

但是下面的情况是允许的：

```
    var obj = { import: "42" };
    console.log( obj.import );
```

需要注意的是，在一些版本较老的浏览器中（主要是IE）这些规则并不完全适用，有时候将保留字用作对象属性还是会出错。所以你需要在所有要支持的浏览器中仔细测试。

###实现中的限制

JavaScript规范对于函数中参数的个数，和字符串常量的长度等并没有限制，但是由于JavaScript引擎实现的各异，规范在某些地方有一些限制。

例如：

```
    function addAll() {
            var sum = 0;
            for (var i=0; i < arguments.length; i++) {
                    sum += arguments[i];
            }
            return sum;
    }
    
    var nums = [];

    for (var i=1; i < 100000; i++) {
            nums.push(i);
    }
    
    addAll( 2, 4, 6 );           // 12
    addAll.apply( null, nums );  // should be: 499950000
```

在一些JS引擎中你会得到正确答案`499950000`，而另外一些引擎（如Safari 6.x）会产生错误“RangeError: Maximum call stack size exceeded.”。

这里我们列出一些已知的限制：

- 字符串常量中允许的最大字符数（并非只是针对字符串值）
- 可以作为参数传递到函数中的数据大小（也称为stack size，以byte为单位）
- 函数声明中的参数个数
- 未经优化的调用栈的最大层数（例如递归）：即函数调用链的最大长度
- JS程序以阻赛方式在浏览器中运行的最长时间（秒）
- 变量名的最大长度

我们并不太常会碰到这些限制，但是还是必须对它们有所了解，特别是不同的JS引擎的限制各异。

###回顾

JS语言本身有一个统一的标准，在所有浏览器／引擎中的实现也是可靠的。这时好事！

但是JavaScript很少独立运行。我们的运行环境中通常还有第三方代码，代码甚至会运行在浏览器之外的引擎／环境中。

如果我们对这些问题多加注意，就能够提高代码的可靠性和健壮性。