##第五章 语法

语法（grammar）是本书要讨论的最后一个重点。或许你觉得自己已经会用JS编程了，但是JS语法中仍然有许多容易引起误解的地方，本章将对它们做深入的介绍。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">相比“词法（syntax）”，“语法（grammar）”对读者来说可能更陌生一些。很多时候它们是同一个意思，都是对语言<i>规则</i>的定义。虽然也有一些细微差别，但是在这里可以忽略不计。JavaScript语法定义了各种词法规则（syntax rules，如：运算符和关键词等等）怎样在一起构成可运行的程序代码。换句话说，只看词法不看语法将会漏掉很多重点。所以本章我们介绍的是语法（grammar），虽然与开发人员直接打交道的是词法（syntax）。</td>
    </tr>
</table>

###语句和表达式

开发人员常常将“语句（statement）”和“表达式（expression）”看作一回事，但在这里我们要将它们区分开来，因为在JS中它们之间有一些重要的差别。

读者应该对英语中的术语更熟悉，这里我们就借用它们来说明问题。

“句子（sentence）”是完整表达某个意思的一组词，由一个或多个“短语（phrase）”组成，它们之间由标点符号和连接词（“and”和“or”等）连接起来。短语可以包含更小的短语。有些短语是不完整的，本身不表达什么意思，有些短语则相对完整，并且能够独立表达某个意思。这些规则就是英语的*语法（grammar）*。

JavaScript的语法也是这样。语句相当于句子，表达式相当于短语，运算符则相当于标点符号和连接词。

JS中的表达式可以返回一个结果值。例如：

```
    var a = 3 * 6;
    var b = a;
    b;
```

上例中，`3 * 6`是一个表达式（结果为`18`）。第二行的`a`也是一个表达式，第三行的`b`也是。表达式`a`和`b`的结果值都是`18`。

这三行代码都是包含表达式的语句。`var = 3 * 6`和`var b = a`叫做“声明语句（declaration statement）”，因为它们声明了变量（也可以赋值）。`a = 3 * 6`和`b = a`（不带`var`）叫做赋值表达式。

第三行代码只有一个表达式`b`，同时它也是一个语句（虽然没有太大意义！）。这样的情况通常叫做“表达式语句（expression statement）”。

###语句的结果值

很多人不知道语句都有一个结果值（statement completion value，`undefined`也是一个结果值）。

获得结果值最直接的方法是在浏览器开发控制台中输入语句，默认情况下控制台会显示执行的最后一条语句的结果值。

以赋值表达式`b = a`为例，其结果值是赋给`b`的值（`18`），但规范定义`var`的结果值是`undefined`。如果在控制台中输入`var a = 42`会看到结果值为`undefined`，而非`42`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从技术角度来解释更复杂一些。ES5规范12.2节“变量语句”中的<b>变量声明（VariableDeclaration）</b>算法实际上有一个返回值（是一个包含所声明变量名称的字符串，很奇特吧！？），但是这个值被<b>变量语句（VariableStatement）</b>算法屏蔽掉了（<b>for..in</b>循环除外），最后返回结果为空（即<b>undefined</b>）。</td>
    </tr>
</table>

如果你用开发控制台调试过代码（或者JavaScript REPL－－read／evaluate／print／loop工具），应该会看到很多语句的返回值显示为`undefined`，只是你可能没有探究过其中的原因。其实控制台中显示的就是语句的结果值。

但在代码中是没有办法获得这个结果值的，具体办法比较复杂，我们先要搞清楚为什么要获得语句的结果值。

先来看看其他语句的结果值。比如代码块`{ .. }`的结果值是其最后一个语句／表达式的结果。

例如：

```
    var b;
    
    if (true) {
        b = 4 + 38;
    }
```

在控制台／REPL中输入以上代码应该会显示`42`，即最后一个语句／表达式`b = 4 + 38`的结果值。

换句话说就是代码块的结果值就如同一个*隐式的return*返回最后一个语句的结果值。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">与此类似，CoffeeScript中的函数也会隐式地返回最后一个语句的结果值。</td>
    </tr>
</table>

但下面这样的代码将无法运行：

```
    var a, b;
    
    a = if (true) {
        b = 4 + 38;
    };
```

因为语法不允许我们获得语句的结果值并将其赋值给另一个变量（至少目前还不行！）。

那应该怎样获得语句的结果值呢？

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">下面的代码仅为演示，不要在实际开发中这样做！</td>
    </tr>
</table>

我们可以使用万恶的`eval(..)`（又读作“evil”）来获得结果值：

```
    var a, b;

    a = eval( "if (true) { b = 4 + 38; }" );

    a;  // 42
```

这是个很不好的方法，但是能够让我们获得语句的结果值。

ES7规范有一项提案“do表达式（do expression）”，类似下面这样：

```
    var a, b;
    
    a = do {
        if (true) {
            b = 4 + 38; 
        }
    };

    a; // 42
```

上例中`do表达式`执行一个代码块（包含一个或多个语句），并且返回其中最后一个语句的结果值，然后赋值给变量`a`。

目的是把语句当作表达式来处理，语句中可以包含其他语句，不需要将语句封装为函数再调用`return`来返回值。

虽然目前还不是很重要，但随着JS语言的演进，语句的结果值可能会扮演越来越重要的角色，希望`do { .. }`表达式的引入能够减少我们对`eval(..)`这类方法的使用。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">重要的话再说一遍：不要使用eval(..)。详情见<b>《Scope &amp; Closures》</b>。</td>
    </tr>
</table>

###表达式的副作用

大部分表达式没有副作用。例如：

```
    var a = 2;
    var b = a + 3;
```

表达式`a + 3`本身没有副作用（比如改变`a`的值）。它的结果值为`5`，通过`b = a + 3`赋值给变量`b`。

最为常见的有副作用（也可能没有）的表达式是函数调用：

```
    function foo() {
        a = a + 1;
    }
    
    var a = 1;
    foo();      // 结果值: `undefined`, 副作用: `a`的值被改变
```

其它一些表达式也有副作用，比如：

```
    var a = 42;
    var b = a++;
```

`a++`做两件事，首先返回变量`a`的当前值`42`（再将该值赋给`b`），然后将`a`的值加一：

```
    var a = 42;
    var b = a++;

    a;  // 43
    b;  // 42
```

很多人会误以为变量`b`和`a`的值都是`43`，这是因为没有弄明白`++`运算符的副作用何时产生。

递增运算符`++`和递减运算符`--`都是一元运算符（unary operator，见`第四章`），它们可以出现在操作数的前面和后面：

```
    var a = 42;
    
    a++;    // 42
    a;      // 43
    
    ++a;    // 44
    a;      // 44
```

`++`在前面时，如：`++a`，它的副作用（将`a`递增）产生在表达式返回结果值之前，而`a++`的副作用产生在之后。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>++a++</b>会产生<b>ReferenceError</b>错误，因为运算符需要将产生的副作用赋值给一个变量。以<b>++a++</b>为例，它首先执行<b>a++</b>（根据运算符优先级，见下），返回<b>42</b>，然后执行<b>++42</b>，这时会产生<b>ReferenceError</b>错误，因为<b>++</b>无法在<b>42</b>这样的值上直接产生副作用。</td>
    </tr>
</table>

常有人误以为可以用括号`( )`将`a++`的副作用封装起来，例如：

```
    var a = 42;
    var b = (a++);

    a;  // 43
    b;  // 42
```

可惜不行，`( )`本身并不是一个封装表达式，不会在表达式`a++`产生副作用之后执行。即便可以，`a++`首先返回`42`，除非有表达式在`++`之后再次对`a`进行运算，否则还是不会得到`43`，`b`的值也不会是`43`。

不过有一个办法，可以用`,`（语句系列逗号运算符，statement-series comma operator）。它可以将多个独立的表达式语句串联成一个语句：

```
    var a = 42, b;
    b = ( a++, a );
    
    a;  // 43
    b;  // 43
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">由于运算符优先级的原因，<b>a++, a</b>需要放到<b>( .. )</b>中，本章后面将会介绍。</td>
    </tr>
</table>

`a++, a`中的第二个表达式`a`在`a++`之后执行，结果为`43`，并被赋值给`b`。

另一个例子是`delete`。我们在`第二章`中介绍过，`delete`用来删除`object`中的属性和`array`中的单元。通常它是以独立语句的形式出现：

```
    var obj = {
        a: 42
    };
    
    obj.a;          // 42
    delete obj.a;   // true
    obj.a;          // undefined
```

如果操作成功`delete`返回`true`，否则返回`false`。副作用是属性被从`object`中删除（或者单元从`array`中删除）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">操作成功是指对于那些不存在的以及存在且可配置（configurable，见本系列的《this &amp; Object Prototypes》第三章）的属性，delete返回true，否则返回false或者产生错误。</td>
    </tr>
</table>

最后一个有意思的例子是`=`赋值运算符。

例如：

```
    var a;
    
    a = 42;     // 42
    a;          // 42
```

`a = 42`中的`=`看上去没有副作用，实际上它的结果值是`42`，副作用是将`42`赋值给`a`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">组合赋值运算符，如<b>+=</b>和<b>-=</b>等，也同理。例如，<b>a = b += 2</b>先执行<b>b += 2</b>（即<b>b = b + 2</b>），然后结果值再被赋给<b>a</b>。</td>
    </tr>
</table>

在多个赋值语句串联（链式赋值，chained assignments）的时候，赋值表达式（和语句）的结果值就能派上用场，比如：

```
    var a, b, c;

    a = b = c = 42;
```

这里`c = 42`的结果值为`42`（副作用是`c`被赋值`42`），然后`b = 42`的结果值为`42`（副作用是`b`被赋值`42`），最后是`a = 42`（副作用是`a`被赋值`42`）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/warning.png'></td>
        <td style="border: none;">链式赋值常常被误用，例如：<b>var a = b = 42</b>，这看起来和前面的例子差不多，实则不然。如果变量<b>b</b>没有在代码作用域中正式声明过，如：<b>（var b）</b>，则<b>var a = b = 42</b>不会对变量<b>b</b>进行声明。这在严格模式（strict mode）中会产生错误或者是无意中创建了一个全局变量（见本系列的<b>《Scope &amp; Closures》</b>一书）。</td>
    </tr>
</table>

另一个需要注意的地方是，很多开发人员喜欢这样：

```
    function vowels(str) {
        var matches;

        if (str) {
            // pull out all the vowels
            matches = str.match( /[aeiou]/g );

            if (matches) {
                return matches;
            } 
        }
    }
    
    vowels( "Hello World" ); // ["e","o","o"]
```

然而我们也可以通过赋值语句的副作用将两个`if`语句合二为一：

```
    function vowels(str) {
        var matches;

        // pull out all the vowels
        if (str && (matches = str.match( /[aeiou]/g ))) {
            return matches;
        }
    }

    vowels( "Hello World" ); // ["e","o","o"]
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">将<b>matches = str.match..</b>放到<b>( .. )</b>中是必要的。原因在<b>第137页“运算符优先级”</b>一节中会介绍。</td>
    </tr>
</table>

我偏向更简短的后者，因为它体现了两个条件的关联性。不过这只是个人偏好，无关对错。

###上下文规则

JavaScript语法规则有时对于同样的语法在不同的情况下有不同的解释。如果孤立地来理解这些规则会很吃力。

在这里我们不一一列举，只介绍一些常见情况。

####大括号

我们在下面两种情况下会用到大括号`{ .. }`（随着JS的演进会出现更多这样的情况）。

#####对象常量

用大括号定义`object`常量（object literals）：

```
    // assume there's a `bar()` function defined

    var a = {
        foo: bar()
    };
```

因为`{ .. }`被赋值给`a`，所以它是一个`object`常量。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>a</b>是赋值的目标，称为“左值”（l-value）。<b>{ .. }</b>是所赋的值（即本例中赋给变量<b>a</b>的值），称为“右值”（r-value）。</td>
    </tr>
</table>

#####标签

如果将上例中的`var a =`去掉会发生什么情况呢？

```
    // assume there's a `bar()` function defined
    {
        foo: bar()
    }
```

许多开发人员认为此处的`{ .. }`只是一个孤立的`object`常量，并没有被赋值。实际上完全不是这样。

`{ .. }`在这里只是一个普通的代码块。这在JavaScript中并不多见（在其他语言中则常见得多！），但在语法上是完全合法的，特别是和`let`（块作用域声明）一起使用时非常有帮助（见本系列的*《Scope & Closures》*一书）。

`{ .. }`的作用和`for`／`while`循环、`if`条件语句中的代码块基本相同。

但是foo: bar()`这样奇怪的语法怎么也是合法的呢？

这里涉及到JavaScript中一个不太为人知的特性（也不建议使用），叫“标签语句（labeled statements）”。`foo`是语句`bar()`的标签（后面没有`;`，请参见本章`第146页`上的`“自动分号”`）。

如果JavaScript有`goto`语句，理论上我们可以使用`goto foo`跳转到`foo`处执行。`goto`被普遍认为是一种十分糟糕的编码方式，它会让代码变得难以理解（也叫做“spaghetti code”），好在JavaScript不支持`goto`。

不过JS通过标签跳转（labeled jumps）能够实现一定程度上的`goto`。`continue`和`break`都可以带一个标签，因此能够象`goto`那样进行跳转。例如：

```
    // `foo` labeled-loop
    foo: for (var i=0; i<4; i++) {
        for (var j=0; j<4; j++) {
            // whenever the loops meet, continue outer loop
            if (j == i) {
                // jump to the next iteration of
                // the `foo` labeled-loop
                continue foo;
            }
            
            // skip odd multiples
            if ((j * i) % 2 == 1) {
                // normal (nonlabeled) `continue` of inner loop
                continue; 
            }
            
            console.log( i, j );
        }
    }
    // 1 0
    // 2 0
    // 2 1
    // 3 0
    // 3 2
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>contine foo</b>并不是指“跳转到标签<i>foo</i>所在的位置继续执行”，而是“执行标签为<i>foo</i>循环的下一轮循环”。所以这里的<b>foo</b>并非<b>goto</b>。</td>
    </tr>
</table>

我们可以看到`continue`跳过了循环`3 1`，`continue foo`（带标签的循环跳转，labeled-loop jump）跳过了`1 1`和`2 2`。

带标签的循环跳转用处更大的地方，是和`break __`一起可以实现从内层循环跳转到外层循环。没有它们的话实现起来有时会非常麻烦：

```
    // `foo` labeled-loop
    foo: for (var i=0; i<4; i++) {
        for (var j=0; j<4; j++) {
            if ((i * j) >= 3) {
                console.log( "stopping!", i, j );
                break foo; 
            }
            
            console.log( i, j );
        }
    }
    // 0 0
    // 0 1
    // 0 2
    // 0 3
    // 1 0
    // 1 1
    // 1 2
    // stopping! 1 3
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>break foo</b>的意思不是“跳转到标签<i>foo</i>所在位置继续执行”，而是“跳出标签<i>foo</i>所在的循环／代码块，继续执行后面的代码”。因此它并非传统意义上的<b>goto</b>。</td>
    </tr>
</table>

上例中如果用不带标签的`break`的话可能需要用到一两个函数调用和共享作用域的变量等，这样代码会更难懂，此时带标签的`break`或许是更好的选择。

标签也能用于非循环代码块，但只有`break`才可以。我们可以对带标签的代码块使用`break ___`，但是不能对带标签的非循环代码块使用`continue ___`，也不能对不带标签的代码块使用`break`：

```
    // `bar` labeled-block
    function foo() {
        bar: {
                console.log( "Hello" );
                break bar;
                console.log( "never runs" );
        }
        console.log( "World" );
    }

    foo();
    // Hello
    // World
```

带标签的循环／代码块十分少见，也不建议使用，比如循环跳转也可以通过函数调用来实现。不过在某些情况下它们也能派上用场，这时请务必把注释写清楚！

JSON被普遍认为是JS语言的一个子集，`{"a":42}`这样的JSON字符串会被当作合法的JS代码（请注意JSON属性名必须使用双引号！）。实际并非如此！如果你在控制台输入`{"a":42}`会报错。

这是因为标签不允许使用双引号，所以`"a"`并不是一个合法的标签，因此后面不能带`:`。

JSON的确是JS语法的一个子集，但是JSON本身并不是合法的JS语法。

这里存在一个十分普遍的误区，即如果通过`<script src=..>`标签加载JS文件，其中只包含JSON数据（比如某个API返回的结果），它就会被当作合法的JavaScript代码来解析，只不过没有办法被访问到（inaccessible）。JSON-P（通过把JSON数据封装为方法调用来解决这个问题，比如象`foo({"a":42})`）这样将JSON数据传递给函数）。

`{"a":42}`作为JSON值没有任何问题，但是在作为代码执行时会产生错误，因为它会被当作一个带有非法标签的语句块来执行。`foo({"a":42})`就没有问题，因为`{"a":42}`在这里是一个传递给`foo(..)`的`object`常量。因此准确地说是*JSON-P能将JSON转换为合法的JS语法*。

#####代码块

另一个常被提到的坑（涉及到强制类型转换，见`第四章`）是：

```
    [] + {}; // "[object Object]"
    {} + []; // 0
```

看似`+`运算符根据第一个操作数（`[]`或`{}`）的不同产生不同的结果。实际上不是！

第一行中的`{}`被当作一个值（空`object`）来处理。在`第四章`我们讲过，`[]`会被强制类型转换为`""`，`{}`会被强制类型转换为`"[object Object]"`。

但在第二行中，`{}`被当作一个独立的空代码块（不做任何事情）。代码块结尾不需要分号，所以这里语法没有问题。最后`+ []`将`[]`*显式强制类型转换*为`number`值`0`。

#####对象解构

从ES6开始，`{ .. }`也可用于“解构赋值（destructuring assignments）”（详情见本系列的*《ES6 & Beyond》一书*），特别是`object`的解构。例如：

```
    function getData() {
        // ..
        return {
            a: 42,
            b: "foo" 
        };
    }
    
    var { a, b } = getData();

    console.log( a, b ); // 42 "foo"
```

`{ a , b } = ..`即ES6中的解构赋值，功能相当于下面的代码：

```
    var res = getData();
    var a = res.a;
    var b = res.b;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>{ a, b }</b>实际上是<b>{ a: a, b: b }</b>的简化版本，两种写法都可以，只是<b>{ a, b }</b>更简洁。</td>
    </tr>
</table>

我们还可以使用`{ .. }`对函数的命名参数（named function arguments）做对象解构（object destructuring），方便从对象属性隐式地赋值：

```
    function foo({ a, b, c }) {
        // no need for:
        // var a = obj.a, b = obj.b, c = obj.c
        console.log( a, b, c );
    }

    foo( {
        c: [1,2,3],
        a: 42,
        b: "foo"
    } );    // 42 "foo" [1, 2, 3]
```

`{ .. }`在不同上下文中（context）的作用不同，这也是词法（syntax）和语法（grammar）的区别。掌握这些细节对我们了解JS引擎怎样解析代码很重要。

#####else if和可选代码块

很多人误以为JavaScript中有`else if`，因为我们可以这样来写代码：

```
    if (a) { 
        // ..
    }
    else if (b) {
        // .. 
    }
    else { 
        // ..
    }
```

这里涉及到一个不太为人所知的语法规则：JavaScript中没有`else if`，但如果`if`和`else`只包含单条语句，则代码块的`{ }`可以被省略。你一定见过这样的代码：

```
    if (a) doSomething( a );
```

很多JS代码检查工具建议对单条语句也应该加上`{ }`，如：

```
    if (a) { doSomething( a ); }
```

`else`也是如此，所以我们经常用到的`else if`*实际*上是这样的：

```
    if (a) { 
        // ..
    } 
    else {
        if (b) { 
            // ..
        } 
        else {
            // .. 
        }
    }
```

`if (b) { .. } else { .. }`实际上是前面那个`else`之后的一个单独语句，所以带不带`{ }`都行。换句话说就是`else if`不符合前面说的编码规范，`else`后面实际上是一个单独的`if`语句而已。

`else if`很常见，能够为我们省去一层代码缩进，所以很受欢迎。但这只是我们自己的发明创造，千万不要想当然地认为这些都是JS语法的一部分。

###运算符优先级

我们在`第四章`讲过，JavaScript中的`&&`和`||`返回它其中一个操作数的值，而不是`true`或`false`。这对于一个运算符两个操作数的情况比较好理解：

```
    var a = 42;
    var b = "foo";

    a && b; // "foo"
    a || b; // 42
```

如果是两个运算符三个操作数呢？

```
    var a = 42;
    var b = "foo";
    var c = [1,2,3];

    a && b || c; // ???
    a || b && c; // ???
```

我们需要了解超过一个运算符时表达式的执行顺序规则。

这些规则称为“运算符优先级（operator precedence）”。

估计大多数读者都觉得自己对运算符优先级已经了解得差不多了。现在我们就来做个测试，或许会有新的收获。

回顾前面的例子：

```
    var a = 42, b;
    b = ( a++, a );
    
    a;  // 43
    b;  // 43
```

如果去掉`( )`会出现什么情况呢？

```
    var a = 42, b;
    b = a++, a;

    a;  // 43
    b;  // 42
```

为什么`b`的值会不一样？

因为`,`运算符的优先级比`=`低。所以`b = a++, a`其实是`(b = a++), a`。前面说过`a++`有*后续副作用（after side effects）*，所以`b`的值是`++`对`a`做递增之前的值`42`。

这只是一个简单的例子。在使用`,`来连接一系列语句的时候，请务必记住它的优先级最低，其他操作数的优先级都比它高。

回顾前面的一个例子：

```
    if (str && (matches = str.match( /[aeiou]/g ))) {
        // ..
    }
```

这里对赋值语句使用`( )`是必要的，因为`&&`的优先级高于`=`，如果没有`( )`对其中的表达式进行绑定（bind），代码就会执行为`(str && matches) = str.match..`。这样会出错，因为`(str && matches)`的结果并不是一个变量，而是一个`undefined`值，它不能够出现在`=`的左边！

事情还没有完，再来看一个更复杂的例子（本章的下面几节都会用到）：

```
    var a = 42;
    var b = "foo";
    var c = false;

    var d = a && b || c ? c || b ? a : c && b : a;
    
    d;      // ??
```

看起来很恐怖，应该没有人会这样来写代码，不过这只是用来举例说明多个运算符串联时可能出现的一些常见问题。

上例的结果是`42`。当然我们运行一下代码就能够知道答案，但是弄明白其中的来龙去脉会更有趣。

首先要搞清楚`(a && b || c)`执行的是`(a && b) || c`还是`a && (b || c)`？它们之间有什么区别？

```
    (false && true) || true;    // true
    false && (true || true);    // false
```

事实证明它们是有区别的，`false && true || true`的执行顺序如下：

```
    false && true || true;      // true
    (false && true) || true;    // true
```

`&&`首先被执行，然后是`||`。

那执行顺序是否就一定是从左到右呢？将运算符颠倒一下看看：

```
    true || false && false;     // true

    (true || false) && false;   // false
    true || (false && false);   // true
```

事实证明`&&`先于`||`执行。原因是*运算符优先级*。

每门语言都有自己的运算符优先级。遗憾的是对JS的运算符优先级有深入了解的人不多。

如果明白其中的原由，上面的例子就是小菜一碟。但估计很多读者看到这几个例子时还是需要琢磨一番。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">遗憾的是JS规范对运算符优先级并没有一个集中的介绍。我们需要从语法规则中间逐一了解。所以我们在这里列出一些常见和有用的优先级规则。完整列表请参见<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN</a>上的“优先级列表”。</td>
    </tr>
</table>

####短路

`第四章`的注解中提到过`&&`和`||`的“短路（short circuiting）”特性。这里我们对它做一个详细的介绍。

对于`&&`和`||`来说，如果能够从左边的操作数得出结果，就可以忽略右边的操作数。我们称之为“短路（short circuited）”（即执行最短路径）。

以`a && b`为例，如果`a`是一个假值，足以决定`&&`的结果，所以没有必要再判断`b`的值。同样对于`a || b`，如果`a`是一个真值，也足以决定`||`的结果，所以没有必要再判断`b`的值。

短路很好用，也很常用，如：

```
    function doSomething(opts) {
        if (opts && opts.cool) {
            // .. 
        }
    }
```

`opts && opts.cool`中的`opts`条件判断如同一层安全保护措施，因为如果`opts`未赋值（或者不是一个`object`），表达式`opts.cool`会出错。此时利用`短路`特性，`opts`条件判断未通过，所以`opts.cool`不会执行，也就不会产生错误！

`||`也同理：

```
    function doSomething(opts) {
        if (opts.cache || primeCache()) {
            // .. 
        }
    }
```

这里我们先判断`opts.cache`是否存在，如果是则无需调用`primeCache()`，这样可以避免执行不必要的代码。

####更强的绑定

回顾一下前面多个运算符串联在一起的例子：

```
    a && b || c ? c || b ? a : c && b : a

```

其中`? :`三元运算符的优先级比`&&`和`||`是高还是低？是这样：

```
    a && b || (c ? c || (b ? a : c) && b : a)
```

还是这样？

```
    (a && b || c) ? (c || b) ? a : (c && b) : a
```

答案是后者。因为`&&`的优先级高于`||`，`||`的优先级又高于`? :`。

所以表达式`(a && b || c)`先于包含它的`? :`执行。另一种说法是`&&`和`||`比`? :`的绑定更强（bind more tightly）。如果`c ? c...`的绑定更强就会这样来执行：` a && b || (c ? c..)`。

#####关联

`&&`和`||`先于`? :`执行，如果多个相同优先级的运算符同时出现怎么办呢？它们的执行顺序是从左到右还是从右到左？

一般来说，运算符的关联（associativity）不是从左到右（left-associative）就是从右到左（right-associative），取决于组合（grouping）是从左开始还是从右开始。

请注意关联和执行顺序*不是*一回事。

但它为什么又和执行顺序相关呢？原因是表达式可能会产生副作用，比如函数调用：

```
    var a = foo() && bar();
```

这里`foo()`首先执行，它的返回结果决定了`bar()`是否执行。所以如果`bar()`在`foo()`之前执行整个结果会完全不同。

这是从左到右的情况（JavaScript的默认执行顺序！），与`&&`的关联无关。因为其中只有一个`&&`，所以不涉及组合和关联。

`a && b && c`这样的表达式就涉及组合（隐式），`a && b`或`b && c`会先执行。

从技术角度来说，因为`&&`是左关联（`||`也是），所以`a && b && c`会被处理为`(a && b) && c`。不过右关联`a && (b && c)`的结果也一样。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">如果<b>&amp;&amp;</b>是右关联的话会被处理为<b>a &amp;&amp; (b &amp;&amp; c)</b>。但这不是说<b>c</b>会在<b>b</b>之前执行。右关联不是指从右到左执行，而是从右到左<i>组合（grouping）</i>。任何时候执行顺序都是从左到右，a，b，然后c。</td>
    </tr>
</table>

所以`&&`和`||`是不是左关联这个问题本身并不重要，只要我们对此有一个准确的定义。

但情况并非总是这样。一些运算符在左关联和右关联时的表现截然不同。

比如`? :`（即三元运算符或者条件运算符）：

```
    a ? b : c ? d : e;
```

`? :`是右关联，它的组合顺序是以下哪一种呢？

```
• a ? b : (c ? d : e)

• (a ? b : c) ? d : e
```

答案是`a ? b : (c ? d : e)`。和`&&`和`||`不同，右关联在这里会影响到返回结果，因为`(a ? b : c) ? d : e`对有些值（并非所有值）的处理方式会有所不同。

举个例子：

```
    true ? false : true ? true : true;      // false

    true ? false : (true ? true : true);    // false
    (true ? false : true) ? true : true;    // true
```

在某些情况下这样的差别十分微妙，虽然返回的结果没有区别。例如：

```
    true ? false : true ? true : false;     // false
    
    true ? false : (true ? true : false);   // false
    (true ? false : true) ? true : false;   // false
```

这里返回的结果一样，运算符组合看似没起什么作用。然而实际情况是：

```
    var a = true, b = false, c = true, d = true, e = false;

    a ? b : (c ? d : e); // false, 执行 `a` 和 `b`
    (a ? b : c) ? d : e; // false, 执行 `a`, `b` 和 `e`
```

这里我们可以看出，`? :`是右关联，它组合的方式会影响到返回结果。

另一个右关联（组合）的例子是`=`运算符。本章前面介绍过一个串联赋值的例子：

```
    var a, b, c;

    a = b = c = 42;
```

它首先执行`c = 42`，然后是`b = ..`，最后是`a = ..`。因为是右关联，所以它实际上是这样来处理的：`a = (b = (c = 42))`。

而对于本章前面那个复杂的赋值表达式的例子：

```
    var a = 42;
    var b = "foo";
    var c = false;

    var d = a && b || c ? c || b ? a : c && b : a;
    
    d;      // 42
```

掌握了优先级和关联之后，我们就能够根据组合规则将上面的代码分解如下：

```
    ((a && b) || c) ? ((c || b) ? a : (c && b)) : a
```

也可以通过缩进显式让代码更容易理解：

```
    (
        (a && b)
            || 
        c
    )
        ?
    (
        (c || b)
            ? 
        a
            :
        (c && b)
    ) 
        :
    a
```

现在来逐一执行：

1. (a && b) 结果为`"foo"`。
2. `"foo" || c`结果为`"foo"`。
3. 第一个`?`中，`"foo"`为真值。
4. `(c || b)`结果为`"foo"`。
5. 第二个`?`中，`"foo"`为真值。
6. `a`的值为`42`。

最后结果是`42`。

#####释疑

现在你应该对运算符优先级（和关联）有了一个更深入的了解，多个运算符串联的代码也不在话下。

不过我们仍然面临着一个重要的问题，即是不是理解和遵守了运算符优先级和关联规则就万事大吉了？在必要时是否应该用`( )`来自行控制运算符的组合和执行顺序？

换句话说，尽管这些规则是可以学习和掌握的，但其中也有很多的坑，完全依赖它们来编码的话很容易掉坑里。我们是否应该使用`( )`来自行控制运算符的执行。

和`第四章`中的*隐式*强制类型转换一样，这个问题仁者见仁，智者见智。对于两者，大多人的看法都是：要么完全依赖规则编码，要么完全使用显式和自行控制的方式。

对这个问题我并没有一个明确的答案。它们各自的优缺点也都介绍过了，希望能有助于你加深理解，从而做出自己的判断。

个人认为，依赖运算符优先级／关联规则和使用`( )`自行控制两者都要兼顾，对`第四章`中的*隐式*强制类型转换也是如此，我们应该安全合理地运用它们，而非无节制地滥用。

如果我觉得`if (a && b && c) ..`没问题，就不会用`if ((a && b) && c) ..`，因为这样过于繁琐。

然而如果需要串联两个`? :`运算符的话，我就会使用`( )`来自行控制运算符的组合，让代码更清晰易读。

所以我的建议和`第四章`一样：如果运算符优先级／关联规则能够令代码更简洁，就用。如果`( )`有助于提高代码可读性，就用。

####自动分号

有时JavaScript会自动为代码行补上缺失的分号，即自动分号插入（ASI，Automatic Semicolon Insertion）。

如果代码缺失了必要的`;`将无法运行。这样的话语言的容错性不是很高。ASI能让我们忽略那些不必要的`;`。

请注意ASI只在换行符（即line break）处起作用，不会在代码行的中间插入分号。

如果JS解析器发现代码行因为缺失分号可能导致错误，就会自动补上分号。并且只有在代码行末尾与换行符之间除了空格和注释之外没有别的内容时才会这样做。

例如：

```
    var a = 42, b 
    c;
```

如果`b`和`c`之间出现`a ,`的话（可以另起一行）,`c`会被作为`var`语句的一部分来处理。在这里JS判断`b`之后应该有`;`，所以`c;`被处理为一个独立的表达式语句。

又比如：

```
    var a = 42, b = "foo";
    
    a
    b // "foo"
```

这也没问题，不会产生错误，因为ASI也适用于表达式语句。

ASI在某些情况下很有用，比如：

```
    var a = 42;

    do {
            // ..
    } while (a) // <-- 这里应该有;
    a;
```

语法规定`do..while`循环后面必须带`;`，`while`和`for`循环则不需要。很少有人会记得这一点，此时ASI就会自动补上分号。

本章前面讲过，语句代码块结尾不用带`;`，所以不需要用到ASI：

```
    var a = 42;
    
    while (a) {
        // ..
    } // <-- 这里可以没有;
    a;
```

其它涉及到ASI的情况是`break`，`continue`，`return`和`yield`（ES6）等关键字：

```
    function foo(a) {
        if (!a) return
        a *= 2;
        // .. 
    }
```

由于ASI会在`return`后面自动加上`;`，所以这里`return`语句并不包括第二行的`a *= 2`。`return`语句的跨度可以是多行，但是其后必须有换行符以外的代码：

```
    function foo(a) {
        return (
            a * 2 + 3 / 12 
        );
    }
```

同样的规则对`break`，`continue`，和`yield`也适用。

####纠错机制

我们是否应该完全依赖ASI来编码，这是JS社区中最具争议的主题之一（除此之外还有tab和空格之争）。

大多数情况下分号并非必不可少，不过`for( .. ) ..`循环头部的两个分号是必须的。

正方认为ASI机制很有用，能省略掉那些不必要的`;`，让代码更简洁。ASI让`;`变得可有可无，只要代码没问题有没有`;`都一样。

反方则认为这里面的坑太多，对缺乏经验的初学者尤其如此，自动插入`;`会无意中改变代码的逻辑。还有一些开发人员认为省略分号本身就是错误的，应该通过linter这样的工具来找出这些错误，而不是依赖于JS引擎。

仔细阅读规范我们就会发现，ASI实际上是一个“纠错（error correction）”机制。这里的错误是*解析器错误（parser error）*。换句话说ASI的目的在于提高解析器的容错性。

究竟哪些情况需要容错呢？我觉得解析器报错就意味着代码有问题。对于ASI来说，解析器报错的唯一原因就是代码中缺失了必要的分号。

我认为在代码中省略那些“不必要的分号”就意味着“这些代码解析器无法解析，但是仍然可以运行”。

仅仅为了省去一些键盘输入和追求“代码的美观”，这样做显得有点得不偿失。

这与空格和tab之争还不是一回事，后者仅涉及代码的美观，前者则关系到是应该遵循语法规则来编码，还是打规则的擦边球。

换个角度看，依赖于ASI实际上是将换行符当作有意义的“空格”来对待。在一些语言（如Python）中空格是有意义的，但这对JavaScript是否合适呢？

我认为我们应该在所有需要的地方加上分号，将对ASI的依赖降到最低。

持这种观点的并非我一个。JavaScript的作者Brendan Eich早在2012年就说过这样的话：

*ASI是一个语法纠错机制。将换行符当作有意义的字符来对待的话会遇到很多问题。我希望在1999年5月的那十天里（ECMAScript规范制定期间）我能够让换行符承载更多的意义。千万别以️为ASI真的会将换行符当作有意义的字符。*

####错误

JavaScript不仅有各种类型的运行时错误（`TypeError`，`ReferenceError`，`SyntaxError`等），它的语法中也定义了一些编译时错误。

在编译阶段发现的代码错误叫“早期错误（early errors）”。语法错误是早期错误的一种（如：`a = ,`），还有就是那些语法正确但不符合语法规则的情况。

这些错误在代码执行之前是无法用`try...catch`来捕获的，它们会导致解析（parsing）／编译（compilation）失败。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">规范没有明确规定浏览器（和开发工具）应该怎样来处理报错，因此下面的报错处理在不同的浏览器中可能会不一样，包括错误类型和错误信息。</td>
    </tr>
</table>

一个简单的例子是正则表达式常量中的语法。这里JS语法没有问题，但非法的正则表达式也会产生早期错误：

```
    var a = /+foo/;     // Error!
```

语法规定赋值对象必须是一个标识符（identifier，或者ES6中的解构表达式destructuring expression），因此下面的`42`会报错：

```
    var a;
    42 = a;     // Error!
```

ES5规范的`严格（strict）`模式中定义了很多早期错误。比如在`严格`模式中函数的参数不能重名：

```
    function foo(a,b,a) { }                 // just fine
    function bar(a,b,a) { "use strict"; }   // Error!
```

还有对象常量包含多个同名属性：

```
    (function(){
        "use strict";
        
        var a = { 
            b: 42,
            b: 43
        };          // Error!
    })();
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从语义角度来说，这些错误并非<i>词法错误（syntax errors）</i>，而是<i>语法错误（grammar errors）</i>－－因为它们在词法上是正确的。只不过由于没有<b>GrammarError</b>类型，一些浏览器也用<b>SyntaxError</b>来代替。</td>
    </tr>
</table>

####提前使用变量

ES6规范中有一个新概念叫做TDZ（Temporal Dead Zone）。

TDZ指的是代码中的变量由于还没有初始化所以不能被引用的情况。

最直观的例子是ES6规范中的`let`块作用域：

```
    {
        a = 2;      // ReferenceError!
        let a; 
    }
```

`a = 2`试图在`let a`初始化`a`之前使用该变量（作用域在`{ .. }`内），这里就是`a`的TDZ，会产生错误。

有意思的是对未声明（undeclared）变量使用`typeof`不会产生错误（参见`第一章`），但在TDZ中却会报错：

```
{
    typeof a;   // undefined
    typeof b;   // ReferenceError! (TDZ)
    let b;
}
```

###函数参数

另一个TDZ违规的例子是ES6中的参数缺省值（参见本系列的*ES6 & Beyond*）：

```
    var b = 3;

    function foo( a = 42, b = a + b + 5 ) {
        // ..
    }
```

`b = a + b + 5`在参数`b`（`=`右边的`b`，而不是函数外的那个）的TDZ中访问`b`，所以会出错。而访问`a`没有问题，因为刚好跨出了参数`a`的TDZ。

在ES6中，如果参数被省略或者值为`undefined`，则取该参数的缺省值：

```
    function foo( a = 42, b = a + 1 ) {
        console.log( a, b );
    }

    foo();              // 42 43
    foo( undefined );   // 42 43
    foo( 5 );           // 5 6
    foo( void 0, 7 );   // 42 7
    foo( null );        // null 1
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>a + 1</b>中<b>null</b>被强制类型转换为<b>0</b>。详情请参见<b>第四章</b>。</td>
    </tr>
</table>

参数被省略和被赋值`undefined`效果一样，都是取该参数的缺省值。然而它们之间还是有所区别：

```
    function foo( a = 42, b = a + 1 ) {
        console.log(
            arguments.length, a, b,
            arguments[0], arguments[1]
        );
    ￼}

    foo();                  // 0 42 43 undefined undefined
    foo( 10 );              // 1 10 11 10 undefined
    foo( 10, undefined );   // 2 10 11 10 undefined
    foo( 10, null );        // 2 10 null 10 null
```

虽然参数`a`和`b`都有缺省值，但是函数不带参数时`arguments`数组为空。

如果向函数传递`undefined`值，则`arguments`数组中会对应出现一个值为`undefined`的单元，而不是缺省值。

ES6参数缺省值会导致`arguments`数组和命名参数之间出现偏差，ES5也会出现这种情况：

```
    function foo(a) {
        a = 42;
        console.log( arguments[0] );
    }

    foo( 2 );   // 42 (linked)
    foo();      // undefined (not linked)
```

向函数传递参数时，`arguments`数组中的对应单元会和命名参数建立关联（linkage）以得到相同的值。不传递参数就不会建立关联。

但是在`严格`模式中并没有建立关联这一说：

```
    function foo(a) {
        "use strict";
        a = 42;
        console.log( arguments[0] );
    }

    foo( 2 );   // 2 (not linked)
    foo();      // undefined (not linked)
```

因此在开发中不要依赖这种关联机制，实际上它是JavaScript语言引擎底层实现的一个抽象泄露（leaky abstraction），并不是语言本身的特性。

`arguments`数组已经被废止（特别是ES6引入剩余参数`...`（rest parameters）之后，参见本系列的*《ES6 & Beyond》*），不过它并非一无是处。

在ES6之前，获得函数所有参数的唯一途径就是`arguments`数组。还可以将命名参数和`arguments`数组混用，也不会出问题，只要遵守一个原则，即*不要同时访问命名参数和其对应的`arguments`数组单元*。

```
   function foo(a) {
        console.log( a + arguments[1] ); // 安全!
    }

    foo( 10, 32 );  // 42
```

####try..finally

`try..catch`对我们来说可能已经非常熟悉了。但你是否知道`try`可以和`catch`或者`finally`配对使用，必要时两者可同时出现？

`finally`中的代码会在`try`之后执行，如果有`catch`的话则在`catch`之后执行。我们也可以将`finally`中的代码看作一个回调函数，无论出现什么情况最后一定会被调用。

如果`try`中有`return`语句会出现什么情况呢？`return`会返回一个值，那么调用该函数并得到返回值的代码是在`finally`之前还是之后执行呢？

```
    function foo() {
            try {
                return 42;
            } 
            finally {
                console.log( "Hello" );
            }

            console.log( "never runs" );
    }

    console.log( foo() );
    // Hello
    // 42
```

这里`return 42`先执行，将`foo()`函数的返回值设置为`42`。然后`try`执行完毕，接着执行`finally`。最后`foo()`函数执行完毕，`console.log(..)`显示返回值。

`try`中的`throw`也是如此：

```
    function foo() {
        try {
            throw 42; 
        }
        finally {
            console.log( "Hello" );
        }

      console.log( "never runs" );
    }

    console.log( foo() );
    // Hello
    // Uncaught Exception: 42
```

如果`finally`中抛出异常（无论是有意还是无意），函数就会在此处终止。如果此前`try`中已经有`return`设置了返回值，该值会被丢弃：

```
    function foo() {
        try {
            return 42;
        } 
        finally {
            throw "Oops!";
        }

        console.log( "never runs" );
    }
    
    console.log( foo() );
    // Uncaught Exception: Oops!
```

`continue`和`break`也是如此：

```
    for (var i=0; i<10; i++) {
        try {
            continue; 
        }
        finally {
            console.log( i );
        }
    }
    // 0 1 2 3 4 5 6 7 8 9
```

`continue`在每次循环之后、`i++`执行之前执行`console.log(i)`，所以结果是`0..9`而非`1..10`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">ES6中新加入了<b>yield</b>（参见本系列的<i>《Async &amp; Performance》</i>），可以将其视为<b>return</b>的中间版本。然而与<b>return</b>不同的是，yield在generator（ES6的另一个新特性）重新开始时才告结束，这意味着<b>try { .. yield .. }</b>并未结束，因此<b>finally</b>不会在<b>yield</b>之后立即执行。</td>
    </tr>
</table>

`finally`中的`return`会覆盖`try`和`catch`中的`return`的返回值：

```
    function foo() {
        try {
            return 42;
        } 
        finally {
            // no `return ..` here, so no override
        } 
    }
    
    function bar() {
        try {
            return 42;
        }
        finally {
            // override previous `return 42`
            return; 
        }
    }

    function baz() {
        try {
            return 42;
        } 
        finally {
            // override previous `return 42`
            return "Hello";
        }
    }

    foo();  // 42
    bar();  // undefined
    baz();  // Hello
```

通常来说，在函数中省略`return`的结果和`return;`及`return undefined;`是一样的，但是在`finally`中省略`return`则会返回前面的`return`设定的返回值。

我们还可以将`finally`和带标签的`break`混合使用（参见`第131页的“标签”`）：

```
    function foo() {
        bar: {
            try {
                return 42;
            } 
            finally {
                // break out of `bar` labeled block
                break bar;
            }
        }
        
        console.log( "Crazy" );
        
        return "Hello";
    }

    console.log( foo() );
    // Crazy
    // Hello
```

千万别这样做。用`finally`加`break`来跳过`return`会让代码变得难以理解，就算加上注释也是如此。

####switch

现在来简单介绍一下`switch`，可以把它看作`if..else if..else..`的简化版本：

```
    switch (a) {
        case 2:
                // do something
                break;
        case 42:
                // do another thing
                break;
        default:
                // fallback to here
    }
```

这里`a`与`case`表达式逐一进行比较。如果匹配就执行该`case`中的代码，直到`break`或者`switch`代码块结束。

这看起来没什么特别，但其中也有几处不太为人知的坑。

首先`a`和`case`表达式的匹配算法和`===`（见`第四章`）相同。通常`switch`的`case`中都是简单值，所以这并没有问题。

然而我们有时可能会需要通过强制类型转换来进行相等比较（即`==`，见`第四章`），这时就要做一些特殊处理：

```
    var a = "42";

    switch (true) {
        case a == 10:
                console.log( "10 or '10'" );
                break;
        case a == 42;
                console.log( "42 or '42`" );
                break;
        default:
                // never gets here
    }
    // 42 or '42'
```

除简单值以外，`case`中还可以出现各种表达式，它会将表达式的结果值和`true`进行比较。因为`a == 42`的结果为`true`，所以条件成立。

尽管可以使用`==`，但`switch`中`true`和`true`之间仍然是严格相等比较。即如果`case`表达式的结果为真值，但不是严格意义上的`true`（见`第四章`），则条件不成立。所以在这里使用`||`和`&&`就很容易掉坑里：

```
    var a = "hello world";
    var b = 10;

    switch (true) {
        case (a || b == 10):
                // never gets here
                break;
        default:
                console.log( "Oops" );
    }
    // Oops
```

因为`(a || b == 10)`的结果是`"hello world"`而非`true`，所以严格相等比较不成立。此时我们可以强制表达式返回`true`或`false`，如：`case !!(a || b == 10):`（见`第四章`）。

最后，`default`是可选的，并非必不可少（虽然惯例是如此）。`break`相关规则对`default`仍然适用：

```
    var a = 10;

    switch (a) {
            case 1:
            case 2:
                    // never gets here
            default:
                    console.log( "default" );
            case 3:
                    console.log( "3" );
                    break;
            case 4:
                    console.log( "4" );
    }
    // default
    // 3
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">之前我们介绍过，case中的break也可以带标签。</td>
    </tr>
</table>

上例中的代码是这样执行的，首先遍历并找到所有匹配的`case`，如果没有匹配则执行`default`中的代码。因为其中没有`break`，所以继续执行已经遍历过的`case 3`代码块，直到`break`为止。

理论上这种情况在JavaScript中是可能出现的，但实际上我们一般不会这样来编码。如果确实需要这样做，就应该仔细斟酌并做好注释。

###回顾

JavaScript语法规则中的许多细节需要我们多花点时间来了解。从长远来看这有助于我们更深入地掌握这门语言。

语句（statements）就象英语中的句子（sentences），而表达式（expressions）就象短语（phrases）。表达式可以是简单独立的，可能会产生副作用。

JavaScript语法规则之上是语义规则（也称作上下文）。例如，`{ }`在不同情况下的意思不尽相同，可以是语句块，`object`常量，解构赋值（ES6），或者命名函数参数（ES6）。

JavaScript详细定义了运算符的优先级（运算符执行的先后顺序）和关联（多个运算符的组合方式）。只要我们掌握了这些规则，对于怎样合理使用就能作出自己的判断。

ASI（自动分号插入）是JS引擎的代码解析纠错机制，它会在需要的地方自动插入分号来纠正解析错误。问题在于这是否意味着大多数的分号都不是必要的（可以被省略），或者因为分号缺失导致的错误都可以交给JS引擎来处理。

JavaScript中有很多错误类型，分为两大类：“早期错误”（编译时错误，无法被捕获）和“运行时错误”（可以通过`try..catch`捕获）。所有语法错误都是早期错误，程序有语法错误则无法运行。

函数参数和命名参数之间的关系非常微妙。尤其是`arguments`数组，它的抽象泄漏为我们挖了一些坑。尽量不要使用`arguments`，如果非要用的话也千万不要同时使用`arguments`和其对应的命名参数。

`finally`中代码的处理顺序需要我们多加注意。其中有一些非常有用，也容易引起困惑，特别是和带标签的代码块混用时。总之使用`finally`的目的是让代码更简洁易读，不要弄巧成拙。

`switch`相对于`if..else if..`来说更简洁，需要注意的是我们对它的理解可能还不是很透彻，不小心的话很容易掉坑里。