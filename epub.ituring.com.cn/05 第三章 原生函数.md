##第三章 原生函数

`第一章`和`第二章`中提到过JavaScript的原生函数（natives），如：`String`和`Number`。本章我们将对它们做详细介绍。

常用的原生函数有：

- String() 
- Number() 
- Boolean()
- Array()
- Object()
- Function()
- RegExp()
- Date()
- Error()
- Symbol()－ES6中加入!

它们其实就是内建函数（built-in functions）。

如果你熟悉Java语言就会发现，JavaScript中的`String()`和Java中的字符串构造函数`String(..)`非常相似，可以这样来用：

```
    var s = new String( "Hello World!" );

    console.log( s.toString() ); // "Hello World!"
```

原生函数可以被当做构造函数来使用。但是它们构造出来的对象可能会和我们设想的有出入：

```
    var a = new String( "abc" );
    
    typeof a;                            // "object" ... not "String"
    
    a instanceof String;                 // true
    
    Object.prototype.toString.call( a ); // "[object String]"
```

通过构造函数（如`new String("abc")`）创建出来的是封装了基本类型值（如`"abc"`）的封装对象。

请注意`typeof`在这里返回的是`对象`类型的子类型（subtypes）。

可以这样来查看封装对象：

```
    console.log( a );
```

由于不同浏览器在开发控制台中显示对象的方式不同（对象序列化 － object serialization），所以上面的输出结果也不尽相同。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="900px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba">
</td>
        <td style="border: none;">在本书写作时，Chrome的最新版本是这样显示的：<b>String {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}</b>，老版本这样显示：<b>String {0: "a", 1: "b", 2: "c"}</b>。最新版本的Firefox这样显示：<b>String ["a","b","c"]</b>，老版本这样显示：<b>"abc"</b>，并且可以点击打开对象查看器。这些输出结果随着浏览器的演进不断变化。</td>
    </tr>
</table>

再次强调，`new String("abc")`创建的是字符串`"abc"`的封装对象，而非基本类型值`"abc"`。

###内部属性[[Class]]

所有`typeof`返回值为`"object"`的对象（如`数组`）都包含一个内部属性`[[Class]]`（我们可以把它看作是一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般是通过`Object.prototype.toString(..)`来查看。例如：

```
    Object.prototype.toString.call( [1,2,3] );
    // "[object Array]"

    Object.prototype.toString.call( /regex-literal/i );
    // "[object RegExp]"
```

上例中数组的内部`[[Class]]`属性值是`"Array"`，正则表达式的值是`"RegExp"`。多数情况下对象的内部`[[Class]]`属性和创建该对象的内建原生构造函数相对应（见下），但非总是如此。

那么基本类型值呢？我们先来看看`null`和`undefined`：

```
    Object.prototype.toString.call( null );
    // "[object Null]"
    
    Object.prototype.toString.call( undefined );
    // "[object Undefined]"
```

虽然并不存在`Null()`和`Undefined()`这样的原生构造函数，但是内部`[[Class]]`属性值仍然是`"Null"`和`"Undefined"`。

对于其他基本类型值来说情况又有所不同，如：`string`，`number`，和`boolean`，通常称为“包装（boxing）”（参见`第42页的“封装对象包装”`）：

```
    Object.prototype.toString.call( "abc" );
    // "[object String]"
    
    Object.prototype.toString.call( 42 );
    // "[object Number]"
    
    Object.prototype.toString.call( true );
    // "[object Boolean]"
```

上例中的基本类型值自动被包装（boxed）为对应的封装对象，所以它们的内部`[[Class]]`属性值分别为`"String"`，`"Number"`，和`"Boolean"`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从ES5到ES6，<a>toString()</a>和<a>[[Class]]</a>发生了一些变化，我们将会在本系列的<i>《ES6 &amp; Beyond》</i>一书中详细介绍。</td>
    </tr>
</table>

###封装对象包装

封装对象（object wrappers）扮演着十分重要的角色。因为基本类型值没有`.length`和`.toString()`这样的属性和方法，需要通过封装对象才能访问，此时JS会自动为基本类型值*包装*（box或者wrap）一个封装对象：

```
    var a = "abc";
    
    a.length; // 3
    a.toUpperCase(); // "ABC"
```

如果我们需要经常用到`string`中的属性和方法，比如在`for`循环中使用`i < a.length`，从一开始就创建一个封装对象可能更好些，这样JS引擎就不必每次自动创建封装对象了。

但实际上这并不是一个好办法。因为浏览器早就为`.length`这样的常见情况做了性能优化，试图通过直接使用封装对象的方式来“提前优化（preoptimize）”代码*反而会降低执行效率*。

通常我们不用直接使用封装对象。最好是让JS引擎自己决定什么时候使用。换言之就是应该优先考虑使用`"abc"`和`42`这样的基本类型值，而非`new String("abc")`和`new Number(42)`。

###封装对象释疑

使用封装对象时需要特别注意一些地方。

例如`Boolean`：

```
    var a = new Boolean( false );
    
    if (!a) {
        console.log( "Oops" ); // never returns
    }
```

这里的问题在于我们为`false`值创建了一个封装对象，但对象本身是真值（“truthy”，即总是返回`true`，见`第四章`），所以使用封装对象和使用`false`值的结果大相径庭。

如果想要自行封装基本类型值，可以使用`Object(..)`函数（不带`new`）：

```
    var a = "abc";
    var b = new String( a );
    var c = Object( a );

    typeof a; // "string"
    typeof b; // "object"
    typeof c; // "object"
    
    b instanceof String; // true
    c instanceof String; // true

    Object.prototype.toString.call( b ); // "[object String]"
    Object.prototype.toString.call( c ); // "[object String]"
```

重要的话说再说一遍，通常不推荐直接使用封装对象（如上例中的`b`和`c`），不过它们在某些情况下可能会派上用场。

###拆封

如果想要得到封装对象中的基本类型值，可以使用`valueOf()`函数：

```
    var a = new String( "abc" );
    var b = new Number( 42 );
    var c = new Boolean( true );

    a.valueOf(); // "abc"
    b.valueOf(); // 42
    c.valueOf(); // true
```

在需要用到封装对象中的基本类型值时会发生隐式（implicitly）拆封（unboxing）。这个过程（`强制类型转换，coercion`）我们将在`第四章`详细介绍。

```
    var a = new String( "abc" );
    var b = a + ""; // `b` has the unboxed primitive value "abc"
    
    typeof a;       // "object"
    typeof b;       // "string"
```

###使用原生函数作为构造函数

对于`array`，`object`，`function`，和`regular-expression（正则表达式）`来说，我们一般倾向通过常量的方式来创建值，实际上使用常量和使用构造函数的效果是一样的（创建的值都是通过封装对象来包装）。

前面讲过我们应该尽量避免使用这些构造函数，除非确实有必要，因为它们时常会产生意想不到的结果。

####Array(..)

```
    var a = new Array( 1, 2, 3 );
    a; // [1, 2, 3]

    var b = [1, 2, 3];
    b; // [1, 2, 3]
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">构造函数<b>Array(..)</b>不要求必须带<b>new</b>关键字。没有时它会被自动加上。因此<b>Array(1,2,3)</b>和<b>new Array(1,2,3)</b>的效果是一样的。</td>
    </tr>
</table>

`array`构造函数只带一个`number`参数时，该参数会被作为数组的预设长度（length），而非数组中的一个元素。

这实在不是一个明智之举，容易让人犯错。

更要命的是，`array`并没有预设长度这个概念。这样创建出来的只是一个空数组（empty array），只不过其`length`属性被设置成了指定的值。

一个数组中没有任何单元，但是它的`length`属性却显示单元的数量，这样的数据结构很奇特，会导致一些怪异的行为。这一切源于那些已被废止的旧特性（如“类数组对象”`arguments`）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">我们将至少包含一个“空单元（empty slot）”的<b>数组</b>称为“稀疏数组（sparse array）”。</td>
    </tr>
</table>

对于这种情况不同浏览器的开发调试控制台的显示结果也各异，让问题更复杂化。

例如：

```
    var a = new Array( 3 );
    
    a.length; // 3
    a;
```

`a`在Chrome中显示为`[ undefined x 3 ]`（本书写作时），意指其有三个值为`undefined`的单元，实际上并没有（“空单元 empty slots”这个叫法并不准确）。

运行下面的代码可以看出它们的差别：

```
    var a = new Array( 3 );
    var b = [ undefined, undefined, undefined ];
    var c = [];
    c.length = 3;
    
    a; 
    b; 
    c;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">我们可以创建包含空单元的数组，如上例中的<b>c</b>。如果将<b>length</b>属性设置为超过实际单元数的值，就会隐式地制造出空单元。实际上还可以通过<b>delete b[1]</b>在数组<b>b</b>的中制造出一个空单元。</td>
    </tr>
</table>

`b`在Chrome的当前版本中显示为`[ undefined, undefined, undefined ]`，而`a`和`c`则显示为`[ undefined x 3 ]`。是不是很晕？

更加糟糕的是在本书写作时，`a`和`c`在Firefox中显示为`[ , , , ]`。有没有发现什么问题？三个逗号代表了四个空单元，而非我们所想的三个。

为什么Firefox会在输出结果后面多加一个`,`！？因为从ES5开始允许在列表（数组值、属性列表等）的末尾加上一个逗号（在处理中会被忽略不计）。所以如果在代码或者调试控制台中输入`[ , , , ]`，实际得到的会是`[ , , ]`（包含三个空单元的数组）。

读到这里你或许已是一头雾水，没关系，你不是一个人在战斗！

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">对于这类情况Firefox已改为显示<b>[ <3 empty slots> ]</b>，比显示<b>[ , , , ]</b>好得多。</td>
    </tr>
</table>

不仅控制台的输出结果让人费解，更糟糕的还在后面。上例中的`a`和`b`在有些情况下表现相同，有些情况下却不同：

```
    a.join( "-" ); // "--"
    b.join( "-" ); // "--"

    a.map(function(v,i){ return i; }); // [ undefined x 3 ]
    b.map(function(v,i){ return i; }); // [ 0, 1, 2 ]
```

晕。

`a.map(..)`之所以执行失败，是因为数组中并没有任何单元，所以`map(..)`无从遍历。而`join(..)`却不一样，它的具体实现可参考下面的代码：

```
    function fakeJoin(arr,connector) {
        var str = "";
        for (var i = 0; i < arr.length; i++) {
            if (i > 0) {
                str += connector;
            }
            if (arr[i] !== undefined) {
                str += arr[i];
            } 
        }
        return str; 
    }
    
    var a = new Array( 3 );
    fakeJoin( a, "-" ); // "--"
```

可以看到，`join(..)`首先假定数组不为空，然后通过`length`属性值来遍历其中的元素。而`map(..)`并不做这样的假定，所以它对“空单元”数组的处理结果出乎意料，容易导致执行失败。

我们可以这样来创建包含`undefined`单元（而非“空单元”）的数组：

```
    var a = Array.apply( null, { length: 3 } );
    a; // [ undefined, undefined, undefined ]
```

不太好理解？下面我们详细解释一下。

`apply(..)`是一个工具函数，适用于所有函数对象，它以一种特殊的方式来调用传递给它的函数。

第一个参数是`this`对象（在本系列的<i>《this & Object Prototypes》</i>一书中有介绍），这里我们不用管它，将它设为`null`。第二个参数必须是一个`array`（或者*类似*数组的值，也叫做“类数组对象，array-like object”）。该“数组”中的值作为被调用函数的参数。

因此`Array.apply(..)`调用的是`Array(..)`函数，并且将`{ length: 3 }`中的值作为函数的参数。

我们可以想象`apply(..)`内部有一个`for`循环（和前面的`join(..)`类似），从`0`开始循环到`length`（本例中为`3`，即循环到`2`，不包括`3`）。

假如在`apply(..)`中数组对象参数名为`arr`，那么`for`循环会通过`arr[0]`，`arr[1]`，`arr[2]`来遍历该数组。由于`{ length: 3 }`中并不存在这些属性，所以返回值为`undefined`。

换句话说，我们实际上调用的是`Array(undefined, undefined, undefined)`，所以最后的结果是单元值为`undefined`的数组，而非空单元数组。

虽然使用`Array.apply( null ,{ length: 3 } )`来创建单元值为`undefined`的数组显得有些奇怪和繁琐，但是远比用`Array(3)`更好、更可靠。

总之就是一句话：*永远*不要创建和使用空单元数组。

###Object(..)，Function(..)，和RegExp(..)

`Object(..)`／`Function(..)`／`RegExp(..)`这些构造函数除非确实有必要，否则尽量不要使用：

```
    var c = new Object();
    c.foo = "bar";
    c; // { foo: "bar" }

    var d = { foo: "bar" };
    d; // { foo: "bar" }
    
    var e = new Function( "a", "return a * 2;" );
    var f = function(a) { return a * 2; }
    function g(a) { return a * 2; }
    
    var h = new RegExp( "^a*b+", "g" );
    var i = /^a*b+/g;
```

实际操作中我们并没有必要使用`new Object()`来创建对象，这样就无法象常量形式（literal 
form）那样一次设定多个属性，而必须逐一设定。

构造函数`Function`在少数情况下很有用，比如需要动态定义函数参数和函数体的时候。不要把`Function(..)`当做`eval(..)`的替代品来使用。我们基本上不会用这种方式来定义函数。

强烈建议使用常量形式（如：`/^a*b+/g`）来定义正则表达式，这样不仅语法简单，执行效率也更高，因为JS引擎在代码执行前会对它们进行预编译和缓存。与前面的构造函数不同，`RegExp(..)`还是很有用的，比如动态定义正则表达式：

```
    var name = "Kyle";
    var namePattern = new RegExp( "\\b(?:" + name + ")+\\b", "ig" );

    var matches = someText.match( namePattern );
```

上面的情况在JS中会不时出现，这时`new RegExp("pattern","flags")`就能派上用场。

###Date(..)和Error(..)

我们经常会用到`Date(..)`和`Error(..)`这两个原生构造函数，因为没有相应的常量形式可以替代它们。

创建日期对象必须使用`new Date()`。`Date(..)`构造函数可以带参数，用来指定日期和时间，不带参数的话则使用当前日期和时间。

`Date(..)`最主要的用途是获得当前Unix系统时间（从1970年1月1日开始计算，以秒为单位）。可以通过日期对象中的`getTime()`来获得该值。

从ES5开始引入了一个更简单的方法，即静态函数`Date.now()`。对ES5之前的版本我们可以使用下面的polyfill：

```
    if (!Date.now) {
        Date.now = function(){
            return (new Date()).getTime();
        };
    }
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">如果在调用<b>Date()</b>时不带<b>new</b>关键字会得到当前日期的字符串值。规范没有规定它的具体格式，但浏览器会使用类似“Fri Jul 18 2014 00:31:02 GMT-0500 (CDT)”这样的格式来显示。</td>
    </tr>
</table>

构造函数`Error(..)`（和前面的`Array()`类似）带不带`new`关键字都一样。

创建错误对象（error object）主要是为了获得当前运行堆栈的上下文信息（在大部分JS引擎中是通过只读属性`.stack`来访问）。堆栈上下文信息包括函数调用栈信息和产生错误的代码行号，以便调试（debugging）。

错误对象通常与`throw`配合使用：

```
    function foo(x) {
        if (!x) {
            throw new Error( "x wasn't provided" );
        }
    // .. }
```

错误对象一般至少会有`message`属性，有时可能还会有其他属性（它们须被当作只读属性来使用），如：`type`。除了访问`stack`属性外，最好是直接调用`toString()`方法来获得经过格式化的方便查看的错误信息（显示调用，或者通过强制类型转换隐式调用，见`第四章`）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/suggestion.png'></td>
        <td style="border: none;">除了<b>Error(..)</b>外，还有针对某些特定错误类型的原生构造函数，如：<b>EvalError(..)</b>，<b>RangeError(..)</b>，<b>ReferenceError(..)</b>，<b>SyntaxError(..)</b>，<b>TypeError(..)</b>，和<b>URIError(..)</b>。但我们很少直接使用它们。这些构造函数在程序产生异常时会被自动调用（比如试图使用未声明的变量时会产生<b>ReferenceError</b>错误）。</td>
    </tr>
</table>

###Symbol(..)

ES6中新增了“符号”（Symbol）这一基本数据类型。符号是具有唯一性的特殊值（并不绝对保证唯一！），用作对象属性名不容易产生命名冲突。引入该类型主要是由于ES6中的一些特殊构造，我们也可以自定义符号。

符号可以被用作属性名，但是在代码中无法查看和访问符号的实际值，在调试控制台中也是如此。在调试控制台中符号会显示为`Symbol(Symbol.create)`这样的内容。

ES6中有一些预定义符号，它们是`Symbol`的静态属性，如：`Symbol.create`，`Symbol.iterator`等。我们可以这样来使用它们：

```
    obj[Symbol.iterator] = function(){ /*..*/ };
```

我们可以使用`Symbol(..)`原生构造函数来自定义符号。它有些特别，不能带`new`，否则会出错：

```
    var mysym = Symbol( "my own symbol" );
    mysym;              // Symbol(my own symbol)
    mysym.toString();   // "Symbol(my own symbol)"
    typeof mysym;       // "symbol"
    
    var a = { };
    a[mysym] = "foobar";
    Object.getOwnPropertySymbols( a );
    // [ Symbol(my own symbol) ]
```

符号虽然实际上并非私有（private）属性（通过`Object.getOwnPropertySymbols(..)`可以获得对象中的所有符号），但其主要还是用于私有和特殊属性。很多开发人员用它来替代那些有下划线前缀（_）的属性，下划线前缀通常用于命名私有和特殊属性。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;"><b>符号</b>并不是一种<b>对象</b>，它是一种简单标量基本类型。</td>
    </tr>
</table>

###原生原型（Native Prototypes）

原生构造函数有自己的`.prototype`对象，如：`Array.prototype`，`String.prototype`等。

这些对象中包含其对应子类型特有的行为特征。

例如，将基本类型`string`值封装（boxing）为字符串对象之后，就能访问`String.prototype`中定义的方法。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">根据文档约定，我们将<b>String.prototype.XYZ</b>简写为<b>String#XYZ</b>，对其他<b>.prototypes</b>也如此。</td>
    </tr>
</table>

`String#indexOf(..)`
    在字符串中找到指定子字符串的位置

`String#charAt(..)`
    获得字符串中指定位置上的字符

`String#substr(..)`，`String#substring(..)`，和` String#slice(..)`
    获得字符串的指定部分

`String#toUpperCase()`和`String#toLowerCase()`
    将字符串转换为大写和小写

`String#trim()`
    去掉字符串前后的空格，返回新的字符串

这些方法并不改变原字符串，而是返回一个新字符串。

所有字符串值都可以通过prototype delegation（参考本系列的*《this & Object Prototypes》*）来访问这些方法：

```
    var a = " abc ";
    
    a.indexOf( "c" ); // 3
    a.toUpperCase();  // " ABC "
    a.trim();         // "abc"
```

其他构造函数的prototype中包含它们各自类型特有的行为特征，比如：`Number#toFixed(..)`（将数字转换为指定长度的整数字符串），`Array#concat(..)`（合并数组）。所有的函数（function）都可以调用`Function.prototype`中的`apply(..)`，`call(..)`，和`bind(..)`。

但是有些原生原型并非普通的对象：

```
    typeof Function.prototype;          // "function"
    Function.prototype();               // it's an empty function!
    
    RegExp.prototype.toString();        // "/(?:)/" -- empty regex
    "abc".match( RegExp.prototype );    // [""]
```

要命的是这些原生原型甚至可以被修改（不光是添加属性）：

```
    Array.isArray( Array.prototype );   // true
    Array.prototype.push( 1, 2, 3 );    // 3
    Array.prototype;                    // [1,2,3]

    // don't leave it that way, though, or expect weirdness!
    // reset the `Array.prototype` to empty
    Array.prototype.length = 0;
```

这里`Function.prototype`是一个函数，`RegExp.prototype`是一个正则表达式，而`Array.prototype`是一个数组。很有意思是不是？

###使用原型作为默认值

`Function.prototype`是一个空函数，`RegExp.prototype`是一个“空”正则表达式（没有任何匹配），而`Array.prototype`是一个空数组，它们对于未赋值的变量来说是很好的缺省值。

例如：

```
    function isThisCool(vals,fn,rx) {
        vals = vals || Array.prototype;
        fn = fn || Function.prototype;
        rx = rx || RegExp.prototype;
        
        return rx.test(
            vals.map( fn ).join( "" )
        ); 
    }

    isThisCool();       // true
    
    isThisCool(
        ["a","b","c"],
        function(v){ return v.toUpperCase(); },
        /D/
    );                  // false
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从ES6开始我们不再需要使用<b> vals = vals || .. </b>这样的方式来设置缺省值了（见<b>第四章</b>），因为缺省值可以通过函数声明中的内置语法来设置（见<b>第五章</b>）。</td>
    </tr>
</table>

这样做有一点好处就是`.prototypes`已经创建好并且*只创建一次*。相比之下如果使用`[]`，`function(){}`，和`/(?:)/`作为缺省值，每次调用`isThisCool(..)`的时候这些缺省值都会被重新创建（具体取决于JS引擎，稍后可能被垃圾回收）。这样会造成内存和CPU资源的浪费。

还有一点需要注意，就是如果缺省值随后会被更改，就不要使用`Array.prototype`作为缺省值。上例中的`vals`是作为只读变量来使用，更改`vals`实际上是更改`Array.prototype`本身，这样会导致前面提到过的一系列问题！

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这里我们介绍了原生原型及其用途，使用时需要十分小心，特别是要对它们做更改时。详情请见<b>第167页，Appendix A一节的“Native Prototypes”</b>。</td>
    </tr>
</table>

###回顾

JavaScript为基本数据类型值提供了封装对象，也叫做原生函数（`String`，`Number`，`Boolean`等）。它们为基本数据类型值提供了其类型特有的方法和属性（`String#trim()`和`Array#concat(..)`）。

对于简单标量基本类型值，比方说`"abc"`，如果要访问它的`length`属性或者`String.prototype`方法，JS引擎会自动对该值进行封装（boxing，即用相应类型的封装对象来包装它）以实现对这些属性和方法的访问。