##第三章 原生函数

`第一章`和`第二章`中提到过JavaScript的原生函数（natives），如：`String`和`Number`。本章我们将对它们做详细介绍。

常用的原生函数有：

- String() 
- Number() 
- Boolean()
- Array()
- Object()
- Function()
- RegExp()
- Date()
- Error()
- Symbol()－ES6中加入!

它们其实就是内建函数（built-in functions）。

如果你熟悉Java语言就会发现，JavaScript中的`String()`和Java中的字符串构造函数`String(..)`非常相似，可以这样来用：

```
    var s = new String( "Hello World!" );

    console.log( s.toString() ); // "Hello World!"
```

原生函数可以被当做构造函数来使用。但是它们构造出来的对象可能会和我们设想的有出入：

```
    var a = new String( "abc" );
    
    typeof a;                            // "object" ... not "String"
    
    a instanceof String;                 // true
    
    Object.prototype.toString.call( a ); // "[object String]"
```

通过构造函数（如`new String("abc")`）创建出来的是封装了基本类型值（如`"abc"`）的封装对象。

请注意`typeof`在这里返回的是`对象`类型的子类型（subtypes）。

可以这样来查看封装对象：

```
    console.log( a );
```

由于不同浏览器在开发控制台中显示对象的方式不同（对象序列化 － object serialization），所以上面的输出结果也不尽相同。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="900px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba">
</td>
        <td style="border: none;">在本书写作时，Chrome的最新版本是这样显示的：<b>String {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}</b>，老版本这样显示：<b>String {0: "a", 1: "b", 2: "c"}</b>。最新版本的Firefox这样显示：<b>String ["a","b","c"]</b>，老版本这样显示：<b>"abc"</b>，并且可以点击打开对象查看器。这些输出结果随着浏览器的演进不断变化。</td>
    </tr>
</table>

再次强调，`new String("abc")`创建的是字符串`"abc"`的封装对象，而非基本类型值`"abc"`。

###内部属性[[Class]]

所有`typeof`返回值为`"object"`的对象（如`数组`）都包含一个内部属性`[[Class]]`（我们可以把它看作是一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般是通过`Object.prototype.toString(..)`来查看。例如：

```
    Object.prototype.toString.call( [1,2,3] );
    // "[object Array]"

    Object.prototype.toString.call( /regex-literal/i );
    // "[object RegExp]"
```

上例中数组的内部`[[Class]]`属性值是`"Array"`，正则表达式的值是`"RegExp"`。多数情况下对象的内部`[[Class]]`属性和创建该对象的内建原生构造函数相对应（见下），但非总是如此。

那么基本类型值呢？我们先来看看`null`和`undefined`：

```
    Object.prototype.toString.call( null );
    // "[object Null]"
    
    Object.prototype.toString.call( undefined );
    // "[object Undefined]"
```

虽然并不存在`Null()`和`Undefined()`这样的原生构造函数，但是内部`[[Class]]`属性值仍然是`"Null"`和`"Undefined"`。

其他基本类型值（如：`字符串`，`数字`，和`布尔`）的情况有所不同，通常称为“包装（boxing）”（参见`第42页的“封装对象包装”`）：

```
    Object.prototype.toString.call( "abc" );
    // "[object String]"
    
    Object.prototype.toString.call( 42 );
    // "[object Number]"
    
    Object.prototype.toString.call( true );
    // "[object Boolean]"
```

上例中基本类型值被自动包装（boxed）为对应的封装对象，所以它们的内部`[[Class]]`属性值分别为`"String"`，`"Number"`，和`"Boolean"`。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="300px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba">
</td>
        <td style="border: none;">从ES5到ES6，<b>toString()</b>和<b>[[Class]]</b>发生了一些变化，详情见本系列的<i>《ES6 &amp; Beyond》</i>一书。</td>
    </tr>
</table>

###封装对象包装

封装对象（object wrappers）扮演着十分重要的角色。因为基本类型值没有`.length`和`.toString()`这样的属性和方法，需要通过封装对象才能访问，此时JS会自动为基本类型值*包装*（box或者wrap）一个封装对象：

```
    var a = "abc";
    
    a.length; // 3
    a.toUpperCase(); // "ABC"
```

如果需要经常用到这些`字符串`属性和方法，比如在`for`循环中使用`i < a.length`，从一开始就创建一个封装对象也许更方便，这样JS引擎就不用每次都自动创建了。

但实际上这样并不好。因为浏览器已经为`.length`这样的常见情况做了性能优化，直接使用封装对象来“提前优化（preoptimize）”代码*反而会降低执行效率*。

我们一般不需要直接使用封装对象。最好的办法是让JS引擎自己决定什么时候应该使用封装对象。换句话说就是应该优先考虑使用`"abc"`和`42`这样的基本类型值，而非`new String("abc")`和`new Number(42)`。

###封装对象释疑

使用封装对象时有些地方需要特别注意。

比如`Boolean`：

```
    var a = new Boolean( false );
    
    if (!a) {
        console.log( "Oops" ); // never returns
    }
```

我们为`false`创建了一个封装对象，然而对象本身是真值（“truthy”，即总是返回`true`，见`第四章`），所以这里使用封装对象得到的结果和使用`false`截然相反。

如果想要自行封装基本类型值，可以使用`Object(..)`函数（不带`new`）：

```
    var a = "abc";
    var b = new String( a );
    var c = Object( a );

    typeof a; // "string"
    typeof b; // "object"
    typeof c; // "object"
    
    b instanceof String; // true
    c instanceof String; // true

    Object.prototype.toString.call( b ); // "[object String]"
    Object.prototype.toString.call( c ); // "[object String]"
```

再次强调，一般我们不推荐直接使用封装对象（如上例中的`b`和`c`），不过它们可能偶尔会派上用场。

###拆封

如果想要得到封装对象中的基本类型值，可以使用`valueOf()`函数：

```
    var a = new String( "abc" );
    var b = new Number( 42 );
    var c = new Boolean( true );

    a.valueOf(); // "abc"
    b.valueOf(); // 42
    c.valueOf(); // true
```

在需要用到封装对象中的基本类型值的地方会发生隐式拆封（implicitly unboxing）。具体过程（`强制类型转换，coercion`）我们将在`第四章`详细介绍。

```
    var a = new String( "abc" );
    var b = a + ""; // `b` has the unboxed primitive value "abc"
    
    typeof a;       // "object"
    typeof b;       // "string"
```

###使用原生函数作为构造函数

对于`数组（array）`，`对象（object）`，`函数（function）`，和`正则表达式（regular-expression）`来说，我们通常喜欢以常量的形式来创建它们，实际上使用常量和使用构造函数的效果是一样的（创建的值都是通过封装对象来包装）。

前面说过我们应该尽量避免使用这些构造函数，除非十分必要，因为它们经常会产生意想不到的结果。

####Array(..)

```
    var a = new Array( 1, 2, 3 );
    a; // [1, 2, 3]

    var b = [1, 2, 3];
    b; // [1, 2, 3]
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="300px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">构造函数<b>Array(..)</b>不要求必须带<b>new</b>关键字。不带时它会被自动补上。因此<b>Array(1,2,3)</b>和<b>new Array(1,2,3)</b>的效果是一样的。</td>
    </tr>
</table>

`Array`构造函数只带一个`数字`参数的时候，该参数会被作为数组的预设长度（length），而非数组中的一个元素。

这实在不是一个明智之举，一是容易忘记，二是容易弄错。

更要命的是，`数组`并没有预设长度这个概念。这样创建出来的只是一个空数组（empty array），只不过它的`length`属性被设置成了指定的值。

一个数组中没有任何单元，但它的`length`属性中却有单元数量，这样奇特的数据结构会导致一些怪异的行为。这一切归咎于那些已被废止的旧特性（象`arguments`这样的“类数组”）。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="200px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">我们将包含至少一个“空单元（empty slot）”的<b>数组</b>称为“稀疏数组（sparse array）”。</td>
    </tr>
</table>

对此不同浏览器的开发控制台显示的结果不同，让问题变得更加复杂。

例如：

```
    var a = new Array( 3 );
    
    a.length; // 3
    a;
```

`a`在Chrome中显示为`[ undefined x 3 ]`（目前为止），意思是它有三个值为`undefined`的单元，实际上并不是这样（“空单元 － empty slots”这个叫法并不准确）。

从下面代码的结果可以看出它们的差别：

```
    var a = new Array( 3 );
    var b = [ undefined, undefined, undefined ];
    var c = [];
    c.length = 3;
    
    a; 
    b; 
    c;
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="500px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">我们可以创建包含空单元的数组，如上例中的<b>c</b>。如果将<b>length</b>属性设置为超过实际单元数的值，就会隐式地制造出空单元。另外还可以通过<b>delete b[1]</b>在数组<b>b</b>中制造出一个空单元。</td>
    </tr>
</table>

`b`在当前版本的Chrome中显示为`[ undefined, undefined, undefined ]`，`a`和`c`则显示为`[ undefined x 3 ]`。是不是很晕？

更晕的是在当前版本的Firefox中`a`和`c`显示为`[ , , , ]`。其中有三个逗号，代表四个空单元，而不是三个。

Firefox在输出结果后面多加了一个`,`，原因是从ES5开始规范允许我们在列表（数组值、属性列表等）末尾多加一个逗号（在实际处理中会被忽略不计）。所以如果你在代码或者调试控制台中输入`[ , , , ]`，实际得到的是`[ , , ]`（包含三个空单元的数组）。这样做是为了让拷贝粘贴结果更准确，虽然在控制台中看起来很让人费解。

读到这里你或许已是一头雾水，没关系，你不是一个人在战斗！

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="150px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">针对这种情况Firefox已改为显示<b>Array [ &lt;3 empty slots&gt; ]</b>，比<b>[ , , , ]</b>要好很多。</td>
    </tr>
</table>

更糟糕的还在后面。上例中`a`和`b`的行为有时相同，有时又不同：

```
    a.join( "-" ); // "--"
    b.join( "-" ); // "--"

    a.map(function(v,i){ return i; }); // [ undefined x 3 ]
    b.map(function(v,i){ return i; }); // [ 0, 1, 2 ]
```

`a.map(..)`之所以执行失败，是因为数组中并没有任何单元，所以`map(..)`无从遍历。而`join(..)`却不一样，它的具体实现可参考下面的代码：

```
    function fakeJoin(arr,connector) {
        var str = "";
        for (var i = 0; i < arr.length; i++) {
            if (i > 0) {
                str += connector;
            }
            if (arr[i] !== undefined) {
                str += arr[i];
            } 
        }
        return str; 
    }
    
    var a = new Array( 3 );
    fakeJoin( a, "-" ); // "--"
```

从中可以看出，`join(..)`首先假定数组不为空，然后通过`length`属性值来遍历其中的元素。而`map(..)`并不做这样的假定，所以产生出乎意料的结果。

我们可以这样来创建包含`undefined`单元（不是“空单元”）的数组：

```
    var a = Array.apply( null, { length: 3 } );
    a; // [ undefined, undefined, undefined ]
```

不明白？下面大致解释一下。

`apply(..)`是一个工具函数，适用于所有函数对象，它会以一种特殊的方式来调用传递给它的函数。

第一个参数是`this`对象（在本系列的<i>《this & Object Prototypes》</i>一书中有介绍），这里我们不用管它，设为`null`。第二个参数必须是一个`数组`（或者*类似*数组的值，也叫做“类数组对象 － array-like object”），其中的值被用作函数的参数。

于是`Array.apply(..)`调用`Array(..)`函数，并且将`{ length: 3 }`作为函数的参数。

我们可以想象`apply(..)`内部有一个`for`循环（和前面的`join(..)`类似），从`0`开始循环到`length`（这里是`3`，即循环到`2`，不包括`3`）。

假设在`apply(..)`内部该数组参数名为`arr`，`for`循环就会这样来遍历数组：`arr[0]`，`arr[1]`，`arr[2]`。由于`{ length: 3 }`中并不存在这些属性，所以返回值为`undefined`。

换句话说，我们执行的实际上是`Array(undefined, undefined, undefined)`，所以结果是单元值为`undefined`的数组，而非空单元数组。

虽然`Array.apply( null ,{ length: 3 } )`显得有些奇怪和繁琐，但是远比`Array(3)`更好更可靠。

总之就是一句话：*永远*不要创建和使用空单元数组。

###Object(..)，Function(..)，和RegExp(..)

除非万不得已，否则尽量不要使用`Object(..)`／`Function(..)`／`RegExp(..)`，：

```
    var c = new Object();
    c.foo = "bar";
    c; // { foo: "bar" }

    var d = { foo: "bar" };
    d; // { foo: "bar" }
    
    var e = new Function( "a", "return a * 2;" );
    var f = function(a) { return a * 2; }
    function g(a) { return a * 2; }
    
    var h = new RegExp( "^a*b+", "g" );
    var i = /^a*b+/g;
```

实际情况中我们并没有必要使用`new Object()`来创建对象，因为这样就无法象常量形式（literal 
form）那样一次设定多个属性，而必须逐一设定。

构造函数`Function`在极少数情况下很有用，比如动态定义函数参数和函数体的时候。不要把`Function(..)`当做`eval(..)`的替代品，你基本上不会需要通过这种方式来定义函数。

我们强烈建议使用常量形式（如：`/^a*b+/g`）来定义正则表达式，这样不仅语法上简单，执行效率也更高，因为JS引擎在代码执行前会对它们进行预编译和缓存。与前面的构造函数不同，`RegExp(..)`有时候还是很有用的，比如动态定义正则表达式时：

```
    var name = "Kyle";
    var namePattern = new RegExp( "\\b(?:" + name + ")+\\b", "ig" );

    var matches = someText.match( namePattern );
```

上述情况我们在JS中会不时碰到，这时`new RegExp("pattern","flags")`就能派上用场。

###Date(..)和Error(..)

`Date(..)`和`Error(..)`这两个原生构造函数的用处则大得多，因为没有对应的常量形式可以作为它们的替代。

创建日期对象必须使用`new Date()`。`Date(..)`可以带参数，用来指定日期和时间，不带参数的话则使用当前的日期和时间。

`Date(..)`主要用来获得当前的Unix时间戳（从1970年1月1日开始计算，以秒为单位）。该值可以通过日期对象中的`getTime()`来获得。

从ES5开始引入了一个更简单的方法，即静态函数`Date.now()`。对ES5之前的版本我们可以使用下面的polyfill：

```
    if (!Date.now) {
        Date.now = function(){
            return (new Date()).getTime();
        };
    }
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="500px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">如果调用<b>Date()</b>时不带<b>new</b>关键字则会得到当前日期的字符串值。它的具体格式规范没有规定，浏览器使用“Fri Jul 18 2014 00:31:02 GMT-0500 (CDT)”这样的格式来显示。</td>
    </tr>
</table>

构造函数`Error(..)`（和前面的`Array()`类似）带不带`new`关键字都可以。

创建错误对象（error object）主要是为了获得当前运行堆栈的上下文（大部分JS引擎中是通过只读属性`.stack`来访问）。堆栈上下文信息包括函数调用栈信息和产生错误的代码行号，便于调试（debugging）。

错误对象通常与`throw`一起使用：

```
    function foo(x) {
        if (!x) {
            throw new Error( "x wasn't provided" );
        }
        // .. 
    }
```

通常错误对象至少会包含`message`属性，有时还会有其他属性（必须作为只读属性访问），如：`type`。除了访问`stack`属性以外，最好的办法是调用（显示调用或者通过强制类型转换隐式调用，见`第四章`）`toString()`来获得经过格式化的便于阅读的错误信息。


<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="900px" src="/api/storage/getbykey/screenshow?key=16047bc8813535bf18e1"></td>
        <td style="border: none;"><b>Error(..)</b>之外还有一些针对特定错误类型的原生构造函数，如： <b>EvalError(..)</b>，  <b>RangeError(..)</b>，  <b>ReferenceError(..)</b>， <b>SyntaxError(..)</b>， <b>TypeError(..)</b>，和<b>URIError(..)</b>。 不过我们很少直接使用这些构造函数，它们在程序产生异常时会被自动调用（比如试图使用未声明的变量时会产生 <b>ReferenceError</b>错误）。</td>
    </tr>
</table>

###Symbol(..)

ES6中新加入了一个基本数据类型 － “符号”（Symbol）。符号是具有唯一性的特殊值（并不绝对保证唯一！），用它来命名对象属性不容易导致重名。该类型的引入主要是源于ES6的一些特殊构造，符号也可以自行定义。

符号可以用作属性名，但我们无法在代码中查看和访问符号的值，在开发控制台中也不行，会显示为诸如`Symbol(Symbol.create)`这样的值。

ES6中有一些预定义符号，以`Symbol`的静态属性的形式出现，如：`Symbol.create`，`Symbol.iterator`等，可以这样来使用：

```
    obj[Symbol.iterator] = function(){ /*..*/ };
```

我们可以使用`Symbol(..)`原生构造函数来自定义符号。它比较特别，不能带`new`，否则会出错：

```
    var mysym = Symbol( "my own symbol" );
    mysym;              // Symbol(my own symbol)
    mysym.toString();   // "Symbol(my own symbol)"
    typeof mysym;       // "symbol"
    
    var a = { };
    a[mysym] = "foobar";
    Object.getOwnPropertySymbols( a );
    // [ Symbol(my own symbol) ]
```

虽然符号实际上并非私有（private）属性（通过`Object.getOwnPropertySymbols(..)`可以获得对象中的所有符号），但它主要还是用于私有和特殊属性。很多开发人员用它来替代那些有下划线前缀（_）的属性，下划线前缀通常用于命名私有和特殊属性。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="150px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;"><b>符号</b>并不是<b>对象</b>，它是一种简单标量基本类型。</td>
    </tr>
</table>

###原生原型（Native Prototypes）

原生构造函数有自己的`.prototype`对象，如：`Array.prototype`，`String.prototype`等。

这些对象包含其对应子类型特有的行为特征。

例如，将`字符串`值封装（boxing）为字符串对象之后，就能访问`String.prototype`中定义的方法。

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img width="300px" src="/api/storage/getbykey/screenshow?key=1604a41b2abfdacaddba"></td>
        <td style="border: none;">根据文档约定，我们将<b>String.prototype.XYZ</b>简写为<b>String#XYZ</b>，对其他<b>.prototypes</b>也如此。</td>
    </tr>
</table>

`String#indexOf(..)`
    在字符串中找到指定子字符串的位置

`String#charAt(..)`
    获得字符串指定位置上的字符

`String#substr(..)`，`String#substring(..)`，和` String#slice(..)`
    获得字符串的指定部分

`String#toUpperCase()`和`String#toLowerCase()`
    将字符串转换为大写和小写

`String#trim()`
    去掉字符串前后的空格，返回一个新的字符串

这些方法并不改变原字符串的值，而是返回一个新字符串。

所有字符串都可以通过原型代理（prototype delegation，参考本系列的*《this & Object Prototypes》*一书）来访问这些方法：

```
    var a = " abc ";
    
    a.indexOf( "c" ); // 3
    a.toUpperCase();  // " ABC "
    a.trim();         // "abc"
```

其他构造函数的prototype中包含它们各自类型特有的行为特征，比如：`Number#toFixed(..)`（将数字转换为指定长度的整数字符串），`Array#concat(..)`（合并数组）。所有的函数（function）都可以调用`Function.prototype`中的`apply(..)`，`call(..)`，和`bind(..)`。

但是有些原生原型并非普通的对象：

```
    typeof Function.prototype;          // "function"
    Function.prototype();               // it's an empty function!
    
    RegExp.prototype.toString();        // "/(?:)/" -- empty regex
    "abc".match( RegExp.prototype );    // [""]
```

要命的是这些原生原型甚至可以被修改（不光是添加属性）：

```
    Array.isArray( Array.prototype );   // true
    Array.prototype.push( 1, 2, 3 );    // 3
    Array.prototype;                    // [1,2,3]

    // don't leave it that way, though, or expect weirdness!
    // reset the `Array.prototype` to empty
    Array.prototype.length = 0;
```

这里`Function.prototype`是一个函数，`RegExp.prototype`是一个正则表达式，而`Array.prototype`是一个数组。很有意思是不是？

###使用原型作为默认值

`Function.prototype`是一个空函数，`RegExp.prototype`是一个“空”正则表达式（没有任何匹配），而`Array.prototype`是一个空数组，它们对于未赋值的变量来说是很好的缺省值。

例如：

```
    function isThisCool(vals,fn,rx) {
        vals = vals || Array.prototype;
        fn = fn || Function.prototype;
        rx = rx || RegExp.prototype;
        
        return rx.test(
            vals.map( fn ).join( "" )
        ); 
    }

    isThisCool();       // true
    
    isThisCool(
        ["a","b","c"],
        function(v){ return v.toUpperCase(); },
        /D/
    );                  // false
```

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">从ES6开始我们不再需要使用<b> vals = vals || .. </b>这样的方式来设置缺省值了（见<b>第四章</b>），因为缺省值可以通过函数声明中的内置语法来设置（见<b>第五章</b>）。</td>
    </tr>
</table>

这样做有一点好处就是`.prototypes`已经创建好并且*只创建一次*。相比之下如果使用`[]`，`function(){}`，和`/(?:)/`作为缺省值，每次调用`isThisCool(..)`的时候这些缺省值都会被重新创建（具体取决于JS引擎，稍后可能被垃圾回收）。这样会造成内存和CPU资源的浪费。

还有一点需要注意，就是如果缺省值随后会被更改，就不要使用`Array.prototype`作为缺省值。上例中的`vals`是作为只读变量来使用，更改`vals`实际上是更改`Array.prototype`本身，这样会导致前面提到过的一系列问题！

<table>
    <tr style="border: none;">
        <td style="border: none; width: 150px;"><img src='images/note.png'></td>
        <td style="border: none;">这里我们介绍了原生原型及其用途，使用时需要十分小心，特别是要对它们做更改时。详情请见<b>第167页，Appendix A一节的“Native Prototypes”</b>。</td>
    </tr>
</table>

###回顾

JavaScript为基本数据类型值提供了封装对象，也叫做原生函数（`String`，`Number`，`Boolean`等）。它们为基本数据类型值提供了其类型特有的方法和属性（`String#trim()`和`Array#concat(..)`）。

对于简单标量基本类型值，比方说`"abc"`，如果要访问它的`length`属性或者`String.prototype`方法，JS引擎会自动对该值进行封装（boxing，即用相应类型的封装对象来包装它）以实现对这些属性和方法的访问。